---
layout: default
title: Files and Filesystems
last-updated: March, 2021
---

<!-- 

To Do:
    VFS (Subsection in Filesystems)
    Inodes (after Filesystems)
    Proc filesystem (in pseudofiles)
    Add reference to findmnt (in mounting and unmounting)
    Sudo/Superuser priveledges

    Describing paths:
        Basename
        Dirname
        Absolute path
        Relative path

    Directory structure:
        Root's parent is root

</div>


Filesystems:
btrfs:
http://www.internetnews.com/dev-news/article.php/3781676/A+Better+File+System+for+Linux.htm

    "The main goal is to let it {Linux} scale for the storage that will be available," Chris Mason Director of Linux Kernel Engineering at Oracle told InternetNews.com. "Scaling is not just about addressing the storage but also means being able to administer and to manage it with a clean interface that lets people see what's being used and makes it more reliable."

Filesystem Heirarchy:
    /var: 
        (Double check:) Per-runtime variable files
        https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch05.html:
            /var contains logs, transient and temporary files
            Not shareable across systems

Kerrisk calls File I/O "The Universal I/O Model"

Closing Remarks:

Not mentioned here is Linux's "Logical Volume Manager", a software layer that 
(when used) sits between disks and the filesystem and offers 
to abstract away pesky facts like, "There are six discs in a RAID array." 
The ext4/lvm software stack has proven difficult to scale, and has been a major
impetus for moving towards filesystems which include LVM capabilities.  

XDG Directory Specification
    ~/.config is defined as part of the XDG specification

Another convention: 
    Each program is typically allowed one file in important system directories 
    (e.g., <code>/etc</code>)
    If they have a single file to store, it may be stored plainly; if they
    have more than one file to store, they should make a subdirectory and
    store them within.

https://wiki.ubuntu.com/Lvm

    </ol>
        <li> Wirzenius, L. (2004). Chapter 3: Overview of the Directory Tree. In <em>Linux System Administrator's Guide.</em> <a href="https://www.tldp.org/LDP/sag/html/fs-background.html">https://www.tldp.org/LDP/sag/html/fs-background.html</a></li>
        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). The Root Filesystem. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html</a></li>


-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#files"> Files </a></li>
        <li><a href="#regular-files"> Regular Files</a></li>
        <li><a href="#device-files"> Device Files </a></li>
        <li><a href="#pseudo-files"> Psuedo Files </a></li>
        <!--<li><a href="#fifo"> FIFO </a></li>
        <li><a href="#socket"> Socket </a></li> -->
        <li><a href="#fs-heir"> Filesystem Heirarchy </a></li>
        <li><a href="#mounting-unmounting"> Mounting and Unmounting</a></li>
        <li><a href="#filesystems"> Filesystems </a></li>
        <!-- <li><a href="#vfs-and-inodes">VFS and Inodes</a></li> -->
        <li><a href="#directories"> Directories </a></li>
        <li><a href="#closing-remarks"> Closing Remarks </a></li>
        <li><a href="#udacity"> Udacity </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Files and Filesystems</h1>
    <div class="quote-text">
        "Understanding is the key to success with Linux."
    </div>
    <div class="quote-ref">
        <a href="https://www.tldp.org/LDP/sag/html/intro.html">Linux System Administrator's Guide</a>
    </div>

    <p>
        The protogenesis of Unix was a filesystem.<sup><a href=#references>[1]</a><a href="http://read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf">[2]</a></sup>
        Designed by the researchers of Bell Laboratories and
        implemented primarily by Ken Thompson,
        this piece of software became an operating system with the
        introduction of a means of interacting with, and executing, its contents.
    </p>
</div>

<div id="files" class="content">
    <h2>Files</h2>

    <p>
        In UNIX, a file is a sequence of bytes.<sup><a href=#references>[1]</a></sup>
        This definition is sufficiently abstract to allow, for instance, a keyboard
        to appear as a file.
        Unix-like kernels facilitate interaction with files via four essential
        system calls:
    </p>

    <ol>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/open.2.html">open(2)</a></code></li>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/close.2.html">close(2)</a></code></li>
        <li><code><a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></code></li>
        <li><code><a href="https://man7.org/linux/man-pages/man2/write.2.html">write(2)</a></code></li>
    </ol>

    <p>
        In particular, the <code>read</code> system call fills a given
        buffer with the contents of a file;
        order is preserved across sequential calls to <code>read</code>.
        When a program requests a read, the kernel suspends its execution 
        until data is available. 
        At the command-line, data from the keyboard is made available when
        the user presses <em>return.</em><sup><a href="https://blog.nelhage.com/2009/12/a-brief-introduction-to-termios/">[3]</a></sup>
    </p>

    <h3>File Attributes</h3>

    <p>
        UNIX-like operating systems characteristically store a substantial 
        amount of information about each file on the system.
        This information, known as 
        <em><a href="https://en.wikipedia.org/wiki/Metadata">metadata</a>,</em> 
        is stored alongside the file, typically on-disk.
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Oddly, it does not include the file's name, for in UNIX,
            a file may have many names.
            More on this below.
        </p>
    </div>

    <p>
        File metadata consists of:
    </p>


    <ul>
        <li>File Type</li>
        <li>Read/Write/Execute Permissions</li>
        <li>Owner</li>
        <li>Group</li>
        <li>Size</li>
        <li>Timestamps</li>
    </ul>

    <p>
        This information is kept for every file on the machine,
        and can be explained in part by the operating system's time-sharing heritage.
        It is used today in single-user desktops to compartmentalize the machine.
    </p>

   
    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.linfo.org/unix_philosophy.html">Unix Philosophy Description</a> by The Linux Information Project (LINFO)</li>
    </ul>
</div>

<div class="content" id="regular-files">
    <h2>Regular Files</h2>

    <p>
        A regular file contains data which is stored on disk.
        Most files are regular files. 
    </p>

    <p>
        Here we have a typical <code>ls(1)</code> listing:
    </p>

    <!--
        To do:
        - Change "wholename" to "name" (its being a wholename is coincidental to ls's
        invocation here)
        - Change character special and block special to device: special
    -->

    <a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for PDF" ></a>
    <center style="font-size:12pt;">Click for PDF</center>

    <p>
        The first character, a hyphen (<code>-</code>), tells us that 
        <code>/bin/bash</code> refers to a regular file. 
        The next nine characters are the file's 
        <a href="http://linfo.org/permissions.html">permission bits</a>;
        the <code>r</code> and <code>x</code> present in each set indicates 
        that this file is readable and executable (respectively) by any user on 
        the system.
        The <code>w</code> present only in the owner set indicates that the
        file may only be written to by its owner, who in this case 
        is <code>root</code>.
    </p>

    <p>
        Two other tools useful for peeking
        into a file are <code><a href="https://www.man7.org/linux/man-pages/man1/file.1.html">file(1)</a></code>, which prints a summary of the file, and  
        <code><a href="https://man7.org/linux/man-pages/man1/stat.1.html">stat(1)</a></code>, which prints the file's complete metadata:
    </p>

    <div class="code">
        $ file /bin/bash<br>
        /bin/bash: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br>
        dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <br>
        BuildID[sha1]=a43fec47192ff49c2d3fed671f2be8df7e83784a, for <br>
        GNU/Linux 3.2.0, stripped<br><br>
        $ stat /bin/bash<br>
        File: /bin/bash<br>
        Size: 1183448   	Blocks: 2312       IO Block: 4096   regular file<br>
        Device: 802h/2050d	Inode: 1835042     Links: 1<br>
        Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)<br>
        Access: 2020-07-14 13:33:43.628528710 -0500<br>
        Modify: 2020-02-25 06:03:22.000000000 -0600<br>
        Change: 2020-07-09 11:20:12.676956656 -0500<br>
        Birth: -<br>
    </div>

    <p>
        To simply view the contents of a file, we can use the <code>less(1)</code>
        utility, which displays one screenful of the file at a time:
    </p>

    <div class="code">
        $ less hello.c
    </div>

    (Press <code>q</code> to quit).

</div>

<div id="device-files" class="content">
    <h2>Device Files</h2>

    <p>
        The GNU/Linux directory tree is used as a general-purpose meeting place.
        In addition to regular files, it also contains
        information about running processes, information about the running kernel,
        and references to hardware&mdash; each in the form of files.
        This mechanism is general, extensible, and allows both users and programmers
        access to the running machine.
    </p>

    <div class="aside-right">
        <h4>Aside</h4>
        <p>
            It is interesting to note that the essential capabilities of these device 
            coincide with those of a file.
        </p>
    </div>

    <p>
        A <em>device file</em> represents a device connected to the system. 
        Device files reside in the <code>/dev</code> directory.<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">[4]</a></sup>
        Each of these files serves as the principle reference to its
        respective device.
        For instance, when a USB-stick is inserted into the machine,
        a new file appears in <code>/dev</code>.
    </p>

    <p>
        Let's consider the task of creating a boot media 
        by writing to a device file directly.
    </p>

    <p>
        I would like to install Arch Linux onto my PineBook Pro.
        I download a new installation image, and compare the resulting file
        against the original by comparing its official checksum value against
        the results of <code>sha256sum(1)</code>.
        They are identical; this means that the <a href="cacr.uwaterloo.ca/hac/about/chap1.pdf">integrity</a> of the file has been preserved through the operation of
        copying.
    </p>

    <p>
        Next, I insert a micro-SD card and locate it with <code>lsblk</code>.
        It has appeared as <code>/dev/mmcblk1</code>, and its partitions
        have not been mounted, so we are ready to write the file:
    </p>

    <div class="code">
        $ sudo dd if='archlinux-2020.07.02-pbp.img' of='/dev/mmcblk1' bs=4K
    </div>

    <p>
        After this command has completed, 
        the file <code>archlinux-2020.07.02-pbp.img</code> has been 
        copied (byte-wise perfectly) onto the first <em>n</em> bytes of the 
        card, where <em>n</em> is the length of said file.
        That file, a disk image, includes a few filesystems, a kernel,
        and is bootable.
    </p>

    <h3> Block vs. Character </h3>

    <p>
        Within <code>/dev</code>, there are two kinds of device files: 
        Block device files, which read and write in arbitrarily-sized blocks of bytes;
        and, Character device files, which are capable of reading and
        writing single bytes.
        A storage medium will present as a block device (owing to the underlying
        semantics of reading and writing to them);
        terminals present as character device files.
        For most purposes, the difference isn't meaningful.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.archlinux.org/index.php/Device_file">Device File - ArchWiki</a></li>
    </ul>
</div>

<div class="content" id="pseudo-files">
    <h2>Pseudo Files</h2>

    <p>
        The <code>/proc</code> directory offers file-level access to underlying
        kernel 
        structures.<sup><a href="https://man7.org/tlpi/" title="Kerrisk, p.42">[5]</a></sup>
        For example, reading and printing <code>/proc/meminfo</code> effectively 
        reports the system's current memory usage:
    </p>

    <div class="code">
        $ head /proc/meminfo<br>
        MemTotal:        3887988 kB<br>
        MemFree:         1619568 kB<br>
        MemAvailable:    2450268 kB<br>
        Buffers:          120152 kB<br>
        Cached:           984208 kB<br>
        SwapCached:            0 kB<br>
        Active:           324532 kB<br>
        Inactive:        1528196 kB<br>
        Active(anon):       9476 kB<br>
        Inactive(anon):  1061224 kB
    </div>

    <p>
        This is an example of a <em>synthetic</em> or <em>psuedo</em> file.
        These files do not exist on disk, but are instead synthesized by
        the kernel as processes read them (and the directories they
        are in).
        That is, the output printed above was the kernel's response to the
        <code>read(2)</code> system call, and nothing more.
    </p>

    <p>
        The <code>/proc</code> and <code>/sys</code> directories are
        reserved for pseudo files.
        Of these, we will discuss only <code><a href="https://man7.org/linux/man-pages/man5/proc.5.html">/proc</a></code> in any detail.
        It contains one directory for each running program on the system,
        and each directory contains substantial information about its
        respective process.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li> <a href="https://www.kernel.org/doc/html/latest/filesystems/proc.html">The /proc Filesystem &ndash; The Linux Kernel documentation </a></li>
    </ul>
</div>

<div id="fs-heir" class="content">
    <h2>Filesystem Heirarchy</h2>

    <div class="aside-left">
        <h4>Aside:</h4>
        <p>
            The <code>which</code> utility reports the location of executable files:<br>
            <div class="code">
                $ which ls<br>
                /bin/ls
            </div>
        </p>
    </div>

    <p>
        Within any GNU/Linux distribution, some common themes will be found.
        For instance, <code>bin</code> directories are found in several places, such as
        <code>/bin</code>, <code>/sbin</code>, along with <code>/usr/bin</code>
        and often <code>/home/[user]/bin</code> as well.
        These contain binary executable files&ndash; programs&ndash; such as 
        <code>bash</code> and <code>ls</code>. 
        Other standard directories include <code>/root</code>, the root user's home
        directory, and <code>/proc</code>, and <code>/dev</code> as
        mentioned above.
        Some of these have been standard since Unix's inception,
        while others have become standard in more recent decades.
    </p>

    <div class="aside-right" style="font-size: 15px;">
        <h4>Aside:</h4>
        <p>
            The <a href="https://refspecs.linuxfoundation.org/fhs.shtml">Filesystem Heirarchy Standard</a>
            describes the GNU/Linux directory structure, and is maintained
            by the Linux Foundation.
            It is intended to promote inter- operability 
            among UNIX-like operating systems,<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html">[6]</a></sup>
            and was developed with help from the BSD development community.<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch07s02.html">[7]</a></sup>
        </p>
    </div>

    <p>
        Let's begin at the top.
        Each Unix-like operating system has a single directory, <code>/</code>,
        which is the root of the system's directory tree.
        This is referred to as the <em>root directory</em> (not to be 
        confused with <em>root user's home directory</em>). 
        Every file in a Unix-like operating system may be addressed in absolute
        terms by giving its location relative to the root directory.
    </p>

    <p>
        <code>/home</code> contains users' home directories. 
        As user <em>josh</em>, my home directory is <code>/home/josh</code>.
        This path is commonly abbreviated to <code>~</code>.
        By default, it contains the usual "Music", "Movies", "Pictures" and 
        "Downloads", but of course you are the owner.  
        Per-user configuration files are also stored here, either as
        hidden files or in the directory <code>~/.config</code>.
    </p>

    <p>
        The directory <code>/etc</code> contains
        system-specific configuration files. 
        You can expect to fiddle with the contents of this directory when 
        manually configuring the system.
        It contains, for instance, files describing the configuration of 
        the system's package manager, X11 window system configuration, 
        and, well, etcetera.
    </p>

    <p>
        <code>/tmp</code>, <code>/run</code>,  and <code>/var</code> each hold
        transient files of running programs.  
        <code>/tmp</code> is 
        <code>/boot</code> holds everything required for the boot sequence,
        including my very own Linux kernel:
    </p>

    <div class="code">
        $ file /boot/Image<br>
        Image:&emsp;&emsp; Linux kernel ARM64 boot executable Image, little-endian, 4k pages
    </div>

    <p>
        Software libraries are kind of boring, but essential to modern systems.
        The basic idea is to factor out repeated code (for instance, 
        C's <code>printf</code> function) not just from the source code, but
        from <em>executable</em> files as well.  
        This means that, when a bug or security vulnerability is found in 
        <code>printf</code>, any program that uses the function will not
        have to be recompiled; rather, the appropriate library can be adjusted,
        and all dependant programs can continue operation in blissful ignorance
        of the change. 
        Such executable files are said to be <em>dynamically linked,</em> 
        and cannot be expected to run properly without their dependencies.
        <code>/lib</code> holds libraries. 
    </p>

    <p>
        The last directory we will look at is <code>/usr</code>, which 
        is more interesting. It contains user-shared files, such as 
        man pages (in <code>/usr/share/man</code>) and most of the system's
        programs (in <code>/usr/bin</code>).
        These files are used by all system users, and the 
        Linux Filesystem Heirarchy Standard mentioned
        above intends to guarantee that this  
        directory can shared across systems via network, by making its contents
        read-only.
    </p>

  
    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.archlinux.org/index.php/XDG_Base_Directory">XDG Base Directory</a> - Arch Linux (A newer, super-specification)</li>
        <li><a href="http://linfo.org/root.html">What is root?</a> -- definition by the Linux Information Project (LINFO)</li>
    </ul>
</div>

<div class="content" id="mounting-unmounting">
    <h2>Mounting and Unmounting</h2>

    
    <p>
        Unlike Windows systems, which create a new, distinct directory tree
        for each storage device on the system (e.g., <code>C:\, D:\</code>, etc.),
        UNIX-like operating systems 
        maintain a single, unique directory tree for the entire system.
        When a new device is introduced to the machine, its files are made 
        available by placing the new filesystem's root directory 
        in the existing directory tree,
        in an operation is called <a href="https://unix.stackexchange.com/questions/3192/what-is-meant-by-mounting-a-device-in-linux"><em>mounting</em></a>.
    </p>

    <p>
        Let's take a look at this, for it is new.
    </p>

    <p>
        Suppose we have a usb stick with some music on it, and we'd
        like to access its contents.
        When we plug it in, the hardware, then the kernel,
        recognize it, but it may not be accessible:
    </p>

    <img style="width:80%" src="assets/img/mounting.png">

    <p>
        The Linux Filesystem Heirarchy Standard provides two places to mount 
        temporary filesystems: <code>/mnt</code> and <code>/media/[user]</code>.
        When mounting new devices manually, the usual method is to identify the 
        device to be mounted with 
        <a href="https://man7.org/linux/man-pages/man8/lsblk.8.html"><code>lsblk(8)</code></a>, 
        then mount it with
    </p>

    <div class="code">
        $ sudo mount [DEVICE] [MOUNTPOINT]
    </div>

    <p>
        Superuser priveledges allow us to mount a filesystem anywhere.  
        When a filesystem's is mounted to a directory that is not empty,
        those directory's contents become "hidden" by those of the new filesystem, 
        and are inaccessible while the filesystem is mounted.  
        Therefore, we typically locate an empty directory in the existing
        directory tree, to serve as the to-be-mounted filesystem's root
        directory.
    </p>
            
    <h3> Unmounting </h3>

    <p>
        Devices should be unmounted before being removed; this operation is
        encapsulated in "eject." 
        To unmount a device manually, we again assert the correct device 
        with <code>lsblk</code>, then unmount it with,
    <p>

    <div class="code">
        $ sudo umount &lt;PATH&gt;
    </div>

    <p>
        where <code>PATH</code> is the location of the mounted filesystem's
        root directory.
    </p>
</div>

<div id="filesystems" class="content">
    <h2> Filesystems </h2>

    <p>
        A <em><a href="https://wiki.osdev.org/File_Systems#File_System_Theory">filesystem</a></em> 
        is a systematic method of storing and retrieving data on
        disk.<sup><a href="https://wiki.osdev.org/Filesystem">[8]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[9]</a></sup>
        The first versions of UNIX referred to its own filesystem as, simply,
        <code>fs</code>.  
        It was well-documented (by, for instance, Maurice J. Bach in 
        <a href="https://archive.org/details/DesignUNIXOperatingSystem/mode/2up"><em>The Design of the Unix Operating System</em></a>), and became the basis of
        a sequence of filesystems, including Linux's <code>ext</code> 
        and <code>ext2</code>.
    </p>

    <p>
        These filesystems were relatively simple and naive:
        They expected that machines would always shutdown cleanly, and
        that hard-drives worked flawlessly.
        In particular, a system crash mid-write could leave the filesystem in 
        an inconsistent state.<sup><a href="https://en.wikipedia.org/wiki/Journaling_file_system">[10]</a></sup> 
        Such a shutdown required a check of the entire structure.<sup><a href="https://en.wikipedia.org/wiki/Journaling_file_system">[10]</a></sup>
        Filesystems like these 
        are today used to hold the bootloader, since they are widely supported and
        their contents are not expected to change often.
    </p>
    
    <p>
        The issue of non-clean shutdowns was solved with the introduction of 
        <em><a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling</a>:</em>
        Before a change is made to the filesystem's contents, it is first written
        to an on-disk journal.  
        Should the system crash after the journal has been updated, the write
        can simply be resumed; should the system crash before the journal entry has been
        completed, the write is discarded.
        In either case, the consistency of the filesystem is preserved.
        Journaling filesystems are in wide use, and include Linux's excellent 
        <a href="https://ext4.wiki.kernel.org/index.php/Main_Page"><code>ext4</code></a>
        and Microsoft's <code>NTFS</code>.
    </p>

    <p>
        Next-generation filesystems are introducing a myriad of features to
        cope with hard-drive failures, especially, in enterprise settings.  
        The most fundamental change is <em>copy on write,</em>
        a minor change in semantics which allows filesystem-wide snapshots to be 
        created very efficiently, while reducing the need for journaling.
        Other features include native logical volume management/RAID support and 
        internal checksumming.
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            <code>ZFS</code> has been described by Linus Torvalds as a "non-starter,"
            principally over licensing issues.<sup><a href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189841">[15]</a></sup>
        </p>
    </div>

    <p>
        Both <code><a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">btrfs</a></code> 
        and <code><a href="https://en.wikipedia.org/wiki/ZFS">ZFS</a></code> 
        are such next-generation, copy-on-write filesystems.<sup><a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">[11]</a><a href="https://wiki.archlinux.org/index.php/ZFS">[12]</a></sup>
        Of the two, <code>btrfs</code> has made inroads to becoming Linux's next 
        major filesystem:
        It is in wide use by Facebook,<sup><a href="https://lwn.net/Articles/824855/">[13]</a></sup> and has recently become  
        the default filesystem of Fedora's <em>Workstation</em> 
        distribution.<sup><a href="https://fedoramagazine.org/announcing-fedora-33/">[14]</a></sup>
        They are among the first to adopt it.
    </p>

    <p>
        Owing in part to a vast collection of open-source drivers, 
        Linux can make use of many filesystems.
        The filesystems that the (running) kernel supports are listed at 
        <code>/proc/filesystems</code>;
        formatting tools are generally of the form <code>mkfs.&lt;filesystem&gt;</code>;
        finally, <code>man</code> pages contain most relevant information.
    </p>
   
    <h3> See Also: </h3>
    <ul>
        <li><a href="https://man7.org/linux/man-pages/man5/filesystems.5.html"><code>filesystems(5)</code></a></li>
        <li><a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">An Introduction to Disk Partitions :: Fedora Docs</a></li>
    </ul>
</div>


<div id="directories" class="content">
    <h2>Directories</h2>

    <p>
        A directory is, of course, just a particular kind of file.
        In order to explain them well, however, we must briefly digress to
        Linux's internal representation of files.
    </p>

    <h3> inodes </h3>

    <p>
        An inode object represents an object within the 
        filesystem.<sup><a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html#id1">[16]</a></sup>
        Every path on the directory tree refers to an inode, and
        every file has a unique inode.
    </p>

    <p>
        Inodes are the responsibility of their respective filesystem, 
        and, in keeping with traditional UNIX filesystems, 
        each is given a number, referred to as an <em>inode number.</em>
        Within a given filesystem, an inode number uniquely identifies an
        inode, and thereby uniquely identifies a file.
    </p>

    <h3>Directories</h3>

    <p>
        A directory is a file containing a table with two columns: 
        File name and Inode number:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            By convention alone, filenames which begin with a 
            period <code>.</code> are considered hidden, 
            including <code>.</code> and <code>..</code>.
            We list them here with the <code>--all</code> option.
        </p>
    </div>

    <div class="code">
        $ ls -ia ~/Public/Learning-Linux <br>
        645278 ./<br>
        384844 ../<br>
        775487 assets/<br>
        641473 command-line-1-tutorial-introduction.html<br>
        645403 _config.yml<br>
        775449 _data/<br>
        642188 documentation.html<br>
        642185 files-and-filesystems.html<br>
        641460 finding-files.html<br>
        775463 _future/<br>
        645377 .git/<br>
        645401 .gitignore<br>
        775479 _includes/<br>
        641295 index.html<br>
        642186 intro-to-gnu-linux.html<br>
        777671 .jekyll-cache/<br>
        775483 _layouts/<br>
        641300 package-management.html<br>
        641293 processes.html<br>
        642193 programming-in-nix.html<br>
        641472 README.md<br>
        775485 _sass/<br>
        898840 _site/<br>
        642693 systemd.html<br>
        641291 terminals-and-shells.html<br>
    </div>

    <p>
        Each entry in a directory is called a <em>hard link.</em>
        A file may have more than one hard link, but when it has zero,
        it is no longer accessible through the directory tree, and
        the kernel prepares to delete it.<sup><a href="#references">[17]</a></sup>
    </p>
   
    <p>
        A hard link is created upon file creation;
        we can also create new hard links with the <code>ln</code> "link" command,
        as the following sequence demonstrates:
    </p>

    <div class="code">
        $ echo "hello world" &gt; newfile <br>
        $ ls -i newfile <br>
        2112949 newfile <br>
        $ ln newfile 2file <br>
        $ ls -i newfile 2file <br>
        2112949 newfile <br>
        2112949 2file <br>
    </div>

    <p>
        The name "2file" is equivalent to the name
        "newfile".
        If we modify the file using one name,
        then we have modified the file referred to by the other:
    </p>

    <div class="code">
        $ echo "hello from 2file" &gt; 2file<br>
        $ cat newfile<br>
        hello from 2file
    </div>

    <p>
        Directories are somewhat special: They are managed by the kernel, 
        and are not directly readable nor writeable by 
        processes.<sup><a href="#references">[17]</a></sup>
    </p>

    <h3> See Also: </h3>
    <ul>
        <li> <code><a href="https://man7.org/linux/man-pages/man7/inode.7.html"> inode(7) </a></code></li>
        <li><a href="http://linfo.org/hard_link.html">What is a hard link?</a> -- definition by The Linux Information Project (LINFO)</li>
        <li><a href="https://en.wikipedia.org/wiki/Symbolic_link#Overview"> Symbolic Link (Overview) - Wikipedia </a> </li>
    </ul>
</div>

<div class="content" id="closing-remarks">
    <h2 style="margin-bottom: 0;">Closing Remarks</h2>
    <h4>Inode: A Historical Perspective</h4>

    <p>
        The inode was implemented literally in the Ancient UNIX filesystem,
        and formed the basis of its architecture:
    </p>

    <img src="">

    <p>
        In the design, data blocks are of fixed size, and either free or
        wholly consumed by a file.<sup><a href="#references">[18]</a></sup> 
        The filesystem's <em>index nodes</em> represent one file each,
        contain their file's metadata, and contain pointers to data blocks.<sup><a href="#references">[18]</a></sup> 
        These nodes are arranged in an array, and can be uniquely identified
        by an index into this array.
    </p>

    <p>
        This design allows a file to grow or shrink without rearranging
        other files.<sup><a href="#references">[18]</a></sup> 
        In addition, the inclusion of single-, double- and triple- 
        indirection blocks allow the inode to remain of fixed, 
        reasonable size, while supporting large 
        files.<sup><a href="#references">[18]</a></sup>
    </p>

    <p>
        It was the most advanced filesystem of its time, 
        and, as UNIX grew in popularity, was propogated and revised. 
        <em>Index node</em> became contracted to <em>inode</em>,
        and the semantics of file operations in UNIX-like operating systems 
        became dependant upon them.
    </p>

    <p>
        The design was demonstrated in the 
        <a href="https://en.wikipedia.org/wiki/Minix">MINIX</a> filesystem,
        which in turn served as Linux's pre-1.0 filesystem.
        The <em>extended</em> filesystem, <code>ext</code>, extended 
        those filesystem's capabilities.
        With <code>ext</code>'s inclusion in kernel 0.96c, Linux began to use
        its new <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">Virtual File System</a>, 
        a kernel subsystem that provides userspace with a 
        uniform filesystem interface.
    </p>

    <p>
        While each filesystem implements its own functionality,
        most functionality is common;
        the Virtual File System provides a uniform interface to user-space by
        mapping filesystem-related system calls to filesystem-driver functions.
        In addition, the VFS imposes inodes on filesystems that do not 
        natively employ them, 
        thereby preserving traditional UNIX file semantics across all
        supported filesystems.
    </p>
</div>

<div id="udacity" class="content">
    <!--
        To Do:
        <b>Exercises:</b>

        <ol>
        <li> Using <code>watch(1)</code>, fashion an ad-hoc terminal utility to
        <li> Create a boot media using <code>cat</code> and redirection.</li>
        monitor the system's memory</li>
        <li> An <code>iso</code> disk image contains partitions and filesystems.
        Mount one of them.</li>
        <li>
        http://cs.smith.edu/~nhowe/262/oldlabs/ext2.html#itable
        https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html
        </li>
        <li>
            What is <code>dirname</code> of <code>/</code>?
        </li>
        </ol>

        <h3>Further Reading:</h3>
        <ul>
            <li><a href="http://kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"><code>udev</code> - A Userspace Implementation of devfs</a> by Greg Kroah-Hartman</a></li>
        </ul>

    -->
    <h2 style="margin-bottom: 2pt;">Udacity:</h2>
    <h4 style="margin-bottom: 18pt;"> Inode Structure</h4>
    <iframe class="video" src="https://www.youtube.com/embed/tMVj22EWg6A" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    <p>
        Note: This video belongs to <em>Lesson 2: File Systems</em> of <a href="https://www.udacity.com/course/gt-refresher-advanced-os--ud098">Advanced OS Refresher</a> by Georgia Tech,
        which is quick and worthwhile.
        It is monetarily free, but you must make an account.
    </p>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>

        <li>Ritchie, D. M. (1984). The Evolution of the Unix Time-sharing System. <em>AT&amp;T Bell Laboratories Technical Journal,</em> 63(6), 2nd ser., 1577-1593.</li>

        <li>Elhage, N. (2009, December 22). A Brief Introduction to Termios. Retrieved March 07, 2021, from <a href="https://blog.nelhage.com/2009/12/a-brief-introduction-to-termios/">https://blog.nelhage.com/2009/12/a-brief-introduction-to-termios/</a></li>

        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). 3.6 /dev: Device Files. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html</a> </li>

		<li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>

        <li>Abstract.  Filesystem Hierarchy Standard. (2015, March 15). Retrieved March 18, 2021, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html</a></li>

        <li>7.2. Background of the FHS. (2015, March 15). Retrieved March 18, 2021, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch07s02.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch07s02.html</a></li>

        <li> File Systems. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.osdev.org/Filesystem">https://wiki.osdev.org/Filesystem</a> </li>

        <li> File systems - ArchWiki. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.archlinux.org/index.php/File_systems">https://wiki.archlinux.org/index.php/File_systems</a> </li>

        <li>Journaling file system - Wikipedia. (2021, January 06). Retrieved March 02, 2021, from <a href="https://en.wikipedia.org/wiki/Journaling_file_system">https://en.wikipedia.org/wiki/Journaling_file_system</a></li> 


        <li>btrfs Wiki (2021, February 24). Retrieved March 02, 2021, from <a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">https://btrfs.wiki.kernel.org/index.php/Main_Page</a></li>
        
        <li>ZFS - ArchWiki. (2021, February 22). Retrieved March 02, 2021, from <a href="https://wiki.archlinux.org/index.php/ZFS">https://wiki.archlinux.org/index.php/ZFS</a></li>

        <li>Btrfs at Facebook [LWN.net]. (2020, July 2). Retrieved March 02, 2021, from <a href="https://lwn.net/Articles/824855/">https://lwn.net/Articles/824855/</a></li>
        
        <li>Fedora 33 is officially here! - Fedora Magazine. (2020, October 27). Retrieved March 2, 2021, from <a href="https://fedoramagazine.org/announcing-fedora-33/">https://fedoramagazine.org/announcing-fedora-33/</a></li>

        <li>Torvalds, L. (2020, January 06). Nuances related to Spinlock implementation and the Linux Scheduler. Retrieved March 02, 2021, from <a href="https://www.realworldtech.com/forum/?threadid=189711&amp;curpostid=189841">https://www.realworldtech.com/forum/?threadid=189711&amp;curpostid=189841</a></li>


        <li> Overview of the Linux Virtual File System - The Linux Kernel Documentation. (n.d.). Retrieved July 17, 2020, from <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">https://www.kernel.org/doc/html/latest/filesystems/vfs.html</a> </li>

        <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>

        <li>Bach, M. J. (1986). Chapter 4: Internal Representation of Files. In <em>The Design of the UNIX Operating System</em> (pp. 60-90). Englewood Cliffs, NG: Prentice-Hall. </li>

    </ol>

</div>

