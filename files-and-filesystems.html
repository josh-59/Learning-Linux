---
layout: default
title: Files and Filesystems
last-updated: July, 2020
---

<!-- To Do:
    Citation needed in "regular files" -> heirarchical filestructure taken from Multics

    XDG Directory Specification
    ~/.config is defined as part of the XDG specification


    https://wiki.ubuntu.com/Lvm

-->
<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#filesystems"> Filesystems </a></li>
    <li><a href="#directories"> Directories </a></li>
    <li><a href="#mounting-unmounting"> Mounting and Unmounting</a></li>
    <li><a href="#fs-heir"> Filesystem Heirarchy </a></li>
    <li><a href="#regular-files"> Regular Files </a></li>
    <li><a href="#pseudo"> Pseudo Files </a></li>
    <li><a href="#device-files"> Device Special Files </a></li>
    <li><a href="#closing-remarks"> Closing Remarks </a></li>
    <li><a href="#lvl1"> Level 1 Linux </a></li>
    <li><a href="#references"> References </a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>Files and Filesystems</h1>
  <h4 style="font-size: 15pt;">"In the beginning, the file was without form, and void;<br>
  and emptiness was upon the face of the bits.<br>
  And the Fingers of the Author moved upon the face of the keyboard.<br>
  And the Author said, Let there be words, and there were words."</h4>
  <div class="quote-ref" style="margin-left: 50%;">
    &mdash;<a href="https://www.tldp.org/LDP/sag/html/intro.html">The Linux System Administrator's Guide</a>
  </div>


  <p>
    Unix began life as a filesystem.<sup><a href=#references>[1]</a></sup>
    Shortly thereafter, a means
    of interacting with it was created&mdash; initially,
    this consisted of the <em>exec</em>
    system call, a shell, a text editor and an assembler.
    Written entirely by Ken Thompson, these key components formed the nexus of
    the time-sharing operating system that would eventually be called
    <em>Unix</em>.
  </p>

  <p>
    This file-first approach to operating system design is found in
    the implementation as well as the history of Unix:
    Unix and its derivatives use files for many things.
    As such, there is a lot to be said about files.
    This paper introduces the <em>filesystem</em>,
    discusses the directory structure implemented on top of it,
    and gives a practical overview of the contents of them.
  </p>
</div>

<div id="filesystems" class="content">
  <h2> Filesystems </h2>
  <p>
    A filesystem is a systematic method of organizing data on
    disk.<sup><a href="https://wiki.osdev.org/Filesystem">[2]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[3]</a></sup>
    Conceptually, it is similar to a data structure, in that it defines a convention
    to be followed in the storage and retrieval of data.
    A given disk is usually <em>partitioned</em> into several logically-distinct components.
    All partitions are contiguous with respect to the disk's address space, and
    each entertains its own distinct filesystem, if any.
    Preparing a partition for use by a particular filesystem
    <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">is known as formatting.</a>
  </p>

  <ul>
    <h3>Some Common Filesystems:</h3>
    <li>
      <p>
        <strong>EXT4</strong>:
        Introduced in 2008,<sup><a href="https://en.wikipedia.org/wiki/Ext4">[4]</a></sup> EXT4 is
        the current standard Linux filesystem.
        It is an evolutionary enhancement on EXT3,
        supporting larger filesizes, deeper subdirectory support,
        faster handling of large files, along with many other improvements.<sup><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">[5]</a></sup>
        It is mature, fast, and stable.
      </p>
    </li>

    <div class="aside-right">
      <h4>Aside</h4>
      <p>
        A filesystem describes how files are stored, but it is the kernel's responsibility to abide by this specification.
        Thus, the details of creating, reading and writing files are left to the kernel.
      </p>
    </div>

    <li>
      <p>
        <strong>ZFS</strong>:
        "Don't use ZFS.  It's that simple." &mdash;<a href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189841">Linus Torvalds</a>.
      </p>

      <p>
        Introduced in 2005,<sup><a href="https://en.wikipedia.org/wiki/ZFS">[6]</a></sup> ZFS incorporates fancier features that are generally
        out of place on a Linux desktop.
        It was developed by Sun Microsystems, and became closed-source with Sun's acquisition by
        Oracle.<sup><a href="https://en.wikipedia.org/wiki/ZFS">[6]</a></sup>
        It was intended for enterprise use, and is
        <a href="https://en.wikipedia.org/wiki/ZFS#Inappropriately_specified_systems">relatively easy to configure improperly.</a>
      </p>
    </li>

    <li>
      <p>
        <strong>FAT32</strong>: The "File Allcoation Table 32-bit" is a DOS-era filesystem,<sup><a href="https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32">[7]</a></sup>
        and is widely supported, though antiquated.
        In particular, it is not a <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling filesystem</a>,
        so that changes to data are not recorded before being carried out (increasing the likelihood of
        corruption in the event of, say, power outage).
        This filesystem is often used to hold the bootloader, since it is virtually guaranteed to be supported by firmware,
        and it will not be changed very often.
      </p>
    </li>
  </ul>

  <p>
    System V Unix implemented its own filesystem as an integral part of the operating system;
    it was unnamed, though well-documented (by, for instance, Maurice J. Bach in <em>The Design of the Unix Operating System</em>).
    The Extended Filesystem (EXT) was an open-source derivative, and retained many distinctive features of the original;
    since then, EXT2, EXT3, and EXT4 have continued to improve upon the design.
  </p>

  <h3> inodes </h3>

  <p>
    A key feature of the architecture of the System V filesystem
    was the <em>inode.</em>
    This feature has been retained throughout the Extended Filesystem series,
    and is a key to understanding files in GNU/Linux.
    The inode of a file serves as the filesystem's unique reference to the file.
    It contains information describing where the data of the file is,
    in addition to metadata about the file, such as its size, access permissions
    and timestamps.
  </p>

  <div class="aside-left">
    <h4>Aside:</h4>
    <p>
      <em>Filesystem</em> is often abbreviated <em>fs.</em>
    </p>
  </div>

  <p>
    The set of all inodes in a filesystem is organized in an array;
    in most filesystems, this array is located near the beginning of the partition.
    An inode number is an index into this array, and therefore serves as a
    reference to a unique inode.
    Each inode&mdash; and therefore each file&mdash; has a unique inode number within its
    filesystem.
  </p>

  <p>
    Intuitively, a file's inode number serves as the "hardware name" of a file,
    since it uniquely identifies a file within a filesystem.
    For the kernel, which often manages more than one filesystem at a time,
    the information required to identify a file
    is its inode number and the filesystem it belongs to.
  </p>

  <h3> See Also: </h3>
  <ul>
    <li> <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">An Introduction to Disk Partitions - Fedora Docs Site</a></li>
    <li> <a href="https://man7.org/linux/man-pages/man5/filesystems.5.html"> filesystems(5)</a></li>
    <li> <a href="https://man7.org/linux/man-pages/man7/inode.7.html"> inode(7) </a></li>
    <li> <a href="https://ext4.wiki.kernel.org/index.php/Main_Page">Ext4 (and Ext2/Ext3) Wiki </a></li>
    <li> <a href="http://web.mit.edu/tytso/www/linux/ext2intro.html"> Design and Implementation of the Second Extended Filesystem</a> (Discusses inodes)</li>
    <li> <a href="https://www.man7.org/tlpi/">The Linux Programming Interface</a>, Chapter 14: Filesystems </li>
  </ul>
</div>

<div id="directories" class="content">
  <h2>Directories</h2>

  <p>
    A directory is a file containing a table with two columns:
    <a href="finding-files.html#basename">basename</a> and inode number.
    Each entry in a directory's table is called a <em>hard link.</em>
  </p>

  <p>
    An inode number is sufficient to uniquely identify a file only within
    the filesystem the directory belongs to.
    Consequently, <em>hard links may not cross filesystem boundaries.</em>
    Another way of saying this is, "Every file belongs to the same filesystem
    as the directories which hard-link it."
  </p>

  <p>
    Every file on the system has an inode number.
    We list the contents of a directory with the usual <code>ls</code> command,
    and can list inode numbers using the <code>-i</code> switch:
  </p>

  <div class="aside-right">
      <h4>Aside:</h4>
      <p>
        The idea of using numerical values as names (i.e., unique identifiers)
        is common throughout computing.
        As we'll see later, each process has a
        unique numerical identifier, called its PID,
        which is used as the system's "handle" to the process.
        Other examples include user id's and memory addresses.
      </p>
  </div>

    <div class="code">
      $ echo "hello world" > newfile <br>
      $ ls -i newfile <br>
      2112949 newfile
    </div>

    <p>
        Files may be hard-linked more than once.
        This allows a file to appear in more than one directory, and/or more than once
        in a single directory.
        We can create new hard links with the <code>ln</code> command:
    </p>

    <div class="code">
        $ ln newfile 2newfile <br>
        $ ls -i newfile 2newfile <br>
        2112949 newfile <br>
        2112949 2newfile <br>
    </div>

    <p>
      The name "2newfile" is equivalent to the name
      "newfile", since they link to the same inode number.
      If we modify the file using one name,
      then we have modified the file referred to by the other:
    </p>

    <div class="code">
      $ cat 2newfile <br>
      hello world<br>
      $ echo "hello from 2newfile" > 2newfile<br>
      $ cat newfile<br>
      hello from 2newfile
    </div>

    <p>
      A question arises: <em>"What if we delete newfile?"</em>
      With the above implementation in mind, there are two distinct operations
      that must take place to delete a file: First, remove all hardlinks to the file
      (that is, delete all directory entries linking it).
      Second, free the file (i.e., allow its inodes and data blocks to be reused).
      Deleting hardlinks is precisely what the <code>rm</code> command does.
      Freeing the file from the filesystem is left to the kernel, and
      takes place only after there are zero hard links to it.
    </p>

    <h3>Structure</h3>

    <p>
      While each file on the system, including directories, is owned by a user,
      the contents of directories are, effectively, owned by the kernel.
      User-space processes are not permitted to read or write
      directly to directories.
      System calls exist to:
    </p>

    <ul style="columns: 2; width: 80%; margin-left: 10%; margin-bottom: 20px;">
      <li><a href="https://www.man7.org/linux/man-pages/man2/open.2.html">Create a new file</a></li>
      <li><a href="https://man7.org/linux/man-pages/man2/link.2.html">Create a new hardlink</a></li>
      <li><a href="https://man7.org/linux/man-pages/man2/unlink.2.html">Delete a hardlink</a></li>
      <li><a href="https://www.man7.org/linux/man-pages/man2/mkdir.2.html">Create a directory</a></li>
      <li><a href="https://www.man7.org/linux/man-pages/man2/rmdir.2.html">Remove a directory</a></li>
      <li><a href="https://www.man7.org/linux/man-pages/man2/getdents.2.html">Get directory entries</a></li>
    </ul>


    <p>
      The layer of indirection offered by these interfaces affords the kernel
      the opportunity to restrict the manipulation of directories, and therefore,
      to impose structure upon the directories within a filesystem.
      In particular, directories are not allowed to be arbitrarily hard-linked
      (i.e., you cannot create new hardlinks to existing directories).
    </p>

    <p>
      Each directory contains at least two hard links, which cannot be changed, and
      which help define the filesystem's directory structure.  They are,
      <code>.</code> ("dot"), which refers to the containing directory itself,
      and <code>..</code> ("dot dot"), which refers to its parent directory.
      The root directory's parent directory is the root directory itself.
      Finally, each filesystem has a single root directory.
    </p>

    <p>
      These restrictions guarantee that the directory structure forms a tree.
    </p>

    <h3> See Also: </h3>
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Symbolic_link#Overview"> Symbolic Link (Overview) - Wikipedia </a> </li>
    </ul>
</div>

<div class="content" id="mounting-unmounting">

  <h2>Mounting and Unmounting</h2>

  <p>
    Unlike Windows systems, which create a new, distinct directory tree
    for each storage device on the system (<code>C:\, D:\</code>, etc.),
    *nix systems place a new filesystem's directory tree within the existing
    directory tree by placing the new root directory in the existing directory
    tree.
    This operation is called
    <a href="https://unix.stackexchange.com/questions/3192/what-is-meant-by-mounting-a-device-in-linux"><em>mounting</em></a>.
  </p>

  <p>
    Let's take a look at this operation, for this is new.
    Suppose you have a usb stick with some music on it, and you'd
    like to access its contents.
    After it's plugged in, the hardware, then the kernel,
    recognize it, but it may not be accessible:
  </p>

  <img style="width:80%" src="assets/img/mounting.png">

  <p>
    When mounting new devices manually, the usual method is to identify the device
    to be mounted with <a href="https://man7.org/linux/man-pages/man8/lsblk.8.html"><code>lsblk(8)</code></a>, then mount it with
    <a href="https://www.man7.org/linux/man-pages/man8/mount.8.html"><code>sudo mount DEVICE MOUNTPOINT</code></a>.
    The device to be mounted should be a partition, and can usually be determined by its size and
    its mountpoint (which should be none).
    Most GNU/Linux distributions provide two places to mount temporary
    filesystems: <code>/mnt</code> and <code>/media/[user]</code>.
  </p>

  <p>
    Similarly, to unmount a filesystem, we first identify the correct
    partition with <code>lsblk</code>,
    then unmount it with <a href="https://www.man7.org/linux/man-pages/man8/umount.8.html"><code>sudo umount PATH</code></a>,
    where <code>PATH</code> is the location of the mounted filesystem.
  </p>

  <p>
    A few details:
    First, device names that appear in <code>/dev</code> or <code>lsblk</code>
    <em>are not</em> guaranteed to be stable across reboots&mdash; The devices are named in the
    order that they are found.
    Second, when mounting a new filesystem, if any files exist at the
    mount point, they will be "hidden" by the files of the new filesystem
    (they become inaccessible).
    They are not deleted, and unmounting the new filesystem will "reveal" them again.
    To avoid this, create a new directory and mount there.
    Third, a filesystem cannot be in use while unmounting; in particular,
    you must <code>cd</code> out of the device before calling <code>umount</code>.
    Finally, unmount (eject) before unplugging!
  </p>
</div>

<div id="fs-heir" class="content">
  <h2>Filesystem Heirarchy</h2>

  <p>
    Now, we turn to more pragmatic matters.
    Within any GNU/Linux distribution, some common themes will be found.
    For instance, <code>bin</code> directories are found in several places, such as
    <code>/bin</code> and <code>/sbin</code>, along with <code>/usr/bin</code>.
    These contain binary executable files (programs), such as <code>ls</code>, which
    can be ran as commands from the shell.
  </p>

  <div class="aside-right" style="font-size: 15px;">
    <h4>Aside:</h4>
      <p>
        The <a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux Filesystem Heirarchy Standard</a>
        describes the working GNU/Linux directory structure.  It is a "follow along" standard:
        It codifies the Linux filesystem as it commonly appears at the time of its publication,
        and does not arbitrarily impose a standard prior to implementation.
      </p>
  </div>

  <p>
    The directory <code>/etc</code> (usually read "<em>et</em>-see") contains
    system-specific configuration files; as a consequence, you can expect to fiddle
    with the contents of this directory when configuring the system for the first time
    (or otherwise).
    It contains, for instance, files describing the configuration of the system's package
    manager, printers, and, well, etcetera.
  </p>

  <p>
    <code>/home</code> contains user's home directories.
    Per-user configuration files are contained here either as
    hidden files, or in the directory <code>~/.config</code>.
    Unix-like systems are often constructed such that the home directory is
    mounted as a separate filesystem.
    One reason to do this is that it helps prevent
    users from threatening the system by consuming all its
    storage space.
  </p>

  <p>
    According the the standard, the system's root directory, <code>/</code>, should belong
    to a minimal filesystem that is "adequate to boot, restore recover and/or repair the system."<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html">[8]</a></sup>
    As such, <code>/bin</code>, <code>/sbin</code>, <code>/etc</code>, <code>/media</code>,
    and <code>/mnt</code> should each belong to the root filesystem.
    Moreover, critical user programs, such as <code>ls</code> and <code>bash</code>,
    are kept here, as well.
  </p>

  <p>
    The last directory we will cover is <code>/usr</code>, which contains
    files which are shareable across systems&mdash; they do not change in normal
    operation, and are not machine-specific.
    This stipulation allows multiple machines to share a single <code>/usr</code>
    directory by locating it on a network,
    potentially saving large amounts of storage.<sup><a href="https://www.tldp.org/LDP/sag/html/fs-background.html">[9]</a></sup>
    For instance, man-pages are found in <code>/usr</code>, as are most user
    programs.
  </p>

  <p>
    The GNU/Linux operating system shows its multi-user/time-sharing
    heritage in the above standards:  They are well-developed to support
    the centralization of computing hardware.
    On small, single-user installations, most of the directories belong to
    a single filesystem.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux Filesystem Heirarchy Standard</a></li>
    <li><a href="https://www.tldp.org/LDP/sag/html/dir-tree-overview.html">Overview of the Directory Tree: Linux System Administrator's Guide</a></li>
  </ul>
</div>

<div id="regular-files" class="content">
  <h2>Regular Files</h2>

  <p>
    In Unix, a file is a sequence of bytes.<sup><a href=#references>[1]</a></sup>
    This definition is sufficiently abstract to allow, for instance, a keyboard
    to appear as a file.
    Ken Thompson's <em>Unix</em> kernel facilitated reading and writing of files,
    but otherwise refrained from interjection.
    This approach was quite novel for its time: Earlier
    operating systems interposed upon the handling of files, so that
    some files could only be read by some programs, and not by others.<sup><a href=#references>[1]</a></sup>
    In my opinion, this uniformity begins <a href="https://en.wikipedia.org/wiki/Unix_philosophy">"The Unix Philosophy."</a>
  </p>

  <p>
    A regular file contains data which is stored on-disk.
    The regular file is the prototypical "file" type;
    approximately 80% of files are regular files (Stevens, 98).
  </p>

  <div class="aside-left">
    <h4> Aside: </h4>
    <p>
      <em>Root</em> has such power over the system that I
      like to think of it as acting on behalf of the system itself.
      It is not a <em>user</em>, per se.
    </p>
  </div>

  <p>
    In both Unix and its derivatives, each file has an owner, and belongs to a group.
    Important files are owned by <code>root</code>, the superuser of the system.
    Because the owner of a given file is permitted to do anything to it, we typically wish
    to avoid acting as <code>root</code>, and instead use <code>sudo</code> wherever possible.
  </p>

  <p>
    The accessibility of each file is controlled by
    nine <em>access permission bits</em>, also called <em>mode bits</em>.
    Only the owner of the file can change these.
    They are:
    <code>read</code>, <code>write</code> and <code>execute</code> for each,
    <em>owner</em>, <em>group</em>, <em>everyone else</em>.
    These bits are maintained within the file's inode.
  </p>

  <p>
    Here we have a typical listing:
  </p>

  <a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for printable" ></a>

  <p>
    We see that <code>bash</code> is executable by anybody, but can
    only be written to (changed by) <code>root</code>.
    File mode bits can be changed with the
    <a href="https://www.man7.org/linux/man-pages/man1/chmod.1.html"><code>chmod(1)</code></a> utility.
  </p>

  <p>
    Beyond <code>ls</code>, two other command-line tools are useful for peeking
    into a file. They are <code>file</code>, which gives a brief description of
    the file's type, and <code>stat</code>, which gives a human-readable
    summary of the file's inode's metadata:
  </p>

  <div class="code">
    $ file /bin/bash<br>
    /bin/bash: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br>
    dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <br>
    BuildID[sha1]=a43fec47192ff49c2d3fed671f2be8df7e83784a, for <br>
    GNU/Linux 3.2.0, stripped<br><br>
    $ stat /bin/bash<br>
    File: /bin/bash<br>
    Size: 1183448   	Blocks: 2312       IO Block: 4096   regular file<br>
    Device: 802h/2050d	Inode: 1835042     Links: 1<br>
    Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)<br>
    Access: 2020-07-14 13:33:43.628528710 -0500<br>
    Modify: 2020-02-25 06:03:22.000000000 -0600<br>
    Change: 2020-07-09 11:20:12.676956656 -0500<br>
    Birth: -<br>
  </div>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://www.man7.org/linux/man-pages/man1/chmod.1.html">chmod(1)</a></li>
    <li><a href="https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation">File System Permissions - Numeric Notation - Wikipedia </a></li>
  </ul>

</div>

<div class="content" id="pseudo">
  <h2>Pseudo Files</h2>
  <p>
    The GNU/Linux directory tree is used as a general-purpose meeting place.
    In addition to regular files, it also contains
    information about running processes, information about the (running) kernel,
    and references to hardware drivers, each in the form of files.
    This mechanism is general, extensible, and allows both users and programmers
    access to the running machine.
  </p>

  <p>
    For example, the file <code>/proc/filesystems</code> contains the
    filesystems supported by the running kernel:
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Other interesting pseudo files are <code>/proc/meminfo</code>,
      and <code>/dev/urandom</code>.
    </p>
  </div>

  <div class="code">
      $ cat /proc/filesystems <br>
      nodev	sysfs<br>
      nodev	tmpfs<br>
      nodev	bdev<br>
      nodev	proc<br>
      ext3<br>
      ext2<br>
      ext4<br>
      squashfs<br>
      vfat<br>
      ...<br>
    </div>

  <p>
    These are known as <em>psuedo</em> or <em>synthetic</em> files.
    A pseudo file is a file that exists only in virtue of the kernel.
    It does not exist on a disk, and does not exist on any persistent filesystem.
  </p>

  <p>
    To explain, a running program is restricted to querying the kernel
    about files:  To read a file, it asks the kernel; to get directory
    entries, it asks the kernel; etc.
    As such, we can interject upon this&mdash; we can make it
    "look like" a file is in a directory by including it as a directory entry in
    response to an appropriate query.
    Similarly, we can make it "look like" it has contents by giving
    information back, when a program requests it.
    As a consequence of this, these files appear to be actual files, when
    in fact their contents are generated by the kernel when a program
    asks for them.
  </p>

  <p>
    The underlying machinery involves actual filesystems.
    The <code>/proc</code> directory, which uses the <em>proc</em>
    filesystem, contains information about
    each running program (process) on the system.
    Its contents are organized by process id number, with one "directory"
    for each process.
    Similarly, the <code>/sys</code> directory is a mounted <em>sysfs</em>
    filesystem, and contains in-depth information about the kernel.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li> <a href="https://man7.org/linux/man-pages/man5/proc.5.html"><code> proc(5) </code> </a> </li>
    <li> <a href="https://www.man7.org/linux/man-pages/man1/watch.1.html"> <code> watch(1) </code> </a> </li>
  </ul>
</div>


<div id="device-files" class="content">
  <h2>Device Special Files</h2>

  <p>
    A <em>device special file</em> represents a device connected to the system;
    they reside in the <code>/dev</code> directory.<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">[10]</a></sup>
    Each special device file serves as the principle reference to its respective device.
    Let's consider the task of creating a boot media, "the hard way."
  </p>

  <p>
    I would like to install Arch Linux onto my PineBook Pro.
    I download a new installation image via torrent, then compare the resulting file
    against the checksum file included in the same directory, using <code>sha256sum(1)</code>.
    It matches character-wise; this means that the file is correct and intact.
  </p>

  <p>
    Next, I insert my USB stick and locate it with <code>lsblk</code>; it
    has been mounted, and I need it unmounted so that I can write to the
    device directly (without filesystem), through its device special file.
    I unmount the device, and double-check with another call to <code>lsblk</code>.
  </p>

  <p>
    This is where things get hairy, because we will be writing to a device
    (in this case, <em>/dev/sdb</em>) with root privileges.
    Note that my system's hard drive is <em>/dev/sda</em>.
    Because I can, I decide to create the boot media with <code>cat</code>
    (a thorough investigation revealed that
    <em><a href="https://www.man7.org/linux/man-pages/man1/cat.1.html">cat</a></em>
    and <em><a href="https://www.man7.org/linux/man-pages/man1/dd.1.html">dd</a></em> are exceptionally similar).
    The caveat is that one must be acting as superuser:
  </p>

  <div class="code">
    # cat archlinux-2020.07.02-pbp.img > /dev/sdb
  </div>

  <p>
    And, success! Granted, <code>dd</code> would have been faster and safer.
  </p>

  <p>
    As the command above points out, my usb stick, <em>/dev/sdb</em>
    appears in the system as a file: We can read from it, and write to it.
    Moreover, all operations that we need to do can be done through this interface.
    For instance, if we wanted to partition a drive:
  </p>

  <div class="code">
    $ sudo fdisk /dev/sdb
  </div>

  <p>
    This utility will read the existing partition table on the device and
    tell us about it, and it will allow us to write a new partition table to the device.
    Furthermore, the <em>mkfs</em> (make filesystem) utilities write
    a new/empty filesystem to a file, allowing us to format a partition.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://wiki.archlinux.org/index.php/Device_file">Device File - ArchWiki</a></li>
  </ul>
</div>


  <div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>
    <h3> Virtual File System (Kernel Subsystem)</h3>
    <p>
      The above discussion gives rise to a few questions:
    </p>

    <ol>
      <li> How can the Linux kernel support multiple filesystems? </li>
      <li> How can it do so simultaneously?  </li>
      <li> How does it handle filesystems that <em>do not</em> use inodes?</li>
    </ol>

    <p>
      The answer to each of these is the
        Virtual File System (VFS), a kernel subsystem that acts,
        essentially, as a driver for filesystems.
        While each filesystem may implement its own functionality,
        most functionality is common;
        the Virtual File System provides a uniform interface by
        implementing filesystem-related system calls, such as <code>open</code>, <code>read</code>, etc..<sup> <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">[11]</a></sup>
      </p>

      <p>
        As for inodes, a more formal definition is given by kernel.org:
        "An inode object represents an object within the filesystem."<sup><a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">[11]</a></sup>
        That is, on filesystems that do not use inodes, they are imposed virtually by
        the VFS, as a means of representing files.
        As a consequence, the discussion about inodes given here remains
        conceptually correct even when non-Unix-like filesystems are being employed.
      </p>

    <h3> Filesystem vs. Directory Tree</h3>
    <p>
      The terms <em>filesystem</em> and <em>directory tree</em> were developed here
      precisely, in order to make a clear distinction between the two.
      However, the terms overlap, somewhat:
      In *nix, each filesystem must entertain exactly one directory tree
      (specifically, it must contain exactly one root directory).
      Because of this, each filesystem implies a directory tree;
      this is the sense in which it is valid to say, "We are going to mount
      a filesystem at <code>/home</code>," when in fact we mean,
      "We are going to mount a filesystem's root directory at <code>/home</code>."
    </p>

    </div>

    <div id="lvl1" class="content">
      <h2>Level-1 Linux</h2>
          <iframe class="video" src="https://www.youtube.com/embed/lsFDp-W1Ks0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    </div>

    <div id="references" class="content">
      <h2> References </h2>
      <ol>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> File Systems. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.osdev.org/Filesystem">https://wiki.osdev.org/Filesystem</a> </li>
        <li> File systems - ArchWiki. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.archlinux.org/index.php/File_systems">https://wiki.archlinux.org/index.php/File_systems</a> </li>
        <li> Ext4 - Wikipedia. (2020, June 14). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/Ext4">https://en.wikipedia.org/wiki/Ext4</a> </li>
        <li> Ext4 Disk Layout - Ext4. (2019, August 26). Retrieved July 17, 2020, from <a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout</a></li>
        <li> ZFS - Wikipedia. (2020, July 15). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/ZFS">https://en.wikipedia.org/wiki/ZFS</a></li>
        <li> File Allocation Table - Wikipedia. (2020, July 12). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/File_Allocation_Table">https://en.wikipedia.org/wiki/File_Allocation_Table</a></li>
        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). The Root Filesystem. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html</a> </li>
        <li> Wirzenius, L. (2004). Chapter 3: Overview of the Directory Tree. In <em>Linux System Administrator's Guide.</em> <a href="https://www.tldp.org/LDP/sag/html/fs-background.html">https://www.tldp.org/LDP/sag/html/fs-background.html</a></li>
        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). The Root Filesystem. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html</a></li>
        <li> Overview of the Linux Virtual File System - The Linux Kernel Documentation. (n.d.). Retrieved July 17, 2020, from <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">https://www.kernel.org/doc/html/latest/filesystems/vfs.html</a> </li>
      </ol>

    </div>
