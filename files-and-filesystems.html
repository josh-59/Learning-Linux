---
layout: default
credits: default
title: Files and Filesystems
last-updated: July, 2020
---

<!-- To Do: Citation needed in "regular files" -> heirarchical filestructure taken from Multics-->
<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#filesystems"> Filesystems </a></li>
    <li><a href="#directories"> Directories </a></li>
    <li><a href="#directory-tree"> Directory Tree </a></li>
    <li><a href="#mounting-unmounting"> Mounting and Unmounting</a></li>
    <li><a href="#regular-files"> Regular Files </a></li>
    <li><a href="#device-files"> Device Special Files </a></li>
    <li><a href="#closing-remarks"> Closing Remarks </a></li>
    <li><a href="#lvl1"> Level 1 Linux </a></li>
    <li><a href="#references"> References </a></li>
    <li><a href="#credits">Credits and Licenses</a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>Files and Filesystems</h1>
  <!-- <h4>"In the beginning, the file was without form, and void;
  and emptiness was upon the face of the bits.
  And the Fingers of the Author moved upon the face of the keyboard.
  And the Author said, Let there be words, and there were words.".</h4> -->
  <h4>Under Construction!</h4>

  <p>
    Unix began life as a filesystem.<sup><a href=#references>[1]</a></sup>
    Shortly thereafter, a means
    of interacting with it was created&mdash; initially,
    this consisted of the <code>exec</code>
    system call, a shell, a text editor and an assembler.
    Written entirely by Ken Thompson, these key components formed the nexus of
    the time-sharing operating system that would eventually be called
    <em>Unix</em>.
  </p>

  <p>
    This file-first approach to operating system design is found in
    the implementation as well as the history of Unix:
    Unix and its derivatives use files for many things.
    As such, there is a lot to be said about files.
    This paper introduces the <em>filesystem</em>, 
    discusses the directory structure implemented on top of it,
    and gives a practical overview of the contents of them.
  </p>
</div>

<div id="filesystems" class="content">
  <h2> Filesystems </h2>
  <p>
    A filesystem is a systematic method of organizing data on 
    disk.<sup><a href="https://wiki.osdev.org/Filesystem">[2]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[3]</a></sup>
    Conceptually, it is similar to a data structure, in that it defines a convention
    to be followed in the storage and retrieval of data.
    A given disk is usually <em>partitioned</em> into several logically-distinct components.
    All partitions are contiguous with respect to the disk's address space, and
    entertains its own distinct filesystem, if any. 
    Preparing a partition for use by a particular filesystem is known as
    formatting.<sup><a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">[4]</a></sup>.
  </p>

  <ul>
    <h3>Some Common Filesystems:</h3>
    <li>
      <p>
        <strong>EXT4</strong>:
        Introduced in 2008,<sup><a href="https://en.wikipedia.org/wiki/Ext4">[5]</a></sup> EXT4 is
        the current standard Linux filesystem.
        It is an evolutionary enhancement on EXT3,
        supporting larger filesizes, deeper subdirectory support,
        faster handling of large files, along with many other improvements.<sup><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">[6]</a></sup>
        It is mature, fast, and stable.
      </p>
    </li>

    <div class="aside-right">
      <h4>Aside</h4>
      <p>
        A filesystem describes how files are stored, but it's the kernel's responsibility to abide by this specification.
        Thus, the details of creating, reading and writing are the left to the kernel.
        In Linux, the filesystems known by the current kernel are 
        listed in the <code>/proc/filesystems</code> file.<sup><a href="#references">[7]</a></sup>
      </p>
    </div>

    <li>
      <p>
        <strong>ZFS</strong>:
        "Don't use ZFS.  It's that simple." &mdash;<a href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189841">Linus Torvalds</a>.
      </p>

      <p>
        Introduced in 2005,<sup><a href="https://en.wikipedia.org/wiki/ZFS">[8]</a></sup> ZFS incorporates fancier features that are generally
        out of place on a Linux desktop.
        It was developed by Sun Microsystems, and became closed-source with Sun's acquisition by
        Oracle.<sup><a href="https://en.wikipedia.org/wiki/ZFS">[8]</a></sup>
        It was intended for enterprise use, and is
        <a href="https://en.wikipedia.org/wiki/ZFS#Inappropriately_specified_systems">relatively easy to configure improperly.</a>
        Also, ZFS is <a href="https://wiki.archlinux.org/index.php/ZFS">not free</a>.
      </p>
    </li>

    <li>
      <p>
        <strong>FAT32</strong>: The "File Allcoation Table 32-bit" is a DOS-era filesystem,<sup><a href="https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32">[9]</a></sup>
        and is widely supported, though antiquated.
        In particular, it is not a <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling filesystem</a>,
        so that changes to data are not recorded before being carried out (increasing the likelihood of
        corruption in the event of, say, power outage).
        This format is often used to hold the bootloader, since it is virtually guaranteed to be supported by firmware.
      </p>
    </li>
  </ul>

  <p>
    System V Unix implemented its filesystem as an integral part of the operating system;
    it was unnamed, though well-documented (by, for instance, Maurice J. Bach in <em>The Design of the Unix Operating System</em>).
    The Extended Filesystem (EXT) was an open-source variant, and retained many distinctive features of the original;
    since then, EXT2, EXT3, and EXT4 have continued to improve upon the design.
  </p>

  <h3> inodes </h3>

  <p>
    A key feature of the architecture of the System V filesystem
    was the <em>inode.</em>
    This feature has been retained throughout the Extended Filesystem series,
    and is a key to understanding files in Linux.
    The inode of a file serves as the filesystem's unique reference to the file.
    It contains information describing where the data of the file is,
    in addition to metadata about the file, such as its size, access permissions
    and timestamps.
  </p>

  <p>
    The set of all inodes in a filesystem is organized in an array;
    in most filesystems, this array is located near the beginning of the partition.
    An inode number is an index into this array, and therefore serves as a
    reference to a unique inode.
    Each inode&mdash; and therefore each file&mdash; has a unique inode number within its
    filesystem.
  </p>

  <p>
    Intuitively, a file's inode number serves as the "hardware name" of a file, 
    since it is unique to the file within its filesystem.
    For the kernel, the information required to uniquely identify a file
    is its inode number and the device (drive & partition) of the filesystem it belongs to.
  </p>

  <h3> See Also: </h3>
  <ul>
    <li> <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">An Introduction to Disk Partitions - Fedora Docs Site</a></li>
    <li> <a href="https://ext4.wiki.kernel.org/index.php/Main_Page">Ext4 (and Ext2/Ext3) Wiki </a></li>

    <li> <a href="http://web.mit.edu/tytso/www/linux/ext2intro.html"> Design and Implementation of the Second Extended Filesystem</a> (Discusses inodes)</li>
    <li> <a href="https://www.man7.org/tlpi/">The Linux Programming Interface</a>, Chapter 14: Filesystems </li>
  </ul>
</div>

<div id="directories" class="content">
  <h2>Directories</h2>

  <p>
    Directories link inode numbers to filenames&mdash; specfically, they link to the file's 
    <a href="finding-files.html#basename">basename</a>.
    We can therefore think of a directory as a file containing two columns:
    inode number and basename.  
    Each entry in the table is known as a <em>hard link.</em>
    Since a directory belongs to a filesystem, this information is sufficient to uniquely
    identify a file only within the filesystem the directory belongs to.
    Consequently, <em>hard links may not cross filesystem boundaries.</em>
  </p>

  <p>
    We can list the contents of a directory with the usual <code>ls</code> command,
    and can list inode numbers using the <code>-i</code> switch:
  </p>

  <div class="code">
    $ ls -i newfile <br>
    2112949 newfile
  </div>

    <p>
        The above components suggest a great deal of the structure of the *nix filesystem
        scheme, and the rest of this paper will be spent, mostly, bearing that out.
        To begin, a file may have more than one hard link, without contradiction.
        This allows a file to appear in more than one directory, or more than once
        in a single directory.  
        We can create new hardlinks with the <code>ln</code> command:
    </p>

    <div class="code">
        $ ln newfile 2newfile <br>
        $ ls -i newfile 2newfile <br>
        2112949 newfile <br> 
        2112949 2newfile <br>
    </div>

    <div class="aside-right">
        <h4>Aside</h4>
        <p>
        Both directories and filesystems are the responsibility of the kernel.
        User-space processes are not permitted to read or write
        directly to directory files.
        System calls exist to:
        <ul style="padding-left: 20px; margin-top: 0">
          <li><a href="https://www.man7.org/linux/man-pages/man2/mkdir.2.html">create directories</a></li>
          <li><a href="https://www.man7.org/linux/man-pages/man2/rmdir.2.html">remove directories</a></li>
          <li><a href="https://www.man7.org/linux/man-pages/man2/getdents.2.html">get directory entries</a></li>
        </ul>
      </p>
    </div>
  </div>


<div id="directory-tree" class="content">
  <h2> Directory Tree</h2>

    <p>
      Each directory has at least two entries, which cannot be changed, and
      which help define the Linux directory structure.  They are,
      <code>.</code> ("dot"), which refers to the containing directory itself,
      and <code>..</code> ("dot dot"), which refers to its parent directory.
      The root directory's parent directory is the root directory itself.
    </p>



  <div class="code">
    /
  </div>

  <p>
    Within any GNU/Linux distribution, some common themes will be found.
    For instance, <code>bin</code> directories are found in several places, such as
    <code>/bin</code> and <code>/sbin</code>, along with <code>/usr/bin</code> and often
    <code>/home/user/bin</code>.
    These contain binary executable files (programs), such as <code>ls</code>, which
    can be ran as commands from the shell.
  </p>

  <p>
    The directory <code>/etc</code> (usually read "<em>et</em>-c") contains host-specific
    system configuration files; as a consequence, you can expect to fiddle
    with the contents of this directory when configuring the system for the first time
    (or otherwise).
    It contains, for instance, files describing the configuration of the system's package
    manager, printers, and, well, etcetera.
  </p>

  <p>
    The directory tree is used as a general-purpose meeting place:
    In addition to regular files, it also holds, for instance, references to hardware drivers,
    and information about running processes.
    This mechanism is general, extensible, and allows both users and programmers
    access to the running machine; the only trick is keeping it organized.
  </p>

  <p>
    The <a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux Filesystem Heirarchy Standard</a>
    officially describes the Linux filesystem.  It is a "follow along standard":
    It codifies the Linux filesystem as it commonly appears at the time of its publication,
    and does not arbitrarily impose a standard prior to implementation.
    For instance, while the <code>/proc</code> virtual filesystem is lauded by the standard,
    it <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch06.html#procKernelAndProcessInformationVir">has not yet been described</a>.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://www.tldp.org/LDP/sag/html/dir-tree-overview.html">Overview of the Directory Tree: Linux System Administrator's Guide</a></li>
    <li><a href="https://wiki.archlinux.org/index.php/Device_file">Device File - ArchWiki</a></li>
  </ul>
</div>

<div class="content" id="mounting-unmounting">

  <h2>Mounting and Unmounting</h2>

  <p>
    Unlike Windows systems, which create a new, distinct directory tree
    for each storage device on the system (<code>C:\, D:\</code>, etc.),
    Linux systems place a new filesystem's directory tree within the existing
    directory tree, in an operation called
    <a href="https://www.man7.org/linux/man-pages/man8/mount.8.html"><em>mounting</em></a>.
  </p>

  <p>
    Let's take a look at the <code>mount</code> operation, for this is new.
    Suppose you have a usb stick with some music on it, and you'd
    like to access its contents.
    After it's plugged into your computer, the hardware, then the kernel,
    recognize it, but it may not be accessible:
  </p>

  <img style="width:80%" src="assets/img/mounting.png">

  <p>
    When mounting new devices manually, the usual method is to identify the device
    to be mounted with <code>lsblk</code>, then mount it with
    <a href="https://www.man7.org/linux/man-pages/man8/mount.8.html"><code>sudo mount DEVICE MOUNTPOINT</code></a>.
    The device to be mounted should be a partition, and can usually be determined by its size and
    its mountpoint (which should be none).
    The Linux Filesystem Hierarchy Standard provides two places to mount temporary
    filesystems: <code>/mnt</code> and <code>/media/[user]</code>
  </p>

  <p>
    Similarly, to unmount a filesystem, we first identify the correct
    partition with <code>lsblk</code>,
    then unmount it with <a href="https://www.man7.org/linux/man-pages/man8/umount.8.html"><code>sudo umount PATH</code></a>,
    where <code>PATH</code> is the location of the mounted filesystem.
  </p>

  <p>
    A few details:
    First, device names that appear in <code>/dev</code> or <code>lsblk</code>
    <em>are not</em> guaranteed to be stable across reboots&mdash; The devices are named in the
    order that they are found.
    Second, when mounting a new filesystem, if any files exist at the
    mount point, they will be "hidden" by the files of the new filesystem.
    They are not deleted, and unmounting the new filesystem will "reveal" them again.
    Finally, a filesystem must be not be in use to be unmounted; in particular,
    you must <code>cd</code> out of it before calling <code>umount</code>.
  </p>


  <p>
    In practice, most distributions automatically mount
    usb sticks when they are plugged in.
  </p>


</div>
<div id="regular-files" class="content">
  <h2>Regular Files</h2>

  <p>
    In Unix, a file was a sequence of bytes (Kernighan, 62).
    This definition is sufficiently abstract to allow, for instance, a keyboard
    to appear as a file.
    Ken Thompson's <em>Unix</em> kernel facilitated reading and writing of files,
    but otherwise refrained from interjection.
    This approach was quite novel for its time: Earlier
    operating systems interposed upon the handling of files, so that
    some files could only be read by some programs, and not by others (Kernighan, 62).
    In my opinion, this uniformity begins <a href="https://en.wikipedia.org/wiki/Unix_philosophy">"The Unix Philosophy."</a>
  </p>

  <p>
    A regular file contains data which is stored on-disk.
    The regular file is the prototypical "file" type;
    approximately 80% of files are regular files (Stevens, 98).
  </p>

  <p>
    In both Unix and Linux, each file has an owner, and belongs to a group.
    Only the owner of a file can delete it.
    Important files are owned by <code>root</code>, the superuser of the system.
    Because the owner of a given file is permitted to do anything to it, we typically wish
    to avoid acting as <code>root</code>, and instead use <code>sudo</code> wherever possible.
  </p>

  <p>
    The accesiblity of each file is controlled by the owner through
    nine <em>access permission bits</em>, also called <em>mode bits</em>.
    and only the owner of the file can change these.
    They are:
    <code>read</code>, <code>write</code> and <code>execute</code> for each,
    <em>owner</em>, <em>group</em>, <em>everyone else</em>.
    These bits, and other metadata, are maintained within the file's inode.
  </p>

  <p>
    Here we have a typical directory listing:
  </p>

  <a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for printable" ></a>

  <p>
    We see that <code>bash</code> is executable by anybody, but can
    only be written to by <code>root</code>.
    File mode bits can be changed with the
    <a href="https://www.man7.org/linux/man-pages/man1/chmod.1.html"><code>chmod(1)</code></a> utility.
  </p>

  <h3>A Short Example</h3>

  <div class="code">
    $ echo "hello world" > newfile <br>
    $ cat newfile <br>
    hello world <br>
    $ chmod -r newfile &emsp;&emsp;&emsp;&emsp; #Remove read permissions on newfile<br>
    $ cat newfile <br>
    cat: newfile: Permission denied <br>
  </div>

  <h3> Reference Count & Deleting </h3>
    

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions">File Permissions (GNU Coreutils)</a></li>
    <li> <a href="https://www.man7.org/linux/man-pages/man1/chown.1.html"<code>chown(1)</code></a></li>
  </ul>

</div>


<div id="device-files" class="content">
  <h2>Device Special Files</h2>
  <p>
    The directory <code>/dev</code> is famous in the Unix/Linux world.
    It contains files called <em>special device files</em>,<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">[1]</a></sup>
    which <em>are not</em> regular files, and are not existent on-disk.
    Each special device file represents a device connected to the system;
    it serves as the principle reference to the device driver (and, therefore, the device).
  </p>

  <p>
    For instance, when we want to partition a drive, we pass the name of the drive
    (say, <code>/dev/sdb</code>) to a program, such as <code>fdisk</code>:
  </p>

  <div class="code">
    $ sudo fdisk /dev/sdb
  </div>

  <p>
    Note that <code>fdisk</code> is a user-space program.
    That is, the operating system has not undertaken the task of
    providing the user an interface for partitioning.
    This is an example of <em>The Unix Philosophy:</em>
    By keeping each tool in the chain small, they are each more easily maintainable, and
    we can interchange them more easily.
    Another program to do the same task is GNU's partition editor, <code>parted</code>.
  </p>

  <p>
    Among device special files, there are two distinct kinds:
    <em>block</em> and <em>character</em>.
    The distinction refers to the way that the kernel reads and writes to these files.
    Character special files are operated on a single character at a time
    (e.g., terminal screen), while block special files are operated on a block of
    bytes at a time (usually, 4096 or 8192), as in a hard drive.
  </p>

  <p>
    While there is too much going on in the <code>/dev</code> directory
    to exhaust the subject here,
    it's worth noting that utilities for displaying the current
    system's hardware often begin with <code>ls</code>:
  </p>

  <ul>
    <li><code><a href="http://man7.org/linux/man-pages/man8/lsblk.8.html">lsblk</a></code> - List block devices (hardrives, CD-drives, etc).  Useful to determine what drive to mount.</li>
    <li><code><a href="http://man7.org/linux/man-pages/man1/lscpu.1.html">lscpu</a></code> - Display information about the CPU architecture </li>
    <li><code><a href="http://man7.org/linux/man-pages/man8/lsusb.8.html">lsusb</a></code> - List usb devices </li>
    <li><code><a href="http://man7.org/linux/man-pages/man8/lspci.8.html">lspci</a></code> - List all PCI devices </li>
</div>



    <h3>Symbolic Links</h3>
    <p>
      Hard links cannot cross filesystem divisions.
    </p>

    <h3>See Also:</h3>
    <ul>
      <li><a href="https://unix.stackexchange.com/questions/20670/why-do-hard-links-exist">Why do hard links exist?</a></li>
    </ul>

  </div>

  <div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>
    <h3> Filesystem vs. Directory Tree</h3>
    <p>
      The terms <em>filesystem</em> and <em>directory tree</em> were developed here
      precisely, in order to make a clear distinction between the two.
      Part of the reason for this is a reaction by the author to common usage of the
      term <em>filesystem</em> as a catch-all for "all things whatever file (on disk)."
      I feel confident in the development of these terms in virtue of
      1) The development of the term "filesystem" in
      <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">An Introduction to Disk Partitions</a>, by Fedora,
      a leading-edge development community of Linux, and
      2) the mathematical definition of "tree".
    </p>

    <p>
      The terms <em>filesystem</em> and <em>directory tree</em> overlap, somewhat:
      A given filesystem must entertain exactly one directory tree.
      Because of this, a directory tree is implied by each filesystem;
      this is the sense in which it is valid to say, "We are going to mount
      a filesystem at <code>/home</code>," when in fact we mean,
      "We are going to mount a filesystem's directory tree at <code>/home</code>."
    </p>

    <h3>Linux Virtual File System (Kernel Subsystem)</h3>
    <p>
      The above discussion gives rise to a few questions:
    </p>

    <ol>
      <li> How can the Linux operating system support multiple filesystems? </li>
      <li> How can it do so simultaneously?  </li>
      <li> How does it handle filesystems that <em>do not</em> use inodes?</li>
    </ol>

    <p>
      The answer to each of these is the <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">
        Linux Virtual File System</a> (VFS), a kernel subsystem that acts,
        essentially, as a driver for filesystems.
        Whereas each filesystem type may implement its own functionality,
        most functionality is common;
        the Virtual Filesystem Switch provides both kernel-space threads and user-space processes with
        a uniform system call interface.
      </p>

      <p>
        As for inodes, a more formal definition is given by kernel.org:
        "An inode object represents an object within the filesystem."<sup><a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html#id1">[10]</a></sup>
        That is, on filesystems that do not use inodes, they are imposed virtually by
        the VFS, as a means of representing files.
        As a consequence, the discussion about inodes given above remains
        at least conceptually correct, when EXT2/EXT3/EXT4 are not being employed.
      </p>
    </div>

    <div id="lvl1" class="content">
      <h2>Level-1 Linux</h2>
          <iframe class="video" src="https://www.youtube.com/embed/lsFDp-W1Ks0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    </div>

    <div id="references" class="content">
      <h2> References </h2>
      <ol>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Filesystem Hierarchy Standard Group. <a href="https://www.pathname.com/fhs/pub/fhs-2.3.pdf">The Linux Filesystem Heirarchy Standard</a>.  Retrieved May 29, 2020.</li>
        <li> Stevens, W. Richard. <i><a href="http://www.apuebook.com/apue3e.html"> Advanced Programming in the Unix Environment.</a></i> Pearson Eduction, 2013.</li>
        <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
      </ol>

    </div>
