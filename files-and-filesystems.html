---
layout: default
credits: default
title: Files and Filesystems
last-updated: July, 2020
---

<!-- To Do: Citation needed in "regular files" -> heirarchical filestructure taken from Multics-->
<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#filesystems"> Filesystems </a></li>
    <li><a href="#directories"> Directories </a></li>
    <li><a href="#mounting-unmounting"> Mounting and Unmounting</a></li>
    <li><a href="#fs-heir"> Filesystem Heirarchy </a></li>
    <li><a href="#regular-files"> Regular Files </a></li>
    <li><a href="#synfs"> Synthetic Files </a></li>
    <li><a href="#device-files"> Device Special Files </a></li>
    <li><a href="#Virtual Filesystem"> Virtual Filesystem </a></li>
    <li><a href="#closing-remarks"> Closing Remarks </a></li>
    <li><a href="#lvl1"> Level 1 Linux </a></li>
    <li><a href="#references"> References </a></li>
    <li><a href="#credits">Credits and Licenses</a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>Files and Filesystems</h1>
  <!-- <h4>"In the beginning, the file was without form, and void;
  and emptiness was upon the face of the bits.
  And the Fingers of the Author moved upon the face of the keyboard.
  And the Author said, Let there be words, and there were words.".</h4> -->
  <h4>Under Construction!</h4>

  <p>
    Unix began life as a filesystem.<sup><a href=#references>[1]</a></sup>
    Shortly thereafter, a means
    of interacting with it was created&mdash; initially,
    this consisted of the <code>exec</code>
    system call, a shell, a text editor and an assembler.
    Written entirely by Ken Thompson, these key components formed the nexus of
    the time-sharing operating system that would eventually be called
    <em>Unix</em>.
  </p>

  <p>
    This file-first approach to operating system design is found in
    the implementation as well as the history of Unix:
    Unix and its derivatives use files for many things.
    As such, there is a lot to be said about files.
    This paper introduces the <em>filesystem</em>,
    discusses the directory structure implemented on top of it,
    and gives a practical overview of the contents of them.
  </p>
</div>

<div id="filesystems" class="content">
  <h2> Filesystems </h2>
  <p>
    A filesystem is a systematic method of organizing data on
    disk.<sup><a href="https://wiki.osdev.org/Filesystem">[2]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[3]</a></sup>
    Conceptually, it is similar to a data structure, in that it defines a convention
    to be followed in the storage and retrieval of data.
    A given disk is usually <em>partitioned</em> into several logically-distinct components.
    All partitions are contiguous with respect to the disk's address space, and
    entertains its own distinct filesystem, if any.
    Preparing a partition for use by a particular filesystem
    <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">is known as formatting.</a>
  </p>

  <ul>
    <h3>Some Common Filesystems:</h3>
    <li>
      <p>
        <strong>EXT4</strong>:
        Introduced in 2008,<sup><a href="https://en.wikipedia.org/wiki/Ext4">[5]</a></sup> EXT4 is
        the current standard Linux filesystem.
        It is an evolutionary enhancement on EXT3,
        supporting larger filesizes, deeper subdirectory support,
        faster handling of large files, along with many other improvements.<sup><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">[6]</a></sup>
        It is mature, fast, and stable.
      </p>
    </li>

    <div class="aside-right">
      <h4>Aside</h4>
      <p>
        A filesystem describes how files are stored, but it is the kernel's responsibility to abide by this specification.
        Thus, the details of creating, reading and writing files are left to the kernel.
      </p>
    </div>

    <li>
      <p>
        <strong>ZFS</strong>:
        "Don't use ZFS.  It's that simple." &mdash;<a href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189841">Linus Torvalds</a>.
      </p>

      <p>
        Introduced in 2005,<sup><a href="https://en.wikipedia.org/wiki/ZFS">[8]</a></sup> ZFS incorporates fancier features that are generally
        out of place on a Linux desktop.
        It was developed by Sun Microsystems, and became closed-source with Sun's acquisition by
        Oracle.<sup><a href="https://en.wikipedia.org/wiki/ZFS">[8]</a></sup>
        It was intended for enterprise use, and is
        <a href="https://en.wikipedia.org/wiki/ZFS#Inappropriately_specified_systems">relatively easy to configure improperly.</a>
        Also, ZFS is <a href="https://wiki.archlinux.org/index.php/ZFS">not free</a>.
      </p>
    </li>

    <li>
      <p>
        <strong>FAT32</strong>: The "File Allcoation Table 32-bit" is a DOS-era filesystem,<sup><a href="https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32">[9]</a></sup>
        and is widely supported, though antiquated.
        In particular, it is not a <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling filesystem</a>,
        so that changes to data are not recorded before being carried out (increasing the likelihood of
        corruption in the event of, say, power outage).
        This filesystem is often used to hold the bootloader, since it is virtually guaranteed to be supported by firmware,
        and it will not be changed very often.
      </p>
    </li>
  </ul>

  <p>
    System V Unix implemented its own filesystem as an integral part of the operating system;
    it was unnamed, though well-documented (by, for instance, Maurice J. Bach in <em>The Design of the Unix Operating System</em>).
    The Extended Filesystem (EXT) was an open-source derivative, and retained many distinctive features of the original;
    since then, EXT2, EXT3, and EXT4 have continued to improve upon the design.
  </p>

  <h3> inodes </h3>

  <p>
    A key feature of the architecture of the System V filesystem
    was the <em>inode.</em>
    This feature has been retained throughout the Extended Filesystem series,
    and is a key to understanding files in GNU/Linux.
    The inode of a file serves as the filesystem's unique reference to the file.
    It contains information describing where the data of the file is,
    in addition to metadata about the file, such as its size, access permissions
    and timestamps.
  </p>

  <div class="aside-left">
    <h4>Aside:</h4>
    <p>
      <em>Filesystem</em> is often abbreviated <em>fs.</em>
    </p>
  </div>

  <p>
    The set of all inodes in a filesystem is organized in an array;
    in most filesystems, this array is located near the beginning of the partition.
    An inode number is an index into this array, and therefore serves as a
    reference to a unique inode.
    Each inode&mdash; and therefore each file&mdash; has a unique inode number within its
    filesystem.
  </p>

  <p>
    Intuitively, a file's inode number serves as the "hardware name" of a file,
    since it uniquely identifies a file within a filesystem.
    For the kernel, which often manages more than one filesystem at a time,
    the information required to identify a file
    is its inode number and the filesystem it belongs to.
  </p>

  <h3> See Also: </h3>
  <ul>
    <li> <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">An Introduction to Disk Partitions - Fedora Docs Site</a></li>
    <li> <a href="https://man7.org/linux/man-pages/man7/inode.7.html"> inode(7) </a></li>
    <li> <a href="https://ext4.wiki.kernel.org/index.php/Main_Page">Ext4 (and Ext2/Ext3) Wiki </a></li>
    <li> <a href="http://web.mit.edu/tytso/www/linux/ext2intro.html"> Design and Implementation of the Second Extended Filesystem</a> (Discusses inodes)</li>
    <li> <a href="https://www.man7.org/tlpi/">The Linux Programming Interface</a>, Chapter 14: Filesystems </li>
  </ul>
</div>

<div id="directories" class="content">
  <h2>Directories</h2>

  <p>
    A directory is a file containing a table with two columns,
    <a href="finding-files.html#basename">basename</a> and inode number (Kerrisk, p. 339).
    Each entry in a directory's table is called a <em>hard link.</em>
  </p>

  <p>
    An inode number is sufficient to uniquely identify a file only within
    the filesystem the directory belongs to.
    Consequently, <em>hard links may not cross filesystem boundaries.</em>
    Another way of saying this is, "Every file belongs to the same filesystem
    as the directories which hard-link it."
  </p>

  <p>
    Every file on the system has an inode number.
    We list the contents of a directory with the usual <code>ls</code> command,
    and can list inode numbers using the <code>-i</code> switch:
  </p>

  <div class="aside-right">
      <h4>Aside:</h4>
      <p>
        The idea of using numerical values as names (i.e., unique identifiers)
        is common throughout computing.
        As we'll see later, each process has a
        unique numerical identifier, called its PID,
        which is used as the system's "handle" to the process.
        Other examples include user id's and memory addresses.
      </p>
  </div>

    <div class="code">
      $ echo "hello world" > newfile <br>
      $ ls -i newfile <br>
      2112949 newfile
    </div>

    <p>
        Files may be hard-linked more than once.
        This allows a file to appear in more than one directory, and/or more than once
        in a single directory.
        We can create new hard links with the <code>ln</code> command:
    </p>

    <div class="code">
        $ ln newfile 2newfile <br>
        $ ls -i newfile 2newfile <br>
        2112949 newfile <br>
        2112949 2newfile <br>
    </div>

    <p>
      The name <code>2newfile</code> is equivalent to the name
      <code>newfile</code>, since they link to the same inode number.
      If we modify the file using one name,
      then we have modified the file referred to by the other:
    </p>

    <div class="code">
      $ cat 2newfile <br>
      hello world<br>
      $ echo "hello from 2newfile" > 2newfile<br>
      $ cat newfile<br>
      hello from 2newfile
    </div>

    <p>
      A question arises: <em>"What if we delete <code>newfile</code>?"</em>
      With the above implementation in mind, there are two distinct operations
      that must take place to delete a file: First, remove all hardlinks to the file
      (that is, delete all directory entries linking it), and
      second, free the file (i.e., allow its inodes and data blocks to be reused).
      Deleting hardlinks is precisely what the <code>rm</code> command does.
      Freeing the file from the filesystem is left to the kernel, and
      takes place only if no hard links reference it.
    </p>

    <h3>Structure</h3>

    <p>
      While most files on the system are owned by a user,
      the contents of directories are, effectively, owned by the kernel.
      User-space processes are not permitted to read or write
      directly to directories.
      System calls exist to:
      <ul style="columns: 2; width: 80%; margin-left: 10%;">
        <li><a href="https://www.man7.org/linux/man-pages/man2/open.2.html">Create a new file</a></li>
        <li><a href="https://man7.org/linux/man-pages/man2/link.2.html">Create a new hardlink</a></li>
        <li><a href="https://man7.org/linux/man-pages/man2/unlink.2.html">Delete a hardlink</a></li>
        <li><a href="https://www.man7.org/linux/man-pages/man2/mkdir.2.html">Create a directory</a></li>
        <li><a href="https://www.man7.org/linux/man-pages/man2/rmdir.2.html">Remove a directory</a></li>
        <li><a href="https://www.man7.org/linux/man-pages/man2/getdents.2.html">Get directory entries</a></li>
      </ul>
      The layer of indirection offered by these interfaces affords the kernel
      the opportunity to restrict the manipulation of directories, and therefore,
      to impose structure upon the directories within a filesystem.
      In particular, directories are not allowed to be arbitrarily hard-linked
      (i.e., you cannot create new hardlinks to existing directories).
    </p>

    <p>
      Each directory contains at least two hard links, which cannot be changed, and
      which help define the filesystem's directory structure.  They are,
      <code>.</code> ("dot"), which refers to the containing directory itself,
      and <code>..</code> ("dot dot"), which refers to its parent directory.
      The root directory's parent directory is the root directory itself.
      Finally, each filesystem has a single root directory.
    </p>

    <h3> See Also: </h3>
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Symbolic_link#Overview"> Symbolic Link (Overview) - Wikipedia </a> </li>
    </ul>
</div>

<div class="content" id="mounting-unmounting">

  <h2>Mounting and Unmounting</h2>

  <p>
    Unlike Windows systems, which create a new, distinct directory tree
    for each storage device on the system (<code>C:\, D:\</code>, etc.),
    Linux systems place a new filesystem's directory tree within the existing
    directory tree, in an operation called
    <a href="https://www.man7.org/linux/man-pages/man8/mount.8.html"><em>mounting</em></a>.
  </p>

  <p>
    Let's take a look at the <code>mount</code> operation, for this is new.
    Suppose you have a usb stick with some music on it, and you'd
    like to access its contents.
    After it's plugged into your computer, the hardware, then the kernel,
    recognize it, but it may not be accessible:
  </p>

  <img style="width:80%" src="assets/img/mounting.png">

  <p>
    When mounting new devices manually, the usual method is to identify the device
    to be mounted with <code>lsblk</code>, then mount it with
    <a href="https://www.man7.org/linux/man-pages/man8/mount.8.html"><code>sudo mount DEVICE MOUNTPOINT</code></a>.
    The device to be mounted should be a partition, and can usually be determined by its size and
    its mountpoint (which should be none).
    The Linux Filesystem Hierarchy Standard provides two places to mount temporary
    filesystems: <code>/mnt</code> and <code>/media/[user]</code>.
  </p>

  <p>
    Similarly, to unmount a filesystem, we first identify the correct
    partition with <code>lsblk</code>,
    then unmount it with <a href="https://www.man7.org/linux/man-pages/man8/umount.8.html"><code>sudo umount PATH</code></a>,
    where <code>PATH</code> is the location of the mounted filesystem.
  </p>

  <p>
    A few details:
    First, device names that appear in <code>/dev</code> or <code>lsblk</code>
    <em>are not</em> guaranteed to be stable across reboots&mdash; The devices are named in the
    order that they are found.
    Second, when mounting a new filesystem, if any files exist at the
    mount point, they will be "hidden" by the files of the new filesystem
    (they become unaccessible).
    They are not deleted, and unmounting the new filesystem will "reveal" them again.
    Third, a filesystem cannot be in use while unmounting; in particular,
    you must <code>cd</code> out of the device before calling <code>umount</code>.
    Finally, unmount (eject) before unplugging!
  </p>
</div>

<div id="fs-heir" class="content">
  <h2>Filesystem Heirarchy</h2>

  <p>
    Now, we turn to more pragmatic matters.
    Within any GNU/Linux distribution, some common themes will be found.
    For instance, <code>bin</code> directories are found in several places, such as
    <code>/bin</code> and <code>/sbin</code>, along with <code>/usr/bin</code>.
    These contain binary executable files (programs), such as <code>ls</code>, which
    can be ran as commands from the shell.
  </p>

  <div class="aside-right" style="font-size: 15px;">
    <h4>Aside:</h4>
      <p>
        The <a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux Filesystem Heirarchy Standard</a>
        describes the working GNU/Linux directory structure.  It is a "follow along standard":
        It codifies the Linux filesystem as it commonly appears at the time of its publication,
        and does not arbitrarily impose a standard prior to implementation.
      </p>
  </div>

  <p>
    The directory <code>/etc</code> (usually read "<em>et</em>-see") contains
    system-specific configuration files; as a consequence, you can expect to fiddle
    with the contents of this directory when configuring the system for the first time
    (or otherwise).
    It contains, for instance, files describing the configuration of the system's package
    manager, printers, and, well, etcetera.
  </p>

  <p>
    <code>/home</code> contains user's home directories.
    Per-user configuration files are contained here either as
    hidden files, or in the directory <code>~/.config</code>.
    Unix-like systems are often constructed such that the home directory is
    mounted as a separate filesystem.
    One reason to do this is that it helps prevent
    users from threatening the system by consuming all its
    storage space.
  </p>

  <p>
    According the the standard, the system's root directory, <code>/</code>, should belong
    to a minimal filesystem that is "adequate to boot, restore recover and/or repair the system."<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html">[5]</a></sup>
    As such, <code>/bin</code>, <code>/sbin</code>, <code>/etc</code>, <code>/media</code>,
    and <code>/mnt</code> should each belong to the root filesystem.
    Moreover, critical user programs, such as <code>ls</code> and <code>bash</code>,
    are kept here, as well.
  </p>

  <p>
    The last directory we will cover is <code>/usr</code>, which contains
    files which are shareable across systems&mdash; they do not change in normal
    operation, and are not machine-specific.
    This stipulation allows multiple machines to share a single <code>/usr</code>
    directory by locating it on a network,
    potentially saving large amounts of storage.<sup><a href="https://www.tldp.org/LDP/sag/html/fs-background.html">[6]</a></sup>
    For instance, man-pages are found in <code>/usr</code>, as are most user
    programs.
  </p>

  <p>
    The GNU/Linux operating system shows its multi-user/time-sharing
    heritage in the above standards:  They are well-developed to support
    the centralization of computing hardware.
    On small, single-user installations, most of the directories belong to
    a single filesystem.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux Filesystem Heirarchy Standard</a></li>
    <li><a href="https://www.tldp.org/LDP/sag/html/dir-tree-overview.html">Overview of the Directory Tree: Linux System Administrator's Guide</a></li>
  </ul>
</div>

<div id="regular-files" class="content">
  <h2>Regular Files</h2>

  <p>
    In Unix, a file is a sequence of bytes.<sup><a href=#references>[1]</a></sup>
    This definition is sufficiently abstract to allow, for instance, a keyboard
    to appear as a file.
    Ken Thompson's <em>Unix</em> kernel facilitated reading and writing of files,
    but otherwise refrained from interjection.
    This approach was quite novel for its time: Earlier
    operating systems interposed upon the handling of files, so that
    some files could only be read by some programs, and not by others.<sup><a href=#references>[1]</a></sup>
    In my opinion, this uniformity begins <a href="https://en.wikipedia.org/wiki/Unix_philosophy">"The Unix Philosophy."</a>
  </p>

  <p>
    A regular file contains data which is stored on-disk.
    The regular file is the prototypical "file" type;
    approximately 80% of files are regular files (Stevens, 98).
  </p>

  <div class="aside-left">
    <h4> Aside: </h4>
    <p>
      <em>Root</em> has such power over the system that I
      like to think of it as acting on behalf of the system itself.
      It is not a <em>user</em>, per se.
    </p>
  </div>

  <p>
    In both Unix and its derivatives, each file has an owner, and belongs to a group.
    Important files are owned by <code>root</code>, the superuser of the system.
    Because the owner of a given file is permitted to do anything to it, we typically wish
    to avoid acting as <code>root</code>, and instead use <code>sudo</code> wherever possible.
  </p>

  <p>
    The accessibility of each file is controlled by
    nine <em>access permission bits</em>, also called <em>mode bits</em>.
    Only the owner of the file can change these.
    They are:
    <code>read</code>, <code>write</code> and <code>execute</code> for each,
    <em>owner</em>, <em>group</em>, <em>everyone else</em>.
    These bits are maintained within the file's inode.
  </p>

  <p>
    Here we have a typical directory listing:
  </p>

  <a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for printable" ></a>

  <p>
    We see that <code>bash</code> is executable by anybody, but can
    only be written to (changed by) <code>root</code>.
    File mode bits can be changed with the
    <a href="https://www.man7.org/linux/man-pages/man1/chmod.1.html"><code>chmod(1)</code></a> utility.
  </p>

  <p>
    Beyond <code>ls</code>, two other command-line tools are useful for peeking
    into a file. They are <code>file</code>, which gives a brief description of
    the file's type, and <code>stat</code>, which gives a human-readable
    summary of the file's inode's metadata:
  </p>

  <div class="code">
    $ file /bin/bash<br>
    /bin/bash: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br>
    dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <br>
    BuildID[sha1]=a43fec47192ff49c2d3fed671f2be8df7e83784a, for <br>
    GNU/Linux 3.2.0, stripped<br><br>
    $ stat /bin/bash<br>
    File: /bin/bash<br>
    Size: 1183448   	Blocks: 2312       IO Block: 4096   regular file<br>
    Device: 802h/2050d	Inode: 1835042     Links: 1<br>
    Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)<br>
    Access: 2020-07-14 13:33:43.628528710 -0500<br>
    Modify: 2020-02-25 06:03:22.000000000 -0600<br>
    Change: 2020-07-09 11:20:12.676956656 -0500<br>
    Birth: -<br>
  </div>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation">File System Permissions - Numeric Notation - Wikipedia </a></li>
  </ul>

</div>

<div class="content" id="synfs">
  <h2>Synthetic Files</h2>
  <p>
    The GNU/Linux directory tree is used as a general-purpose meeting place.
    In addition to regular files, it also contains
    information about running processes, information about the (running) kernel,
    and references to hardware drivers, each in the form of files.
    This mechanism is general, extensible, and allows both users and programmers
    access to the running machine; it is the source of the catechism,
    <em>"Everything is a file."</em>
  </p>

  <p>
    For example, the file <code>/proc/filesystems</code> contains the
    filesystems supported by the running kernel:
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Other interesting synthetic files are <code>/proc/meminfo</code>,
      and <code>/dev/urandom</code>.
    </p>
  </div>

  <div class="code">
      $ cat /proc/filesystems <br>
      nodev	sysfs<br>
      nodev	tmpfs<br>
      nodev	bdev<br>
      nodev	proc<br>
      ext3<br>
      ext2<br>
      ext4<br>
      squashfs<br>
      vfat<br>
      ...<br>
    </div>

  <p>
    These are known as <em>synthetic</em> or <em>psuedo</em> files.
    A synthetic file is a file that exists only in virtue of the kernel.
    It does not exist on a disk, and does not exist on any persistent filesystem.
  </p>

  <p>
    To explain, a running program is restricted to querying the kernel
    about files:  To read a file, it asks the kernel; to get directory
    entries, it asks the kernel; etc.
    As such, we can interject upon this&mdash; we can make it
    "look like" a file is in a directory by including it as a directory entry in
    response to an appropriate query.
    Similarly, we can make it "look like" it has contents by giving
    information back, when it's requested.
    Thus, for all intents and purposes, these files appear
    as actual files; this is a great example of a "hack."
  </p>

  <p>
    The underlying machinery involves actual filesystems&mdash; <em>sysfs</em>,
    <em>proc</em>, and <em>tmpfs</em> are each synthetic filesystems.
    We'll discuss <code>/proc</code> in more depth later.
    For now, know that there are a lot of neat tricks that you can do with this.
    For instance, swap space (which uses hard-disk space as extra RAM)
    can be invented (literally) and mounted as a filesystem.
    In addition <code>tmpfs</code> is a filesystem whose contents exists entirely on
    RAM, allowing programs to create and use temporary files which respond
    very quickly, but do not persist across reboots.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li> <a href="https://man7.org/linux/man-pages/man5/filesystems.5.html"> <code> filesystems(5)</code></a></li>
  </ul>
</div>


<div id="device-files" class="content">
  <h2>Device Special Files</h2>




  <p>
    The directory <code>/dev</code> is famous in the Unix/Linux world.
    It contains files called <em>special device files</em>,<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">[1]</a></sup>
    which <em>are not</em> regular files, and are not existent on-disk.
    Each special device file represents a device connected to the system;
    it serves as the principle reference to the device driver (and, therefore, the device).
  </p>

  <p>
    For instance, when we want to partition a drive, we pass the name of the drive
    (say, <code>/dev/sdb</code>) to a program, such as <code>fdisk</code>:
  </p>

  <div class="code">
    $ sudo fdisk /dev/sdb
  </div>

  <p>
    Note that <code>fdisk</code> is a user-space program.
    That is, the operating system has not undertaken the task of
    providing the user an interface for partitioning.
    This is an example of <em>The Unix Philosophy:</em>
    By keeping each tool in the chain small, they are each more easily maintainable, and
    we can interchange them more easily.
    Another program to do the same task is GNU's partition editor, <code>parted</code>.
  </p>

  <p>
    Among device special files, there are two distinct kinds:
    <em>block</em> and <em>character</em>.
    The distinction refers to the way that the kernel reads and writes to these files.
    Character special files are operated on a single character at a time
    (e.g., terminal screen), while block special files are operated on a block of
    bytes at a time (usually, 4096 or 8192), as in a hard drive.
  </p>

  <p>
    While there is too much going on in the <code>/dev</code> directory
    to exhaust the subject here,
    it's worth noting that utilities for displaying the current
    system's hardware often begin with <code>ls</code>:
  </p>

  <ul>
    <li><code><a href="http://man7.org/linux/man-pages/man8/lsblk.8.html">lsblk</a></code> - List block devices (hardrives, CD-drives, etc).  Useful to determine what drive to mount.</li>
    <li><code><a href="http://man7.org/linux/man-pages/man1/lscpu.1.html">lscpu</a></code> - Display information about the CPU architecture </li>
    <li><code><a href="http://man7.org/linux/man-pages/man8/lsusb.8.html">lsusb</a></code> - List usb devices </li>
    <li><code><a href="http://man7.org/linux/man-pages/man8/lspci.8.html">lspci</a></code> - List all PCI devices </li>
  </ul>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://wiki.archlinux.org/index.php/Device_file">Device File - ArchWiki</a></li>
  </ul>
</div>





  <div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>
    <h3> Filesystem vs. Directory Tree</h3>
    <p>
      The terms <em>filesystem</em> and <em>directory tree</em> were developed here
      precisely, in order to make a clear distinction between the two.
      However, the terms overlap, somewhat:
      In *nix, a (usable) filesystem must entertain exactly one directory tree.
      Because of this, each filesystem implies a directory tree;
      this is the sense in which it is valid to say, "We are going to mount
      a filesystem at <code>/home</code>," when in fact we mean,
      "We are going to mount a filesystem's directory tree at <code>/home</code>."
    </p>

    <h3>Linux Virtual File System (Kernel Subsystem)</h3>
    <p>
      The above discussion gives rise to a few questions:
    </p>

    <ol>
      <li> How can the Linux operating system support multiple filesystems? </li>
      <li> How can it do so simultaneously?  </li>
      <li> How does it handle filesystems that <em>do not</em> use inodes?</li>
    </ol>

    <p>
      The answer to each of these is the <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">
        Linux Virtual File System</a> (VFS), a kernel subsystem that acts,
        essentially, as a driver for filesystems.
        Whereas each filesystem type may implement its own functionality,
        most functionality is common;
        the Virtual Filesystem Switch provides both kernel-space threads and user-space processes with
        a uniform system call interface.
      </p>

      In Linux, the filesystems known by the current kernel are
      listed in the <code>/proc/filesystems</code> file.<sup><a href="#references">[7]</a></sup>

      <p>
        As for inodes, a more formal definition is given by kernel.org:
        "An inode object represents an object within the filesystem."<sup><a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html#id1">[10]</a></sup>
        That is, on filesystems that do not use inodes, they are imposed virtually by
        the VFS, as a means of representing files.
        As a consequence, the discussion about inodes given above remains
        at least conceptually correct, when EXT2/EXT3/EXT4 are not being employed.
      </p>
    </div>

    <div id="lvl1" class="content">
      <h2>Level-1 Linux</h2>
          <iframe class="video" src="https://www.youtube.com/embed/lsFDp-W1Ks0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    </div>

    <div id="references" class="content">
      <h2> References </h2>
      <ol>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Filesystem Hierarchy Standard Group. <a href="https://www.pathname.com/fhs/pub/fhs-2.3.pdf">The Linux Filesystem Heirarchy Standard</a>.  Retrieved May 29, 2020.</li>
        <li> Stevens, W. Richard. <i><a href="http://www.apuebook.com/apue3e.html"> Advanced Programming in the Unix Environment.</a></i> Pearson Eduction, 2013.</li>
        <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
      </ol>

    </div>
