---
layout: default
title: Files and Filesystems
last-updated: December, 2020
---

<!-- 

To Do:

Pseudofiles:
   Write subsection:
   <h3> The <code>/proc</code> Filesystem </h3>

Filesystems:
    inode as indexing method:
        https://wiki.osdev.org/File_Systems#Indexing_Methods
    
    Move following quote to Introduction to GNU/Linux:
        "Unix was well-documented (by, for instance, Maurice J. Bach in 
        <em>The Design of the Unix Operating System</em>)."

    In more detail:
        ext2:
        http://cs.smith.edu/~nhowe/262/oldlabs/ext2.html#itable

        ext4 Data Structures and Algorithms:
        https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html

Regular Files:
    Citation needed: heirarchical filestructure taken from Multics

Filesystem Heirarchy:
    XDG Directory Specification
        ~/.config is defined as part of the XDG specification
    /var: 
        (Double check:) Per-runtime variable files

        https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch05.html:
            /var contains logs, transient and temporary files
            Not shareable across systems

Device Special Files:
    Find better source to discuss "integrity" of a file/message/piece of information
    
    Round out iso-files by mounting a regular file(?)

Logical Volume Management:
    https://wiki.ubuntu.com/Lvm

-->
<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#files"> Files </a></li>
        <li><a href="#filesystems"> Filesystems </a></li>
        <li><a href="#regular-files"> Regular Files</a></li>
        <li><a href="#directories"> Directories </a></li>
        <li><a href="#pseudo"> Pseudo Files </a></li>
        <li><a href="#mounting-unmounting"> Mounting and Unmounting</a></li>
        <li><a href="#fs-heir"> Filesystem Heirarchy </a></li>
        <li><a href="#device-files"> Device Special Files </a></li>
        <li><a href="#closing-remarks"> Closing Remarks </a></li>
        <li><a href="#udacity"> Udacity </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Files and Filesystems</h1>
    <div class="quote-text">
        "Understanding is the key to success with Linux."
    </div>
    <div class="quote-ref">
        <a href="https://www.tldp.org/LDP/sag/html/intro.html">Linux System Administrator's Guide</a>
    </div>

    <p>
        The protogenesis of Unix was a filesystem.<sup><a href=#references>[1]</a><a href="http://read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf">[2]</a></sup>
        Designed by the researchers of Bell Laboratories and
        implemented primarily by Ken Thompson,
        this piece of software became an operating system upon the
        introduction of a means of interacting with its contents.
    </p>
</div>

<div id="files" class="content">
    <h2>Files</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            For each open file on the system, the kernel keeps a few C struct's
            to track them.  One of their entries is <em>file offset</em>,
            which is used to preserve order across <code>read</code>'s.
            See <a href="https://man7.org/tlpi/index.html">The Linux Programming Interface</a>
            for more detail!
        </p>
    </div>

    <p>
        In Unix, a file is a sequence of bytes.<sup><a href=#references>[1]</a></sup>
        This definition is sufficiently abstract to allow, for instance, a keyboard
        to appear as a file.
        Unix-like kernels facilitate interaction with files via four classic system calls:
    </p>

    <ol>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/open.2.html">open(2)</a></code></li>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/close.2.html">close(2)</a></code></li>
        <li><code><a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></code></li>
        <li><code><a href="https://man7.org/linux/man-pages/man2/write.2.html">write(2)</a></code></li>
    </ol>

    <p>
        In particular, the <code>read</code> system call fills a given
        buffer with the contents of a file;
        order is preserved across calls to <code>read</code>.
        When a process requests a read, the kernel suspends the process
        until data is available.
    </p>

    <p>
        In Unix-like operating systems, each file has an owner.
        Important (system) files are owned by <code>root</code>, the superuser of the system.
        Because the owner of a file is permitted to do anything to it,
        including delete it, we typically wish
        to avoid acting as <code>root</code>, and instead use <code>sudo(8)</code> wherever possible.
    </p>

    <p>
        Ken Thompson's <em>Unix</em> kernel facilitated reading and writing of files,
        but otherwise refrained from interjecting upon their use.
        This approach was quite novel for its time: Earlier
        operating systems interposed upon the handling of files, so that
        some files could only be read by some programs, and not by others.<sup><a href=#references>[1]</a></sup>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.linfo.org/unix_philosophy.html">Unix Philosophy Description</a> by The Linux Information Project (LINFO)</li>
    </ul>
</div>

<div id="filesystems" class="content">
    <h2> Filesystems </h2>

    <div class="aside-right">
        <h4>Remember:</h4>
        <p>
            A given disk may entertain more than one partition,
            but a given partition can only entertain a single filesystem.
        </p>
    </div> 

    <p>
        A <a href="https://wiki.osdev.org/File_Systems#File_System_Theory">filesystem</a> is a systematic method of organizing data on
        disk.<sup><a href="https://wiki.osdev.org/Filesystem">[3]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[4]</a></sup>
        It is similar to a data structure, in that it defines a convention
        to be followed in the storage and retrieval of data.<sup><a href="https://wiki.debian.org/Packaging/Intro">[3]</a></sup>
    </p>

    <p>
        A given disk is 
        <em><a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">partitioned</a></em> into one or more distinct components.
        All partitions are contiguous with respect to the disk's address space, and
        each entertains its own distinct filesystem, if any.
        A filesystem cannot cross partition boundaries.
        Writing a new and empty filesystem to a partition is known as
        <em><a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">formatting</a>.</em>
    </p>

    <h3>Some Common Filesystems:</h3>

    <ul>
        <li>
            <p>
                <strong>EXT4</strong>:
                Introduced in 2008,<sup><a href="https://en.wikipedia.org/wiki/Ext4">[5]</a></sup> EXT4 is
                the current standard Linux filesystem.
                It is an evolutionary enhancement on EXT3,
                supporting larger filesizes, deeper subdirectory support,
                faster handling of large files, along with <a href="https://kernelnewbies.org/Ext4">many other improvements</a>.
                It is mature, fast, and stable.
            </p>
        </li>

        <li>
            <p>
                <strong>ZFS</strong>:
                "Don't use ZFS.  It's that simple." &mdash;<a href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189841">Linus Torvalds</a>.
            </p>

            <p>
                Introduced in 2005,<sup><a href="https://en.wikipedia.org/wiki/ZFS">[6]</a></sup> ZFS incorporates fancier features that are generally
                out of place on a Linux desktop.
                It was developed by Sun Microsystems, and became closed-source with Sun's acquisition by
                Oracle.<sup><a href="https://en.wikipedia.org/wiki/ZFS#OpenZFS_and_ZFS">[6]</a></sup>
            </p>
        </li>

        <li>
            <p>
                <strong>FAT32</strong>: The "File Allcoation Table 32-bit" is a DOS-era filesystem,<sup><a href="https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32">[7]</a></sup>
                and is widely supported, though antiquated.
                In particular, it is not a <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling filesystem</a>,
                so that changes to files are not recorded before being carried out.
                This increases the likelihood of corruption in the event of, say, power outage.
                This filesystem is often used to hold the bootloader, since it is virtually guaranteed to be supported by firmware,
                and its contents will not be changed very often.
            </p>
        </li>
    </ul>


    <p>
        Early versions of Unix referred to its own filesystem as, simply, <code>fs</code>.
        It was well-documented (by, for instance, Maurice J. Bach in <em>The Design of the Unix Operating System</em>).
        The Extended Filesystem (EXT) was an open-source implementation, and 
        retained many distinctive features of the original.
        Since then, EXT2, EXT3, and EXT4 have continued to 
        improve upon the design.
    </p>

    <h3> inodes </h3>
    
    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Data about a file is known as its <em>metadata.</em>
        </p>
    </div>

    <p>
        A common feature of Unix-like filesystems is the inode:
        Each file in the filesystem is described by a single inode.
        Each inode describes where the data of the file is located, the size of the file,
        and contains other data about the file, such as access permissions and timestamps.
    </p>

    <p>
        The collection of all inodes of a filesystem is organized, conceptually, 
        into one large array; any inode may be identified by its index 
        in this array.
        These indices are called <em>inode numbers.</em>
    </p>

    <p>
        An inode number serves as the "hardware name" for a file,
        since it uniquely identifies the file within its filesystem.
        Under this scheme, all we need to do to implement filenames
        is associate a string of text with an inode number.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://wiki.osdev.org/File_Systems">File Systems</a> - OSDev Wiki</li>
        <li> <code><a href="https://man7.org/linux/man-pages/man5/filesystems.5.html"> filesystems(5)</a></code> </li>
        <li> <code><a href="https://man7.org/linux/man-pages/man7/inode.7.html">inode(7)</a></code></li>
    </ul>
</div>


<div class="content" id="regular-files">
    <h2>Regular Files</h2>

    <p>
        A regular file contains data which is stored on disk.
        Most files are regular files.
    </p>

    <p>
        Here we have a typical <code>ls(1)</code> listing:
    </p>

    <a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for printable" ></a>

    <p>
        We see that <code>bash(1)</code> is a regular file executable by anybody, but can
        only be written to by <code>root</code>.
    </p>

    <p>
        Beyond <code>ls(1)</code>, two other command-line tools useful for peeking
        into a file are <code>file(1)</code>, which gives a brief description of
        the file's type, and <code>stat(1)</code>, which gives a
        summary of the file's inode contents:
    </p>

    <div class="code">
        $ file /bin/bash<br>
        /bin/bash: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br>
        dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <br>
        BuildID[sha1]=a43fec47192ff49c2d3fed671f2be8df7e83784a, for <br>
        GNU/Linux 3.2.0, stripped<br><br>
        $ stat /bin/bash<br>
        File: /bin/bash<br>
        Size: 1183448   	Blocks: 2312       IO Block: 4096   regular file<br>
        Device: 802h/2050d	Inode: 1835042     Links: 1<br>
        Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)<br>
        Access: 2020-07-14 13:33:43.628528710 -0500<br>
        Modify: 2020-02-25 06:03:22.000000000 -0600<br>
        Change: 2020-07-09 11:20:12.676956656 -0500<br>
        Birth: -<br>
    </div>

    <p>
        We can find out more about the program it contains by querying it
        with
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            We use an absolute pathname here in order to avoid
            <a href="terminals-and-shells.html#authomatic-file-location">automatic program location</a> by the shell.
        </p>
    </div>

    <div class="code">
        $ /bin/bash --help
    </div>

    <p>
        or
    </p>

    <div class="code">
        $ /bin/bash --version
    </div>

    <p>
        This is typical of executable files, but potentially dangerous
        (we are executing that program).
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.man7.org/linux/man-pages/man1/chmod.1.html"><code>chmod(1)</code></a></li>
    </ul>
</div>

<div id="directories" class="content">
    <h2>Directories</h2>

    <p>
        A directory is a file containing a table with two columns, 
        <a href="finding-files.html#basename">basename</a> and inode number.
        Each entry in a directory is called a <em>hard link.</em>
    </p>

    <p>
        An inode number is sufficient to uniquely identify a file only within
        the filesystem the directory belongs to.
        Consequently, <em>hard links may not cross filesystem boundaries.</em>
        Another way of saying this is, "Every file belongs to the same filesystem
        as the directories which hard-link it."
    </p>

    <p>
        Every file on the system has an inode number.
        We list the contents of a directory with the usual <code>ls</code> command,
        and can list inode numbers using the <code>-i</code> switch:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            The idea of using numerical values as names 
            is common in computing.
            As we'll see later, each process is given a
            unique numerical identifier.
            Other examples include user id's and memory addresses.
        </p>
    </div>

    <div class="code">
        $ echo "hello world" &gt; newfile <br>
        $ ls -i newfile <br>
        2112949 newfile
    </div>

    <p>
        Files may be hard-linked more than once.
        This allows a file to appear in more than one directory, and/or more than once
        in a single directory.
        We can create new hard links with the <code>ln</code> ("link") command:
    </p>

    <div class="code">
        $ ln newfile 2newfile <br>
        $ ls -i newfile 2newfile <br>
        2112949 newfile <br>
        2112949 2newfile <br>
    </div>

    <p>
        The name "2newfile" is equivalent to the name
        "newfile", since they link to the same inode number.
        If we modify the file using one name,
        then we have modified the file referred to by the other:
    </p>

    <div class="code">
        $ cat 2newfile <br>
        hello world<br>
        $ echo "hello from 2newfile" > 2newfile<br>
        $ cat newfile<br>
        hello from 2newfile
    </div>

    <p>
        A question arises: <em>"What if we delete newfile?"</em>
        With the above implementation in mind, there are two distinct operations
        that must take place to delete a file: First, remove all hardlinks to the file; and,
        Second, free the file (i.e., allow its inodes and data blocks to be reused).
        Deleting hardlinks is precisely what the <code>rm</code> command does.
        Freeing the file from the filesystem is left to the kernel, and
        takes place after there are no hard links to it (and the file is not
        open by any process on the system).
    </p>

    <h3>Directory Structure</h3>

    <p>
        Although each file on the system, including directories, is owned by a user,
        the contents of directories are effectively owned by the kernel.
        No user-space process is permitted to read or write
        directly to the directories of an in-use filesystem.
    </p>

    <p>
        Instead, system calls exist to:
    </p>

    <ul style="columns: 2; width: 80%; margin-left: 10%; margin-bottom: 20px;">
        <li><a href="https://www.man7.org/linux/man-pages/man2/open.2.html">Create a new file</a></li>
        <li><a href="https://man7.org/linux/man-pages/man2/link.2.html">Create a new hardlink</a></li>
        <li><a href="https://man7.org/linux/man-pages/man2/unlink.2.html">Delete a hardlink</a></li>
        <li><a href="https://www.man7.org/linux/man-pages/man2/mkdir.2.html">Create a directory</a></li>
        <li><a href="https://www.man7.org/linux/man-pages/man2/rmdir.2.html">Remove a directory</a></li>
        <li><a href="https://www.man7.org/linux/man-pages/man2/getdents.2.html">Get directory entries</a></li>
    </ul>


    <p>
        The layer of indirection offered by these interfaces affords the kernel
        the opportunity to restrict the manipulation of directories, and thereby
        to impose structure upon the directories of a filesystem.
    </p>

    <p>
        First, directories cannot be arbitrarily hard-linked
        (i.e., you cannot create new hardlinks to existing directories).
    </p>

    <p>
        Second, each directory contains at least two hard links; 
        these cannot be changed, nor removed.
        They are, 
        <code>.</code> ("dot"), which refers to the containing directory itself,
        and <code>..</code> ("dot dot"), which refers to its parent directory.
        The root directory's parent directory is the root directory itself.
    </p>

    <p>
        Therefore, each directory has exactly one parent directory,
        and the directory structure forms a tree.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Symbolic_link#Overview"> Symbolic Link (Overview) - Wikipedia </a> </li>
    </ul>
</div>

<div class="content" id="pseudo">
    <h2>Pseudo Files</h2>

    <p>
        The GNU/Linux directory tree is used as a general-purpose meeting place.
        In addition to regular files, it also contains
        information about running processes, information about the running kernel,
        and references to hardware drivers&mdash; each in the form of files.
        This mechanism is general, extensible, and allows both users and programmers
        access to the running machine.
    </p>

    <p>
        For example, the  <code>/proc/meminfo</code> file reports statistics about
        memory usage on the system:<sup><a href="https://man7.org/linux/man-pages/man5/procfs.5.html">[25]</a></sup>
    </p>

    <div class="code">
        $ head /proc/meminfo<br>
        MemTotal:        3887988 kB<br>
        MemFree:         1619568 kB<br>
        MemAvailable:    2450268 kB<br>
        Buffers:          120152 kB<br>
        Cached:           984208 kB<br>
        SwapCached:            0 kB<br>
        Active:           324532 kB<br>
        Inactive:        1528196 kB<br>
        Active(anon):       9476 kB<br>
        Inactive(anon):  1061224 kB
    </div>

    <p>
        These are known as <em>psuedo</em> or <em>synthetic</em> files:
        A pseudo or synthetic file is a file that exists only in virtue of the kernel.
        It does not exist on disk, and does not exist on any persistent filesystem.
    </p>

    <!--

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            The intent of this website is to show that 
            the Linux kernel can do anything it damn well pleases.
        </p>
    </div>
    
    -->

    <p>
        To explain: A running program is restricted to querying the kernel
        about files.  To read a file, it must ask the kernel;
        to get directory entries, it must ask the kernel; etc.
        As such, the kernel can interject upon these system calls&mdash; 
        it can make it
        "look like" a file is in a directory by including it as a directory entry in
        response to the appropriate query, and can make 
        "look like" a file has contents by giving information back when 
        a program requests it.
    </p>

    <p>
        As a consequence of this, these files appear to be, and act as, 
        actual files, when in fact their contents are generated dynamically by the 
        kernel at runtime, and do not exist statically on any persistent filesystem.
        GNU/Linux distributions typically use two pseudofilesystems: 
        <a href="https://man7.org/linux/man-pages/man5/proc.5.html"><code>procfs</code></a>
        and 
        <a href="https://man7.org/linux/man-pages/man5/sysfs.5.html"><code>sysfs</code></a>.
    </p>

    <!--

    <h3> The <code>/proc</code> Directory </h3>

    <p>
        The <code>/proc</code> directory contains one directory for each 
        process on the system;
        these directories are organized by process ID number.
    </p>

    -->

    <h3>See Also:</h3>
    <ul>
        <li> <a href="https://www.kernel.org/doc/html/latest/filesystems/proc.html">The /proc Filesystem &ndash; The Linux Kernel documentation </a></li>
        <li> <a href="https://www.man7.org/linux/man-pages/man1/watch.1.html"> <code> watch(1) </code> </a> </li>
    </ul>
</div>

<div class="content" id="mounting-unmounting">

    <h2>Mounting and Unmounting</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            On most modern distributions, mounting is carried out automatically
            (and devices are mounted to <code>/media/[user]/</code>)
        </p>
    </div>

    <p>
        Unlike Windows systems, which create a new, distinct directory tree
        for each storage device on the system (e.g., <code>C:\, D:\</code>, etc.),
        Unix-based systems collect all filesystems into a single
        directory tree by placing any new filesystem's root directory 
        in the existing directory tree.
        This operation is called <a href="https://unix.stackexchange.com/questions/3192/what-is-meant-by-mounting-a-device-in-linux"><em>mounting</em></a>.
    </p>

        <p>
        Let's take a look at this, for it is new.
        Suppose you have a usb stick with some music on it, and you'd
        like to access its contents.
        After it's plugged in, the hardware, then the kernel,
        recognize it, but it may not be accessible:
    </p>

    <img style="width:80%" src="assets/img/mounting.png">

        <p>
        When mounting new devices manually, the usual method is to identify the device
        to be mounted with <a href="https://man7.org/linux/man-pages/man8/lsblk.8.html"><code>lsblk(8)</code></a>, then mount it via
    </p>

    <div class="code">
        $ sudo mount [DEVICE] [MOUNTPOINT]
        </div>

        <p>
        The device to be mounted should be a partition, and can usually be determined by its size and
        its mountpoint (which should be none).
        Most GNU/Linux distributions provide two places to mount temporary
        filesystems: <code>/mnt</code> and <code>/media/[user]</code>.
    </p>

    <p>
        Similarly, to unmount a filesystem, we first identify the correct
        partition with <code>lsblk</code>,
        then unmount it with <a href="https://www.man7.org/linux/man-pages/man8/umount.8.html"><code>sudo umount PATH</code></a>,
        where <code>PATH</code> is the location of the mounted filesystem.
    </p>



    <p>
        A few details:
        First, device names that appear in <code>/dev</code> or <code>lsblk</code>
        <em>are not</em> guaranteed to be stable across reboots&mdash; The devices are named in the
        order that they are found.
        Second, when mounting a new filesystem, if any files exist at the
        mount point, they will be "hidden" by the files of the new filesystem
        (they become inaccessible).
        They are not deleted, and unmounting the new filesystem will "reveal" them again.
        To avoid this, create a new directory and mount there.
        Third, a filesystem cannot be in use while unmounting; in particular,
        you must <code>cd</code> out of the device before calling <code>umount</code>.
        Finally, unmount (eject) before unplugging!
    </p>
</div>

<div id="fs-heir" class="content">
    <h2>Filesystem Heirarchy</h2>

    <p>
        Within any GNU/Linux distribution, some common themes will be found.
        For instance, <code>bin</code> directories are found in several places, such as
        <code>/bin</code> and <code>/sbin</code>, along with <code>/usr/bin</code>
        and <code>/home/[user]/bin</code>.
        These contain binary executable files (programs), such as 
        <code>bash(1)</code> and <code>ls(1)</code>; 
        they are usually associated with the shell, so
        that they may be ran as commands from the shell.
    </p>

    <div class="aside-right" style="font-size: 15px;">
        <h4>Aside:</h4>
        <p>
            The <a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux Filesystem Heirarchy Standard</a>
            describes the working GNU/Linux directory structure.  It is a "follow along" standard:
            It codifies the Linux filesystem as it commonly appears at the time of its publication,
            and does not arbitrarily impose a standard prior to implementation.
        </p>
    </div>

    <p>
        <code>/home</code> contains user's home directories.
        Per-user configuration files are contained here either as
        hidden files, or in the directory <code>~/.config</code>.
        Unix-like systems are often constructed such that the home directory is
        mounted as a separate filesystem.
        One reason to do this is that it helps prevent
        users from threatening the system by consuming all its
        storage space.
    </p>

    <p>
        The directory <code>/etc</code> (usually read "<em>et</em>-see") contains
        system-specific configuration files; you can expect to fiddle
        with the contents of this directory when configuring the system for the first time
        (or otherwise).
        It contains, for instance, files describing the configuration of the system's package
        manager, printers, and, well, etcetera.
    </p>

        <p>
        According to the standard, the system's root directory, <code>/</code>, should belong
        to a minimal filesystem that is "adequate to boot, restore recover and/or repair the system."<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html">[8]</a></sup>
        As such, <code>/bin</code>, <code>/sbin</code>, <code>/etc</code>, <code>/media</code>,
        and <code>/mnt</code> should each belong to the root filesystem.
        Moreover, critical user programs, such as <code>ls</code> and <code>bash</code>,
        are kept here, as well.
    </p>

    <p>
        The last directory we will cover is <code>/usr</code>, which contains
        files which are shareable across systems&mdash; they do not change in normal
        operation, and are not machine-specific.
        For instance, man pages are found in <code>/usr</code>, as are most user
        programs.
        This allows multiple machines to share a single <code>/usr</code>
        directory by locating it on a network,
        potentially saving large amounts of storage.<sup><a href="https://www.tldp.org/LDP/sag/html/fs-background.html">[9]</a></sup>
    </p>

    <p>
        The GNU/Linux operating system shows its multi-user/time-sharing
        heritage in the above standards:  They are well-developed to support
        the centralization of computing hardware.
        On small, single-user installations, most directories belong to
        a single filesystem.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.tldp.org/LDP/sag/html/dir-tree-overview.html">Overview of the Directory Tree: Linux System Administrator's Guide</a></li>
    </ul>
</div>

<div id="device-files" class="content">
    <h2>Device Special Files</h2>

    <p>
        A <em>device special file</em> represents a device connected to the system; 
        they reside in the <code>/dev</code> directory.<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">[10]</a></sup>
        Each of these files serves as the principle reference to a device;
        the kernel takes care of the particulars.
    </p>

    <p>
        For instance, when a usb thumb drive is inserted into my machine,
        a new device special file appears in <code>/dev</code>.
        Note that the essential capabilities of this device 
        coincide with those of a file: We can read from it and write to it.
    </p>

    <p>
        Let's consider the task of creating a boot media using this interface.
    </p>

    <p>
        I would like to install Arch Linux onto my PineBook Pro.
        I download a new installation image, and compare the resulting file
        against the original by comparing its official checksum value against
        the results of <code>sha256sum(1)</code>.
        They are identical; this means that the <a href="cacr.uwaterloo.ca/hac/about/chap1.pdf">integrity</a> of the file has been
        preserved.
    </p>

    <p>
        Next, I insert the USB stick and locate it with <code>lsblk</code>; 
        it has appeared as <code>/dev/sdb</code>, but its partitions
        have been mounted automatically. 
        These partitions must be unmounted so that the device can be written to 
        directly.
        So, I unmount its partitions, and double-check with another call to <code>lsblk</code>.
    </p>

    <p>
        With the machine in this configuration, we can write the file:
    </p>

    <div class="code">
        # cat archlinux-2020.07.02-pbp.img &gt; /dev/sdb
    </div>

    <p>
    And, success! The file <code>archlinux-2020.07.02-pbp.img</code> has been 
    perfectly copied (byte-wise) onto the first <em>n</em> bytes of the usb stick, 
    where <em>n</em> is the length of said file.
    That file, a disk image, includes a few filesystems, a kernel,
    and is bootable.
    </p>

    <p>
        Granted, <code>sudo dd</code> would have been faster and safer.
    </p>

    <h3> Putting it All Together </h3>


    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.archlinux.org/index.php/Device_file">Device File - ArchWiki</a></li>
        <li><a href="https://man7.org/linux/man-pages/man8/fdisk.8.html"><code>fdisk(8)</code></a> - manipulate disk partition table</li>
        <li><a href="https://man7.org/linux/man-pages/man8/mkfs.8.html"><code>mkfs(8)</a></code> - build a Linux filesystem</li>
    </ul>
</div>


<div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>
    <h3> Virtual File System (Kernel Subsystem)</h3>
    <p>
        The above discussion gives rise to a few questions:
    </p>

    <ol>
        <li> How can the Linux kernel support multiple filesystems? </li>
        <li> How can it do so simultaneously?  </li>
        <li> How does it handle filesystems that <em>do not</em> use inodes?</li>
    </ol>

    <p>
        The answer to each of these is the
        Virtual File System (VFS), a kernel subsystem that acts,
        essentially, as a driver for filesystems.
        While each filesystem may implement its own functionality,
        most functionality is common;
        the Virtual File System provides a uniform interface by
        implementing filesystem-related system calls, such as <code>open</code>, <code>read</code>, etc..<sup> <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">[11]</a></sup>
    </p>

    <p>
        As for inodes, a more formal definition is given by kernel.org:
        "An inode object represents an object within the filesystem."<sup><a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">[11]</a></sup>
        That is, on filesystems that do not use inodes, they are imposed virtually by
        the VFS, as a means of representing files.
        As a consequence, the discussion about inodes given here remains
        conceptually correct even when non-Unix-like filesystems are being employed.
    </p>

    <h3> Filesystem vs. Directory Tree</h3>
    <p>
        The terms <em>filesystem</em> and <em>directory tree</em> were developed here
        precisely, in order to make a clear distinction between the two.
        However, the terms overlap, somewhat:
        In Linux, each filesystem must entertain exactly one directory tree
        (specifically, it must contain exactly one root directory).
        Because of this, each filesystem implies exactly one directory tree;
        this is the sense in which it is valid to say, "We are going to mount
        a filesystem at <code>/home</code>," when in fact we mean,
        "We are going to mount a filesystem's root directory at <code>/home</code>."
    </p>

    <h3>See Also:</h3>
    <ul>
        <li> <code><a href="https://man7.org/linux/man-pages/man7/inode.7.html"> inode(7) </a></code></li>
    </ul>

</div>

<div id="udacity" class="content">
    <h2 style="margin-bottom: 2pt;">Udacity:</h2>
    <h4 style="margin-bottom: 18pt;"> Inode Structure</h4>
    <iframe class="video" src="https://www.youtube.com/embed/tMVj22EWg6A" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    <p>
        Note: This video belongs to <em>Lesson 2: File Systems</em> of <a href="https://www.udacity.com/course/gt-refresher-advanced-os--ud098">Advanced OS Refresher</a> by Georgia Tech,
        which is quick and worthwhile.
        It is monetarily free, but you must make an account.
    </p>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li>Ritchie, D. M. (1984). The Evolution of the Unix Time-sharing System. <em>AT&amp;T Bell Laboratories Technical Journal,</em> 63(6), 2nd ser., 1577-1593.</li>
        <li> File Systems. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.osdev.org/Filesystem">https://wiki.osdev.org/Filesystem</a> </li>
        <li> File systems - ArchWiki. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.archlinux.org/index.php/File_systems">https://wiki.archlinux.org/index.php/File_systems</a> </li>
        <li> Ext4 - Wikipedia. (2020, June 14). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/Ext4">https://en.wikipedia.org/wiki/Ext4</a> </li>
        <li> ZFS - Wikipedia. (2020, July 15). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/ZFS">https://en.wikipedia.org/wiki/ZFS</a></li>
        <li> File Allocation Table - Wikipedia. (2020, July 12). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/File_Allocation_Table">https://en.wikipedia.org/wiki/File_Allocation_Table</a></li>
        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). The Root Filesystem. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html</a> </li>
        <li> Wirzenius, L. (2004). Chapter 3: Overview of the Directory Tree. In <em>Linux System Administrator's Guide.</em> <a href="https://www.tldp.org/LDP/sag/html/fs-background.html">https://www.tldp.org/LDP/sag/html/fs-background.html</a></li>
        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). The Root Filesystem. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html</a></li>
        <li> Overview of the Linux Virtual File System - The Linux Kernel Documentation. (n.d.). Retrieved July 17, 2020, from <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">https://www.kernel.org/doc/html/latest/filesystems/vfs.html</a> </li>
    </ol>

</div>

