---
layout: default
title: Files and Filesystems
last-updated: December, 2020
---

<!-- 

To Do:
    ls listing picture:
        Simplify b and c to 'device files'

    Filesystems:
    zfs:
        https://docs.freebsd.org/en/books/handbook/zfs/
        - Data integrity: a checksum is calculated and stored alongside
          each file
            - "self healing"
        - "more than just a file system"
        - Incorporates volume management:
            - Pools are constructed of disks
        - Pools can be grown dynamically (by assigning new disks to it)
        - Native filesystem snapshot support


    tfs:
        A very ambitious, next-generation filesystem.
        Aims to usurp the journaling with so-called "guaranteed atomicity."
        If they pull off their goals, it will be the first
        "smart" filesystem.
        https://gitlab.redox-os.org/redox-os/tfs

       <code>$ df - -print-type</code>

    btrfs:
        https://btrfs.wiki.kernel.org/index.php/Main_Page

    xfs:


    <p>
        Inode numbers can uniquely identify a file only within a single
        filesystem.
        Consequently, <em>Hard links may not cross filesystem boundaries.</em>
        Another way of saying this is, "Every file belongs to the same filesystem
        as the directories which hard link it."
    </p>


Introduction:
    Everything is a file
    Unix-like operating systems are typified by a single directory tree.

Pseudofiles:
   Write subsection:
   <h3> The <code>/proc</code> Filesystem </h3>

Device Special Files:
    Kerrisk 14.1

    Find better source to discuss "integrity" of a file/message/piece of information

    Round out iso-files by mounting a regular file
    
    Neat use of 'file' command:

    $pinebookpro-debian-desktop-mrfixit191226.img
    pinebookpro-debian-desktop-mrfixit191226.img: DOS/MBR boot sector; partition 1 : ID=0xc, active, start-CHS (0x2,10,9), end-CHS (0xa,50,40), startsector 32768, 131072 sectors; partition 2 : ID=0x83, active, start-CHS (0x10,81,2), end-CHS (0x28d,185,44), startsector 262144, 10240000 sectors

Logical Volume Management:
    https://wiki.ubuntu.com/Lvm



Filesystems:
    inode as indexing method:
        https://wiki.osdev.org/File_Systems#Indexing_Methods
    
    Move following quote to Introduction to GNU/Linux:
        "Unix was well-documented (by, for instance, Maurice J. Bach in 
        <em>The Design of the Unix Operating System</em>)."

    In more detail:
        ext2:
        http://cs.smith.edu/~nhowe/262/oldlabs/ext2.html#itable

        ext4 Data Structures and Algorithms:
        https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html

Regular Files:
    Citation needed: heirarchical filestructure taken from Multics

Filesystem Heirarchy:
    XDG Directory Specification
        ~/.config is defined as part of the XDG specification
    /var: 
        (Double check:) Per-runtime variable files

        https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch05.html:
            /var contains logs, transient and temporary files
            Not shareable across systems


 <h4> Exercises: </h4>
    <ol class="big-list">
        <li> From the command line, create a new and empty directory.  
            What does it contain? (It is not empty.)
            To what files do its entries point?</li>
    </ol>


-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#files"> Files </a></li>
        <li><a href="#regular-files"> Regular Files</a></li>
        <li><a href="#synthetic-files"> Synthetic Files </a></li>
        <li><a href="#device-files"> Device Files </a></li>
        <li><a href="#fs-heir"> Filesystem Heirarchy </a></li>
        <li><a href="#mounting-unmounting"> Mounting and Unmounting</a></li>
        <li><a href="#filesystems"> Filesystems </a></li>
        <li><a href="#directories"> Directories </a></li>
        <li><a href="#closing-remarks"> Closing Remarks </a></li>
        <li><a href="#udacity"> Udacity </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Files and Filesystems</h1>
    <div class="quote-text">
        "Understanding is the key to success with Linux."
    </div>
    <div class="quote-ref">
        <a href="https://www.tldp.org/LDP/sag/html/intro.html">Linux System Administrator's Guide</a>
    </div>

    <p>
        The protogenesis of Unix was a filesystem.<sup><a href=#references>[1]</a><a href="http://read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf">[2]</a></sup>
        Designed by the researchers of Bell Laboratories and
        implemented primarily by Ken Thompson,
        this piece of software became an operating system with the
        introduction of a means of interacting with, and executing, its contents.
    </p>
</div>

<div id="files" class="content">
    <h2>Files</h2>

    <p>
        In Unix, a file is a sequence of bytes.<sup><a href=#references>[1]</a></sup>
        This definition is sufficiently abstract to allow, for instance, a keyboard
        to appear as a file.
        Unix-like kernels facilitate interaction with files via four classic 
        system calls:
    </p>

    <ol>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/open.2.html">open(2)</a></code></li>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/close.2.html">close(2)</a></code></li>
        <li><code><a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></code></li>
        <li><code><a href="https://man7.org/linux/man-pages/man2/write.2.html">write(2)</a></code></li>
    </ol>

    <p>
        In particular, the <code>read</code> system call fills a given
        buffer with the contents of a file;
        order is preserved across calls to <code>read</code>.
        When a program requests a read, the kernel suspends its execution 
        until data is available.
    </p>

    <h3>File Attributes</h3>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Oddly, this information does not include the file's name.
            More on this below.
        </p>
    </div>

    <p>
        Unix-like operating systems store a substantial amount of information
        about each file on the system.
        This information, known as <em>file metadata,</em> is stored on-disk, 
        alongside the file.
    </p>

    <p>
        Metadata includes:
    </li>

    <ul>
        <li>File Type</li>
        <li>Owner</li>
        <li>Group</li>
        <li>Read/Write/Execute Permissions</li>
        <li>Size</li>
        <li>Timestamps</li>
    </ul>

    <p>
        This information can be explained in part by the UNIX idiom of
        making everything available in the form of a file, 
        and in part by its time-sharing heritage.
    </p>

    <p>
        Ken Thompson's <em>Unix</em> kernel facilitated reading and writing of 
        files, but otherwise refrained from interjecting upon their use.
        This approach was quite novel for its time: Earlier
        operating systems interposed upon the handling of files, so that
        some files could only be read by some programs, and not by others.<sup><a href=#references>[1]</a></sup>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.linfo.org/unix_philosophy.html">Unix Philosophy Description</a> by The Linux Information Project (LINFO)</li>
    </ul>
</div>

<div class="content" id="regular-files">
    <h2>Regular Files</h2>

    <p>
        A regular file contains data which is stored on disk.
        Most files are regular files. 
    </p>

    <p>
        Here we have a typical <code>ls(1)</code> listing:
    </p>

    <a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for printable" ></a>
    <center style="font-size:12pt;">Click for printable PDF</center>

    <p>
        The first character, a hyphen (<code>-</code>), tells us that 
        <code>/bin/bash</code> is a regular file. 
        The next nine characters are the file's 
        <a href="http://linfo.org/permissions.html">permission bits</a>;
        the <code>r</code> and <code>x</code> present in each set indicates 
        that this file is readable and executable (respectively) by any user on 
        the system.
        The <code>w</code> present only in the owner set indicates that the
        file may only be written to by its owner, who in this case 
        is <code>root</code>.
    </p>

    <p>
        Two other tools useful for peeking
        into a file are <code><a href="https://www.man7.org/linux/man-pages/man1/file.1.html">file(1)</a></code>, and  
        <code><a href="https://man7.org/linux/man-pages/man1/stat.1.html">stat(1)</a></code>:
    </p>

    <div class="code">
        $ file /bin/bash<br>
        /bin/bash: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br>
        dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <br>
        BuildID[sha1]=a43fec47192ff49c2d3fed671f2be8df7e83784a, for <br>
        GNU/Linux 3.2.0, stripped<br><br>
        $ stat /bin/bash<br>
        File: /bin/bash<br>
        Size: 1183448   	Blocks: 2312       IO Block: 4096   regular file<br>
        Device: 802h/2050d	Inode: 1835042     Links: 1<br>
        Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)<br>
        Access: 2020-07-14 13:33:43.628528710 -0500<br>
        Modify: 2020-02-25 06:03:22.000000000 -0600<br>
        Change: 2020-07-09 11:20:12.676956656 -0500<br>
        Birth: -<br>
    </div>

    <p>
        To simply view the contents of a file, we can use the <code>less(1)</code>
        paging utility, which displays one screenful of the file at a time:
    </p>

    <div class="code">
        $ less hello.c
    </div>

    <p>
        As an exercise, go to the <code>/boot</code> directory and look around!
    </p>


    <h3>See Also:</h3>
    <ul>
    </ul>
</div>

<div class="content" id="synthetic-files">
    <h2>Synthetic Files</h2>

    <p>
        The GNU/Linux directory tree is used as a general-purpose meeting place.
        In addition to regular files, it also contains
        information about running processes, information about the running kernel,
        and references to hardware&mdash; each in the form of files.
        This mechanism is general, extensible, and allows both users and programmers
        access to the running machine.
    </p>

    <p>
        For example, the  <code>/proc/meminfo</code> file reports current
        memory usage of the system:
    </p>

    <div class="code">
        $ head /proc/meminfo<br>
        MemTotal:        3887988 kB<br>
        MemFree:         1619568 kB<br>
        MemAvailable:    2450268 kB<br>
        Buffers:          120152 kB<br>
        Cached:           984208 kB<br>
        SwapCached:            0 kB<br>
        Active:           324532 kB<br>
        Inactive:        1528196 kB<br>
        Active(anon):       9476 kB<br>
        Inactive(anon):  1061224 kB
    </div>

    <p>
        This is an example of a <em>synthetic</em> or <em>psuedo</em> file.
        These exist only in virtue of the running kernel. 
        It does not exist on disk, and does not exist on any persistent filesystem.
        The output printed was the kernel's response to the
        <code>read(2)</code> system call.
    </p>

    <p>
        The <code>/proc</code> and <code>/sys</code> directories are
        dedicated to pseudo-files.  
        Of these, we will discuss only <code><a href="https://man7.org/linux/man-pages/man5/proc.5.html">/proc</a></code> in any detail.
        It contains one directory for each running program on the system,
        and each directory contains substantial information about its
        respective process.
    </p>

    <!--

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            The intent of this website is to show that 
            the Linux kernel can do anything it damn well pleases.
        </p>
    </div>
    
    <h3> The <code>/proc</code> Directory </h3>

    <p>
        The <code>/proc</code> directory contains one directory for each 
        process on the system;
        these directories are organized by process ID number.
    </p>

    -->

    <h3>See Also:</h3>
    <ul>
        <li> <a href="https://www.kernel.org/doc/html/latest/filesystems/proc.html">The /proc Filesystem &ndash; The Linux Kernel documentation </a></li>
    </ul>
</div>

<div id="device-files" class="content">
    <h2>Device Files</h2>

    <p>
        A <em>device file</em> represents a device connected to the system; 
        they reside in the <code>/dev</code> directory.<sup><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">[10]</a></sup>
        Each of these files serves as the principle reference to its
        respective device.
    </p>

    <p>
        For instance, when a USB-stick is inserted into my laptop,
        a new file appears in <code>/dev</code>.
        It is interesting to note that the essential capabilities of this device 
        coincide with those of a file: We can read from it and write to it.
    </p>

    <p>
        Let's consider the task of creating a boot media using this interface.
    </p>

    <p>
        I would like to install Arch Linux onto my PineBook Pro.
        I download a new installation image, and compare the resulting file
        against the original by comparing its official checksum value against
        the results of <code>sha256sum(1)</code>.
        They are identical; this means that the <a href="cacr.uwaterloo.ca/hac/about/chap1.pdf">integrity</a> of the file has been
        preserved.
    </p>

    <p>
        Next, I insert the micro-SD and locate it with <code>lsblk</code>.
        It has appeared as <code>/dev/mmcblk1</code>, and its partitions
        have not been mounted, so we are ready to write the file:
    </p>

    <div class="code">
        # cat archlinux-2020.07.02-pbp.img &gt; /dev/mmcblk1
    </div>

    <p>
        And, success! 
        The file <code>archlinux-2020.07.02-pbp.img</code> has been 
        copied (byte-wise perfectly) onto the first <em>n</em> bytes of the 
        card, 
        where <em>n</em> is the length of said file.
        That file, a disk image, includes a few filesystems, a kernel,
        and is bootable.
    </p>

    <p>
        Granted, <code>sudo dd</code> would have been faster and safer.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.archlinux.org/index.php/Device_file">Device File - ArchWiki</a></li>
    </ul>
</div>


<div id="fs-heir" class="content">
    <h2>Filesystem Heirarchy</h2>

    <p>
        Within any GNU/Linux distribution, some common themes will be found.
        For instance, <code>bin</code> directories are found in several places, such as
        <code>/bin</code>, <code>/sbin</code>, along with <code>/usr/bin</code>
        and often <code>/home/[user]/bin</code> as well.
        These contain binary executable files&ndash; programs&ndash; such as 
        <code>bash</code> and <code>ls</code>. 
        Other standard directories include <code>/root</code>, the root user's home
        directory, and <code>/proc</code>, and <code>/dev</code> as
        mentioned above.
        Some of these have been standard since Unix's inception,
        while others have become standard in more recent decades.
    </p>

    <div class="aside-right" style="font-size: 15px;">
        <h4>Aside:</h4>
        <p>
            The <a href="https://refspecs.linuxfoundation.org/fhs.shtml">Linux Filesystem Heirarchy Standard</a>
            describes the GNU/Linux directory structure.  
            It is a "follow along" standard:
            It codifies the Linux filesystem as it commonly appears at the 
            time of its publication, and does not arbitrarily impose a 
            standard prior to implementation.
        </p>
    </div>

    <p>
        Let's begin at the top.
        Each Unix-like operating system has a single directory, <code>/</code>,
        which is the root of the system's directory tree.
        This is referred to as the <em>root directory</em> (not to be 
        confused with <em>root user's home directory</em>). 
        Every file in a Unix-like operating system may be addressed in absolute
        terms by giving its location relative to the root directory.
    </p>

    <p>
        <code>/home</code> contains users' home directories. 
        As user <em>josh</em>, my home directory is <code>/home/josh</code>.
        This path is commonly abbreviated to <code>~</code>.
        By default, it contains the usual "Music", "Movies", "Pictures" and 
        "Downloads", but of course you are the owner.  
        Per-user configuration files are also stored here, either as
        hidden files or in the directory <code>~/.config</code>.
    </p>

    <p>
        The directory <code>/etc</code> contains
        system-specific configuration files; you can expect to fiddle
        with the contents of this directory when configuring the system for the 
        first time (or otherwise).
        It contains, for instance, files describing the configuration of 
        the system's package manager, X11 window system configuration, 
        and, well, etcetera.
    </p>

    <p>
        <code>/run</code>, <code>/tmp</code>, and <code>/var</code> each hold
        transient files of running programs.  
        <code>/boot</code> holds everything required for the boot sequence,
        including my very own Linux kernel:
    </p>

    <div class="code">
        $ file /boot/Image<br>
        Image:&emsp;&emsp; Linux kernel ARM64 boot executable Image, little-endian, 4k pages
    </div>

    <p>
        Software libraries are kind of boring, but essential to modern systems.
        The basic idea is to factor out repeated code (for instance, 
        C's <code>printf</code> function) not just from the source code, but
        from the <em>executable</em> file as well.  
        This means that, when a bug or security vulnerability is found in 
        <code>printf</code>, any program that uses the function will not
        have to be recompiled; rather, the appropriate library can be adjusted,
        and all dependant programs can continue operation in blissful ignorance
        of the change. 
        Such executable files are said to be <em>dynamically linked,</em> 
        and cannot be expected to run properly without their dependencies.
        <code>/lib</code> holds libraries. 
    </p>

    <p>
        The last directory we will look at is <code>/usr</code>, which 
        is more interesting. It contains user-shared files, such as 
        man pages (in <code>/usr/share/man</code>) and most of the system's
        programs (in <code>/usr/bin</code>).
        These files are used by all system users, and the 
        Linux Filesystem Heirarchy Standard mentioned
        above intends to guarantee that this  
        directory can be read-only and shared across systems via network.
    </p>

    <!--

    <h3>The Birds and the Bees</h3>

    <div class="aside-left">
        <h4>Aside:</h4>
        <p>
            It's all fun and games until someone deletes <em>initramfs</em>
        </p>
    </div>

    <p>
        The Unix architecture is designed with the experienced
        user in mind.
        the architecture is well-suited to advanced configuration by
        experienced users.
        Thereby, the root user <em>transcends</em> the access permission
        scheme of the Unix environment.
    </p>

    <p>
        <em>Some</em> users are granted administrative <em>priveledges</em> 
        over the system, and can use them <em>safely</em> through 
        <code>sudo</code> (superuser do).
    </p>

    -->

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://linfo.org/root.html">What is root?</a> -- definition by the Linux Information Project (LINFO)</li>
    </ul>
</div>

<div class="content" id="mounting-unmounting">

    <h2>Mounting and Unmounting</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            On modern distributions, mounting is often carried out automatically.
        </p>
    </div>

    <p>
        Unlike Windows systems, which create a new, distinct directory tree
        for each storage device on the system (e.g., <code>C:\, D:\</code>, etc.),
        Unix-like operating systems maintain a single, unique directory tree.
        When a new device is introduced to the machine, its files are made 
        available by placing the new filesystem's root directory 
        in the existing directory tree,
        in an operation is called <a href="https://unix.stackexchange.com/questions/3192/what-is-meant-by-mounting-a-device-in-linux"><em>mounting</em></a>.
    </p>

    <p>
        Let's take a look at this, for it is new.
    </p>

    <p>
        Suppose we have a usb stick with some music on it, and we'd
        like to access its contents.
        When we plug it in, the hardware, then the kernel,
        recognize it, but it may not be accessible:
    </p>

    <img style="width:80%" src="assets/img/mounting.png">

    <p>
        The Linux Filesystem Heirarchy Standard provides two places to mount 
        temporary filesystems: <code>/mnt</code> and <code>/media/[user]</code>.
        When mounting new devices manually, the usual method is to identify the 
        device to be mounted with 
        <a href="https://man7.org/linux/man-pages/man8/lsblk.8.html"><code>lsblk(8)</code></a>, 
        then mount it via
    </p>

    <div class="code">
        $ sudo mount [DEVICE] [MOUNTPOINT]
    </div>

    <p>
        Superuser priveledges allow us to mount a filesystem anywhere.  
        When a new filesystem is mounted in a directory that is not empty,
        its contents become "hidden" by the new filesystem, and are 
        inaccessible while the filesystem is mounted.  
        They will not be damaged or destroyed, and will "reappear" when 
        the filesystem is unmounted.
        This could be handy to, say, keep your <code>home</code> directory
        on a thumb-drive.
    </p>
            
    <p>
        The device to be mounted should be a partition, and can usually be 
        determined by its size and its mountpoint (which should be none).
    </p>

    <p>
        Devices should be unmounted before being removed; this operation is
        encapsulated in the "eject" operation.
        To unmount a device manually, we again assert the correct device 
        with <code>lsblk</code>,
        then unmount it with 
        <a href="https://www.man7.org/linux/man-pages/man8/umount.8.html"><code>sudo umount PATH</code></a>,
        where <code>PATH</code> is the location of the mounted filesystem.
    </p>
</div>

<div id="filesystems" class="content">
    <h2> Filesystems </h2>

    <p>
        A <a href="https://wiki.osdev.org/File_Systems#File_System_Theory">filesystem</a> is a systematic method of organizing data on
        disk.<sup><a href="https://wiki.osdev.org/Filesystem">[3]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[4]</a></sup>
        It is similar to a data structure, in that it defines a convention
        to be followed in the storage and retrieval of data.
    </p>

   
    <p>
        Early versions of Unix referred to its own filesystem as, 
        simply, <code>fs</code>.
        It was well-documented (by, for instance, Maurice J. Bach in 
        <em>The Design of the Unix Operating System</em>).
        The Extended Filesystem (EXT) was an open-source extension, and 
        retained many distinctive features of the original.
        Since then, EXT2, EXT3, and EXT4 have continued to 
        improve upon the design.
    </p>

    <h3>Some Common Filesystems:</h3>

    <ul>
        <li>
            <p>
            <a href="https://ext4.wiki.kernel.org/index.php/Main_Page"><strong>EXT4</strong></a>:
                Introduced in 2008, EXT4 is the current standard Linux filesystem.
                It is an evolutionary enhancement on EXT3,
                supporting larger filesizes, deeper subdirectory support,
                faster handling of large files, along with <a href="https://kernelnewbies.org/Ext4">many other improvements</a>.
                It is mature, fast, and stable.
            </p>
        </li>

        <li>
            <p>
                <strong>FAT32</strong>: The "File Allcoation Table 32-bit" is a DOS-era filesystem,<sup><a href="https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32">[7]</a></sup>
                and is widely supported,<sup><a href="https://wiki.osdev.org/File_Systems#.22Beginners.22_filesystems">[a]</a></sup> though antiquated.
                In particular, it is not a <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling filesystem</a>,
                so that changes to files are not recorded before being carried out.
                This increases the likelihood of corruption in the event of, 
                say, power outage.
                This filesystem is often used to hold the bootloader, since it 
                is virtually guaranteed to be supported,
                and its contents will not be changed very often.
            </p>
        </li>
    </ul>

    <p>
        To use a particular filesystem, a given disk is first
        <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">partitioned</a> into one or more 
        distinct components.
        A new and empty filesystem may then be written to the partition,
        in an operation known as 
        <em><a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">formatting</a>.</em>
        Partitions are contiguous with respect to the disk's address space,
        and filesystems cannot cross partition boundaries.
    </p>

    <h3> inodes &amp; inode numbers</h3>
    
    <p>
        A common feature of Unix-like filesystems is the 
        <a href="https://wiki.osdev.org/File_Systems#Indexing_Methods">inode</a>:
        Each file is described by a single inode.
        An inode tells where the file's data is stored on-disk, 
        and also contains the file's metadata. 
    </p>

    <p>
        The filesystem's collection of inodes is organized  
        into one large array; any inode, and therefore any file,
        may be uniquely identified by its index in this array.
        These indices are called <em>inode numbers,</em>
        and are the principle (low-level) references to files.
        Under this scheme, all we must do in order to implement filenames
        is associate a string of text with an inode number.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li> <code><a href="https://man7.org/linux/man-pages/man7/inode.7.html"> inode(7) </a></code></li>
    </ul>
</div>

<div id="directories" class="content">
    <h2>Directories</h2>

    <p>
        A directory is, conceptually, a file containing a table with two columns: 
        <a href="finding-files.html#basename">Basename</a> and <a href="https://man7.org/linux/man-pages/man7/inode.7.html">inode number</a>.
        Directories are maintained by the kernel, and are not directly
        readable nor writeable by processes (specific system calls exist
        to interact with directories).
    </p>

    <p>
        We can list inode numbers with <code>ls -i</code>:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            By convention alone, filenames which begin with a 
            period <code>.</code> are considered hidden, 
            including <code>.</code> and <code>..</code>.
        </p>
    </div>

    <div class="code">
        $ ls -ia ~/Public/Learning-Linux <br>
        645278 ./<br>
        384844 ../<br>
        775487 assets/<br>
        641473 command-line-1-tutorial-introduction.html<br>
        645403 _config.yml<br>
        775449 _data/<br>
        642188 documentation.html<br>
        642185 files-and-filesystems.html<br>
        641460 finding-files.html<br>
        775463 _future/<br>
        645377 .git/<br>
        645401 .gitignore<br>
        775479 _includes/<br>
        641295 index.html<br>
        642186 intro-to-gnu-linux.html<br>
        777671 .jekyll-cache/<br>
        775483 _layouts/<br>
        641300 package-management.html<br>
        641293 processes.html<br>
        642193 programming-in-nix.html<br>
        641472 README.md<br>
        775485 _sass/<br>
        898840 _site/<br>
        642693 systemd.html<br>
        641291 terminals-and-shells.html<br>
    </div>

    <p>
        Each entry in a directory is called a <em>hard link.</em>
        A file may have more than one hard link, but when it has zero,
        it is no longer accessible through the directory structure, and
        the kernel will prepare to delete it.
    </p>
   
    <p>
        We can create new hard links with the <code>ln</code> "link" command,
        as the following sequence demonstrates:
    </p>

    <div class="code">
        $ echo "hello world" &gt; newfile <br>
        $ ls -i newfile <br>
        2112949 newfile <br>
        $ ln newfile 2file <br>
        $ ls -i newfile 2file <br>
        2112949 newfile <br>
        2112949 2file <br>
    </div>

    <p>
        The name "2file" is equivalent to the name
        "newfile", since they link to the same file.
        If we modify the file using one name,
        then we have modified the file referred to by the other:
    </p>

    <div class="code">
        $ echo "hello from 2file" &gt; 2file<br>
        $ cat newfile<br>
        hello from 2file
    </div>

    <p>
        They are simply different names for the same file.
        <code>ls --long</code> lists the number of hard links to a given file 
        (see above). 
    </p>

   
    <h3> See Also: </h3>
    <ul>
        <li><a href="http://linfo.org/hard_link.html">What is a hard link?</a> -- definition by The Linux Information Project (LINFO)</li>
        <li><a href="https://en.wikipedia.org/wiki/Symbolic_link#Overview"> Symbolic Link (Overview) - Wikipedia </a> </li>
    </ul>
</div>

<div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>
    <h3> Virtual File System (Kernel Subsystem)</h3>
    <p>
        The above discussion gives rise to a few questions:
    </p>

    <ol>
        <li> How can the Linux kernel support multiple filesystems? </li>
        <li> How can it do so simultaneously?  </li>
        <li> How does it handle filesystems that <em>do not</em> use inodes?</li>
    </ol>

    <p>
        The answer to each of these is the
        Virtual File System (VFS), a kernel subsystem that acts,
        essentially, as a driver for filesystems.
        While each filesystem may implement its own functionality,
        most functionality is common;
        the Virtual File System provides a uniform interface by
        implementing filesystem-related system calls, such as <code>open</code>, <code>read</code>, etc..<sup> <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">[11]</a></sup>
    </p>

    <p>
        As for inodes, a more formal definition is given by kernel.org:
        "An inode object represents an object within the filesystem."<sup><a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">[11]</a></sup>
        That is, on filesystems that do not use inodes, they are imposed virtually by
        the VFS, as a means of representing files.
        As a consequence, the discussion about inodes given here remains
        conceptually correct even when non-Unix-like filesystems are being employed.
    </p>

    <h3> Filesystem vs. Directory Tree</h3>
    <p>
        The terms <em>filesystem</em> and <em>directory tree</em> were developed 
        precisely, in order to make a clear distinction between the two.
        However, the terms overlap, somewhat:
        In Linux, each filesystem must entertain exactly one directory tree
        (specifically, it must contain exactly one root directory).
        Because of this, each filesystem implies exactly one directory tree.
        This is the sense in which it is valid to say, "We are going to mount
        the filesystem at <code>/home</code>," when in fact we mean,
        "We are going to mount the filesystem's root directory at <code>/home</code>."
    </p>

    <h3>See Also:</h3>
    <ul>
        <li> <code><a href="https://man7.org/linux/man-pages/man5/filesystems.5.html"> filesystems(5)</a></code> </li>
    </ul>

</div>

<div id="udacity" class="content">
    <h2 style="margin-bottom: 2pt;">Udacity:</h2>
    <h4 style="margin-bottom: 18pt;"> Inode Structure</h4>
    <iframe class="video" src="https://www.youtube.com/embed/tMVj22EWg6A" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    <p>
        Note: This video belongs to <em>Lesson 2: File Systems</em> of <a href="https://www.udacity.com/course/gt-refresher-advanced-os--ud098">Advanced OS Refresher</a> by Georgia Tech,
        which is quick and worthwhile.
        It is monetarily free, but you must make an account.
    </p>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li>Ritchie, D. M. (1984). The Evolution of the Unix Time-sharing System. <em>AT&amp;T Bell Laboratories Technical Journal,</em> 63(6), 2nd ser., 1577-1593.</li>
        <li> File Systems. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.osdev.org/Filesystem">https://wiki.osdev.org/Filesystem</a> </li>
        <li> File systems - ArchWiki. (n.d.). Retrieved July 17, 2020, from <a href="https://wiki.archlinux.org/index.php/File_systems">https://wiki.archlinux.org/index.php/File_systems</a> </li>
        <li> Ext4 - Wikipedia. (2020, June 14). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/Ext4">https://en.wikipedia.org/wiki/Ext4</a> </li>
        <li> ZFS - Wikipedia. (2020, July 15). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/ZFS">https://en.wikipedia.org/wiki/ZFS</a></li>
        <li> File Allocation Table - Wikipedia. (2020, July 12). Retrieved July 17, 2020, from <a href="https://en.wikipedia.org/wiki/File_Allocation_Table">https://en.wikipedia.org/wiki/File_Allocation_Table</a></li>
        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). The Root Filesystem. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03.html</a> </li>
        <li> Wirzenius, L. (2004). Chapter 3: Overview of the Directory Tree. In <em>Linux System Administrator's Guide.</em> <a href="https://www.tldp.org/LDP/sag/html/fs-background.html">https://www.tldp.org/LDP/sag/html/fs-background.html</a></li>
        <li> LSB Workgroup, The Linux Foundation. (2015, March 9). The Root Filesystem. Retrieved July 17, 2020, from <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s06.html</a></li>
        <li> Overview of the Linux Virtual File System - The Linux Kernel Documentation. (n.d.). Retrieved July 17, 2020, from <a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">https://www.kernel.org/doc/html/latest/filesystems/vfs.html</a> </li>
    </ol>

</div>

