---
layout: default
title: Packages and Distributions
last-updated: March 2021
---

<!--

    Introduction:
        It's more accurate to view a "distribution" as a collection
        of precompiled and preconfigured packages, (which depend upon
        some configuration) than as an operating system.

        Packages and package management are typically handled by a utility program,
        and the ordinary user would not have much need to delve into package
        specifics.
        Nonetheless, they are an important
        step in the attainment of a free working operating system.


    Define 'repository' as a tracked collection of files, and note that they
    usually contain a package.

    https://wiki.gentoo.org/wiki/Handbook:AMD64/Full/Installation
    - Choice and openness are primary concerns within Gentoo;
    - The installation process is markedly similar to Linux From Scratch.
    - Gentoo scripts are written in Python

<div class="content" id="binary-packages">

Package Contents: Metadata and Payload
        Rewrite to use Arch Linux's packaging as example

    The contents of a package may be split into two
        parts: Metadata and Payload.
        In Slackware's format, metadata is restricted to the <code>./install</code>
        directory, and consists of the post-copy script <code>doinst.sh</code>
        and a description of the software, <code>slack-desc</code>.
        Other package management schemes incorporate more metadata; here
        we'll take a look at Arch's, since it is more complete.
    </p>

    <p>
        First, we obtain a package and extract it:
    </p>

<div class="code">o.
        $ ls
        vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ tar xf vim-8.2.2489-1-aarch64.pkg.tar.xz &amp;&amp; rm vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ ls -A
        .BUILDINFO  .MTREE  .PKGINFO  usr/
</div>


<p>
        The package's metadata are the hidden files in this directory:
        <code>.BUILDINFO</code>, <code>.MTREE</code>, <code>.PKGINFO</code>.
        The package's payload consists of the non-hidden files
        (in this case, that is only <code>usr/</code>).
        Not present in this package is the <code>.INSTALL</code> file,
        an optional script which would be executed by the package manager.
</p>


Package managers:
    <div class="code">
        sudo apt install ./atom-amd64.deb
    </div>

    <p>
        That's it. There's nothing more to it.
    </p>

    Expressing the Operating System:
        Arch: base

        The system may be viewed as a collection of installed packages,
        and, the package manager could be viewed as a manager of the
        operating system.


        This is how the Arch guys view packages: The system is viewed
        as a repository, and when new software is released, the local
        repository becomes out of sync with the upstream repository.
        "Upgrading" becomes a matter of synchronizing these repositories.

        Thus, the software that composes a system defines the
        operating system, and,

    Repositories:
        Subsection?


        Some people think that rolling releases are
        the future of Linux distributions
        <sup><a href="https://frontpagelinux.com/news/centos-crosses-streams-with-the-community/">[1]</a></sup>

        Debian Personal Package Archive
        https://itsfoss.com/ppa-guide/
        Arch User's Repository, AUR


    Rolling Releases:

    https://wiki.archlinux.org/index.php/Meta_package_and_package_group

<h2>Package Groups and Metapackages</h2>
<p>
        A package that contains nothing but dependencies.
        When "installed", the effect is to install a group of packages.
</p>


Debian-specific virtual package: A faux target, only realized by other,
actual packages.

A section from the Linux Mint User Guide (old)
https://www.linuxmint.com/documentation/user-guide/Cinnamon/english_18.0.pdf

Debian Recommends vs. Suggests ("Declaring relationships between packages")
https://www.debian.org/doc/debian-policy/ch-relationships.html

Other Package Managers:
    PIP:
    Cargo:

        Cross-platform packages:
                Great in theory, horrific in practice (See Torvald's quote).
    Snap
    Zero Install
    https://blog.linuxmint.com/?p=3766 (Critique of Snap)
    https://blog.linuxmint.com/?p=3906 (Chromium empty package) "In Linux Mint 20, APT will forbid snapd from getting installed.""
    From https://linuxmint-user-guide.readthedocs.io/en/latest/snap.html
           "The Snap Store, also known as the Ubuntu Store, is a commercial centralized software store operated by Canonical."
           Snap is unique in that it solves a problem that didn't actually exist:



    The UNIX Way:
        The <em>really</em> old guys, with <em>really</em> long beards
        just distribute source. a la Free BSD's <em>ports</em>
        Also, gentoo does takes this approach as-well.


Closing Remarks:

    https://docs.freebsd.org/en/books/handbook/ports/#ports-using
    Package Benefits

            Thanks for reading!
                Ecosystem
            Where to go from here?
                Install Ubuntu
                The Linux Command Line
                Arch Linux or Linux From Scratch

    Like if you looked at computing from outer space:
    https://tomaka.medium.com/the-future-of-operating-systems-efa31e17d66d

    <div id="introduction" class="content">
    <h1>Packages</h1>
    <p>
        In the author's opinion, Free Software works because
        people want to do it.
    </p>

    <p>
        Good ideas tend to resurface.
        Free software is in no danger of <em>being forgotten</em> because it is
        one such idea.
        The UNIX architecture similarly resurfaces.
    </p>


        Typically, package are presented to the user in precompiled form,
        and installed by a utility program.

        <p>
            Github offers services for creating your own repository,
            and forking those of others.
        </p>

    <p>
        Known-good ideas:
            Dynamic Linking
        Known-bad ideas:
            Static Linking!
    </p>
</div>

<p>
    For instance, it is common (though fading) practice for
    distributions to offer a new release every six months.
</p>

-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#open-source"> Open Source</a></li>
        <li><a href="#building-from-source">Building an OS from Source</a></li>
        <li><a href="#binary-packages">Binary Packages</a></li>
        <li><a href="#dependencies">Dependencies</a></li>
        <li><a href="#package-managers">Package Managers</a></li>
        <li><a href="#closing-remarks">Closing Remarks</a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div class="content" id="introduction">
    <h1>Packages and Distributions </h1>



    <p>
        A <em>package</em> is a logical unit of software.
        The obvious example is a program, but libraries are packages, too.
    </p>
</div>

<div class="content" id="open-source">
    <h2>Open Source</h2>

    <p>
        The GNU GPL stipulates that licensed software be available in source-code
        form. The GNU-way of building and installing their stuff is:
    </p>

    <div class="code">
        $ ./configure &amp;&amp; make &amp;&amp; make install
    </div>

    <p>
        Each project uses its own language and build system;
        the above list of commands presupposes C/C++ source built via
        GNU's <em>Autoconf.</em>
        Most packages include a <code>README</code> file that contains
        directions to build, install, or tinker.
    </p>

    <p>
        The traditional UNIX package format is a compressed tarball, a file
        ending in <code>.tar.xz</code>, or <code>.tar.gzip</code>.
        One extracts such an archive with:
    </p>

    <div class="code">
        $ tar xf kernel-5.10.tar.xz
    </div>

    <p>
        yielding a directory reflective of its original packager's.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.slackware.com/releasenotes/packages14.2.php">Slackware 14.2 Package List</a></li>
        <li><a href="http://linuxfromscratch.org/lfs/view/stable/chapter03/packages.html">Linux From Scratch Package List</a></li>
    </ul>
</div>

<div id="building-from-source" class="content">
    <h2>Building an OS from Source</h2>

    <p>
        Naturally, the system may be viewed as a collection of installed packages.
    </p>

    <p>
        <a href="http://linuxfromscratch.org/">Linux From Scratch</a> is
        documentation regarding how to build a working
        GNU/Linux system entirely from source.
        One obtains each package, configures, compiles and
        installs it by hand.
        A new version of the documentation is released about every six months.
    </p>

    <p>
        Stepping away from manual configuration and compilation,
        we arrive at the highly UNIX-y notion of <em>ports.</em>
        A port is, in essence, a script that installs a package from source.
        From an OpenBSD manual page:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            More generally, a <em>software port</em> is a minor revision of
            software allowing it to run on some non-native machine.
            We will not have reason to differentiate scripts and revisions here.
        </p>
    </div>

    <blockquote>
        "Each port contains any patches necessary to make the original application
        source code compile and run on OpenBSD. Compiling an application is as simple
        as typing <code>make</code> in the port directory! The Makefile automatically
        fetches the application source code, either from a local disk or via HTTP,
        unpacks it on the local system, applies the patches, and compiles it.
        If all goes well, simply type <code>doas make install</code> to install the
        application."<sup><a href="https://man.openbsd.org/ports.7">[a]</a></sup>
    </blockquote>

    <p>
        Gentoo Linux uses exactly this approach, and is a
        <em>metadistribution</em> owing to its lack of precompiled binaries.
        Even in proper distributions, scripts (and automation in general) are
        used to ease the burden of project maintenance.
        For instance, in Arch Linux,
        <a href="https://wiki.archlinux.org/index.php/PKGBUILD"><code>PKGBUILD</code></a>
        is officially specified as the package's principle build mechanism.
    </p>

    <h3> See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Portage_(software)">Portage (software)</a> - Wikipedia</li>
        <li><a href="http://linuxfromscratch.org/blfs/view/stable/introduction/notes-on-building.html">Notes on Building Software</a> - Beyond Linux From Scratch</a></li>
    </ul>
</div>

<div id="binary-packages" class="content">
    <h2> Binary Packages </h2>

    <p>
        Packages are typically distributed in preconfigured and precompiled form.
        This yields a smaller archive, saves users from the
        time-consuming step of compilation, and allows complete automation of
        installation.
        The implication, however, is that each piece of software is preconfigured
        for a particular operating system.
    </p>

    <p>
        Among major distributions, the Slackware Project entertains the
        oldest, and possibly simplest, binary packaging scheme.
        By modern standards, it may be considered crude,
        because it leaves dependency resolution to the user.<sup><a href="https://www.slackbook.org/html/package-management.html">[2]</a></sup>
        It is easily dissected, though, and so represents a nice jumping-off point
        for us.
    </p>

    <p>
        A Slackware package arrives to the user as a single compressed archive.
        In this file is a directory tree reflective of the Slackware operating
        system, such as:
    </p>

    <div class="code">
        $ tree slackware-vim-fake <br>
        . <br>
        ├── install <br>
        │   ├── doinst.sh <br>
        │   └── slack-desc <br>
        └── usr <br>
            &ensp;&ensp;&ensp;&ensp;├── bin <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;├── doc <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;├── COPYING <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;└── README <br>
            &ensp;&ensp;&ensp;&ensp;└── man <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── man1 <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── vim.1.gz
    </div>

    <p>
        To install the package, the archive is extracted, and the files are
        copied into the appropriate directories of the operating system.
        If a directory does not exist, it is created;
        the <code>install</code> directory is ignored.
        After these files are copied, the script
        <code>./install/doist.sh</code> is executed, if it exists.
    </p>

    <p>
        ...And that's it!
    </p>

    <p>
        Installation is usually handled by a utility&mdash; in this case, either
        <a href="https://www.slackbook.org/html/package-management-package-utilities.html"><code>installpkg</code> or <code>pkgtools</code></a>&mdash;
        which must be granted superuser priveledges.
    </p>

    <p>
        All major distributions package software using compressed archives
        of "reflective directory trees," though each to their own taste:
    </p>

    <ul>
        <li>
            Slackware <code>.txz</code>:
            <code>xz</code>-compressed tarball
        </li>

        <li>
            Fedora / Red Hat <code>.rpm</code>:
            A custom file format which contains four sections: Lead, signature,
            header, and payload (<code>zstd</code>-compressed <code>cpio</code>
            archive).<sup><a href="https://en.wikipedia.org/wiki/RPM_Package_Manager#Binary_format">[3]</a></sup>
        </li>

        <li>
            Debian <code>.deb</code>:
            An archive containing three files:
            <code>debian-binary</code>, denoting package format version number;
            <code>control.tar.xz</code>, serving a role analogous to <code>install</code> above; and
            <code>data.tar.xz</code>, the actual payload
        </li>

        <li>
            Arch:
            <code>zstd</code>-compressed tarball
        </li>
    </ul>

    <p>
        While packages of the same program (e.g., <code>vim</code>) may
        be similar across distributions, do not expect them to be
        cross-distribution compatible.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Tar_(computing)">tar (computing) - Wikipedia </a></li>
    </ul>
</div>

<div class="content" id="dependencies">
    <h2>Dependencies</h2>
    <p>
        It's relatively common for a given package to depend upon other packages;

https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html
    </p>
</div>

<div class="content" id="package-managers">
        <h2> Package Managers </h2>


        <!--
        this is what you turn to a distribution <em>for</em>&mdash; and
        -->


        <p>
        To update a machine running on Debian's packaging facilities, for example,
        we must simply run,
        </p>

        <div class="aside-right">
        <h4>Aside:</h4>
                <p>
                        See <code>$ apt --help</code>
                        and <code><a href="https://manpages.debian.org/buster/apt/apt.8.en.html">apt(8)</a></code> for more information
                </p>
        </div>

        <div class="code">
        $ sudo apt update <br>
        $ sudp apt upgrade
        </div>

        <p>
        The first command, <code>update</code>, synchronizes <code>apt</code>'s
        local package list with those of the configured repositories.
        The second command downloads and installs any revised packages.
        This two-command sequence would install a new kernel
        (via <a href="https://packages.debian.org/search?keywords=kernel-image&searchon=names&suite=stable&section=all">kernel-image</a>), for instance,
        and it would be used on the next reboot.
        </p>
</div>


<div class="content" id="closing-remarks">
    <h2>Closing Remarks:</h2>
    <h4><code>make</code></h4>

    <div class="aside-left">
    <h4>Aside:</h4>

        <p>
            An introduction to UNIX or UNIX-likes would not be complete without
            <code>make</code>!
        </p>
    </div>

    One expresses a program to be compiled in "recipes" of the form,

    hello: hello.c
        gcc -o hello hello.c


    and stores them in a file named <code>Makefile</code>.
    Now, whenever a source file changes (in this example, <code>hello.c</code>),
    the command <code>make hello</code> will recompile the program,
    via <code>gcc -o hello hello.c</code>.


    Quite a novel little utility, and it is general in the sense that the files
    in question need not be source/binary.
    However,


    Kernighan:  p96
    Invented 1976, 7th ed UNIX
    "an instant success"

    "This approach replaces code with data, and that's almost always a win."


    https://en.wikipedia.org/wiki/Make_(software)
    Original Make was conceived and written over a weekend
    [It's rediculous to funnel such quantities of software through such a tool]
    <a href="https://en.wikipedia.org/wiki/GNU_Autotools#Components">obtuse to say the least</a>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> <i>Unix Programmer's Manual, First Edition.</i>  <a href="https://www.bell-labs.com/usr/dmr/www/1stEdman.html"> https://www.bell-labs.com/usr/dmr/www/1stEdman.html </a> </li>
        <li> WHATWG HTML Living Standard Section 1.6, History. <a href="https://html.spec.whatwg.org/multipage/introduction.html#history-2">https://html.spec.whatwg.org/multipage/introduction.html#history-2</a> </li>
    </ol>
</div>
