---
layout: default
title: Packages and Distributions
last-updated: April 2021
---

<!--

<h2>Package Groups and Metapackages</h2>
<p>
        https://wiki.archlinux.org/index.php/Meta_package_and_package_group
        A package that contains nothing but dependencies.
        When "installed", the effect is to install a group of packages.
</p>


A section from the Linux Mint User Guide (old)
https://www.linuxmint.com/documentation/user-guide/Cinnamon/english_18.0.pdf

Debian Recommends vs. Suggests ("Declaring relationships between packages")
https://www.debian.org/doc/debian-policy/ch-relationships.html


    Like if you looked at computing from outer space:
    https://tomaka.medium.com/the-future-of-operating-systems-efa31e17d66d



<div class="content" id="closing-remarks">
    <h2 style="margin-bottom: 0;">Closing Remarks:</h2>
    <h4>Repositories</h4>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Yay free software!
        </p>
    </div>

    <p>
        A <em>repository</em> is a tracked collection of files.
        A distribution necessarily maintains one or more repositories of binary
        packages. 
        These can become quite large:
        openSUSE, for instance, maintains five versions of the same
        repository, each compiled for a different architecture.<sup><a href="https://get.opensuse.org/tumbleweed/">[e]</a></sup>
        They do this once each for <em>Leap</em> and <em>Tumbleweed</em>.
    </p>

    <p>
        Mirroring repositories both distributes and reduces the assiciated cost 
        of package distribution; please use mirrors!
    </p>

    <p>
        Local repositories
        Gentoo <code>ebuilds</code> housed in <code>/var/db/repos/gentoo</code> (by default).<sup><a href="https://wiki.gentoo.org/wiki/Ebuild">[d]</a></sup>
    </p>

    <p>
        Synchronizing Repositories
    </p>

    <p>
        Adding repositories, for instance 
        Personal package repositories
        Debian Personal Package Archive
        https://itsfoss.com/ppa-guide/
        Arch User's Repository, AUR
    </p>

    <p>
        Social repositories
        Github offers services for creating your own repository,
        and forking those of others.
    </p>

    <ul>
        <li><a href="https://flight-manual.atom.io/getting-started/sections/installing-atom/">Installing Atom</a> (Example instructions to add repository)</li>
    </ul>
</div>


    <li><a href="https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html">Debian Package Basics</a></li>
-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#open-source"> Open Source</a></li>
        <li><a href="#building-from-source">Building an OS from Source</a></li>
        <li><a href="#binary-packages">Binary Packages</a></li>
        <li><a href="#package-managers">Package Managers</a></li>
        <li><a href="#release-models">Release Models</a></li>
        <!--<li><a href="#closing-remarks">Closing Remarks</a></li>-->
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div class="content" id="introduction">
    <h1>Packages and Distributions </h1>

    <p>
        A <em>package</em> is a logical unit of software.
        The obvious example is a program, but libraries are packages, too.
        The purpose of this article is to orient the user to the package-centric
        landscape of pragmatic open-source software.
    </p>
</div>

<div class="content" id="open-source">
    <h2>Open Source</h2>

    <p>
        The GNU GPL stipulates that licensed software be available in source-code
        form. The GNU-way of building and installing their stuff is:
    </p>

    <div class="code">
        $ ./configure &amp;&amp; make &amp;&amp; make install
    </div>

    <p>
        Each project uses its own language and build system;
        the above 
        <a href="https://www.gnu.org/software/bash/manual/html_node/Lists.html#Lists">list</a> 
        of commands presupposes C/C++ source built via
        GNU's <em>Autoconf.</em>
        Most packages include a <code>README</code> file of
        instructions to build, install, or tinker.
    </p>

    <p>
        The traditional UNIX package format is a compressed tarball, a file
        ending in <code>.tar.xz</code>, or <code>.tar.gzip</code>.
        One extracts such an archive with:
    </p>

    <div class="code">
        $ tar xf kernel-5.10.tar.xz
    </div>

    <p>
        yielding a directory reflective of its original packager's.
    </p>

    <p>
        Naturally, the system may be viewed as a collection of installed
        packages.
        Finally, to configure and compile source code into usable software 
        is to <em>build</em> it.  
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.slackware.com/releasenotes/packages14.2.php">Slackware 14.2 Package List</a></li>
        <li><a href="http://linuxfromscratch.org/lfs/view/stable/chapter03/packages.html">Linux From Scratch Package List</a></li>
    </ul>
</div>

<div id="building-from-source" class="content">
    <h2>Building an OS from Source</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            A new version of the documentation is released about every six months.
        </p>
    </div>

    <p>
        <a href="http://linuxfromscratch.org/">Linux From Scratch</a> is
        documentation describing how to build a working
        GNU/Linux system entirely from source.
        One obtains each package, configures, compiles and
        installs it by hand.
    </p>

    <p>
        Open-source is all about choice, and for some,
        Linux from Scratch is the only way to go.
        However, building anything from source is time-consuming and labor-intensive;
        in particular, feature and security updates are left entirely to the user.
        The ordinary user is not expected to build software from source.
    </p>

    <p>
        If we're just a little bit more clever, we'll recognize that 
        <strike>programming is all about repitition</strike>
        <em>building</em> is per-package specific, so that we 
        could maintain descriptions of how to build software, to
        be interpretted by some utility program.
    </p>

    <p>
        Gentoo Linux is an operating system built around this strategy.
        The mechanized instructions to build software are kept in 
        <code>ebuild</code>'s text files which
        additionally describe where to obtain the original source
        code, software version number and package dependencies.
        The scheme is transparent and flexible, and Gentoo is all about 
        openness and choice.<sup><a href="https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/About">[a]</a></sup>
    </p>

    <p>
        Compilation remains time-consuming: It can take over a day
        to build a working system from source, but nonetheless begins to be 
        approachable by ordinary users.
    </p>

    <h3> See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Portage_(software)">Portage (software)</a> - Wikipedia</li>
        <li><a href="http://linuxfromscratch.org/blfs/view/stable/introduction/notes-on-building.html">Notes on Building Software</a> - Beyond Linux From Scratch</a></li>
    </ul>
</div>

<div id="binary-packages" class="content">
    <h2> Binary Packages </h2>

    <p>
        Packages are traditionally distributed in preconfigured and precompiled form.
        This yields a smaller archive, saves users the
        time-consuming step of compilation, and allows the
        complete automation of installation.
        And software installation is fast!  
        The implication, however, is that each distributed package is preconfigured
        for a particular operating system, running on a particular computer 
        architecture.
    </p>

    <p>
        Among major distributions, the Slackware Project entertains the
        oldest, and possibly simplest, binary packaging scheme.
        By modern standards, it may be considered crude,
        because it leaves dependency resolution to the user.<sup><a href="https://www.slackbook.org/html/package-management.html">[2]</a></sup>
        It is easily dissected, though, and so represents a nice example 
        for us.
    </p>

    <p>
        A Slackware package arrives to the user as a compressed tarball.
        In this file is a directory tree reflective of the Slackware operating
        system, such as:
    </p>

    <div class="code">
        $ tree slackware-vim-fake <br>
        . <br>
        ├── install <br>
        │   ├── doinst.sh <br>
        │   └── slack-desc <br>
        └── usr <br>
            &ensp;&ensp;&ensp;&ensp;├── bin <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;├── doc <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;├── COPYING <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;└── README <br>
            &ensp;&ensp;&ensp;&ensp;└── man <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── man1 <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── vim.1.gz
    </div>

    <p>
        To install the package, the archive is extracted and the files 
        copied into the appropriate directories of the host operating system.
        If a directory does not exist, it is created;
        the <code>install</code> directory is ignored.
        After these files are copied, the script
        <code>install/doist.sh</code> is executed, if it exists.
    </p>

    <p>
        ...And that's it!
    </p>

    <p>
        The installation utility is, in this case, either
        <a href="https://www.slackbook.org/html/package-management-package-utilities.html"><code>installpkg</code> or <code>pkgtools</code></a>. 
        It must be granted root privilege.
    </p>

    <p>
        All major distributions deal in binary packages, and use similar 
        compressed-archives of "reflective directory trees,"
        though each to their own taste.
        By and large, however, the <em>package</em> is intended to be
        an opaque data format, and we will not dissect it further.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Tar_(computing)">tar (computing) - Wikipedia </a></li>
    </ul>
</div>

<div class="content" id="package-managers">
    <h2> Package Managers </h2>

    <p>
        A utility that obtains and installs packages is referred to as a 
        <em>package manager.</em>
        Package managers are highly distribution-specific, and serve
        as the user's front-end for their software:
    </p>

    <ul>
        <li>Debian: <code>apt</code></li>
        <li>Fedora: <code>rpm</code></li>
        <li>openSUSE: <code>zypper</code></li>
        <li>Arch: <code>pacman</code></li>
    </ul>

    <p>
        Modern package managers are among the most powerful pieces of software
        on GNU/Linux operating systems.
        To update a machine utilizing Debian's packaging facilities, for example,
        we simply,
    </p>

    <div class="code">
        $ sudo apt update <br>
        $ sudp apt upgrade
    </div>

    <p>
        Searching for packages does not require superuser privileges:
    </p>

    <div class="code">
        $ apt search vim
    </div>

    <p>
        Each package contains a description of itself:
    </p>

    <div class="code">
        $ apt show vim
    </div>

    <p>
        And can be installed with:
    </p>

    <div class="code">
        $ sudo apt install vim
    </div>

    <h3>Dependencies</h3>
    <p>
        It's relatively common for a given package to depend upon other packages,
        and most distributions, including Debian, automate dependency resolution.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.debian.org/AptCLI">Apt CLI - Debian Wiki</a></li>
        <li><a href="https://en.opensuse.org/Package_management">Package management - openSUSE</a></li>
    </ul>
</div>


<div class="content" id="release-models">
    <h2>Release Models</h2>
    <p>
        In open-source software, as in any other field, there are 
        known-good ideas and known-bad ideas.
    </p>

    <ul>
        <li>
            Known-good ideas:
            <ul>
                <li>Dynamic linking</li>
                <li>Reiterative improvement</li>
                <li>Breaking a problem down and solving the pieces</li>
                <li>Abdicating responsibility to people who actually want to do it</li>
            </ul>
        </li>
        <li>
            Known-bad ideas:
            <ul>
                <li>Static linking</li>
                <li>Solving problems that don't actually exist</li>
                <li>Dictatorships</li>
            </ul>
        </li>
    </ul>

    <p>
        Distributing binary packages in the manner described above is a 
        known-good idea, and there are many successful variations.
        Among them, the <em>regular release</em> model deals in discretely released
        operating systems.
        After the initial release, updates are restricted to bug
        fixes; new features do not become available within a particular release.
    </p>


    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Mint 20.1 "Ulyssa" is a long-term support release, and will be 
            supported until 2025.<sup><a href="https://blog.linuxmint.com/?p=4011">[d]</a></sup>
        </p>
    </div>

    <p>
        Distributions following the regular release model:
    </p>

    <ul>
        <li> Linux Mint </li>
        <li> openSUSE Leap </li>
        <li> Debian </li>
        <li> Slackware </li>
        <li> Fedora </li>
        <li> Ubuntu </li>
    </ul>

    <p>
        This strategy has produced extremely stable operating 
        systems.<sup><a href="http://www.slackware.com/about/">[c]</a></sup>
        Each version is supported for some length of time, 
        usually asserted beforehand.
    </p>

    <p>
        The <em>rolling release</em> model is a newer variant that 
        dispenses with any versioning scheme.  
        Instead, updates and features are distributed as they become
        available.
        The result is a bleeding-edge operating system&mdash; and
        a constant stream of updates.  
    </p>

    <p>
        Examples:
    </p>

    <ul>
        <li> Arch </li>
        <li> Garuda </li>
        <li> openSUSE Tumbleweed </li>
    </ul>

    <p>
        Finally, between the two is <em>semi-rolling releases,</em>
        best explained through example:
        <a href="https://getsol.us/home/">Solus Linux</a> is an up-and-coming 
        distribution focused on the home desktop. 
        They release a set of package updates every Friday, which, taken together,
        form the most recent version of their OS. 
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.debian.org/News/2021/20210327">Debian -- News -- 10: 10.9 released</a></li>
        <li><a href="https://wiki.archlinux.org/index.php/Arch_Linux">Arch Linux ArchWiki</a></li>
    </ul>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> <i>Unix Programmer's Manual, First Edition.</i>  <a href="https://www.bell-labs.com/usr/dmr/www/1stEdman.html"> https://www.bell-labs.com/usr/dmr/www/1stEdman.html </a> </li>
        <li> WHATWG HTML Living Standard Section 1.6, History. <a href="https://html.spec.whatwg.org/multipage/introduction.html#history-2">https://html.spec.whatwg.org/multipage/introduction.html#history-2</a> </li>
    </ol>
</div>
