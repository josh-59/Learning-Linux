---
layout: default
title: Packages and Distributions
last-updated: April 2021
---

<!--


    Naturally, the system may be viewed as a collection of installed packages.

    Principle build mechanism:
    ^^^^^^^^^
            More like 'custom' or 

    Define 'repository' as a tracked collection of files, and note that they
    usually contain a package.

    - The installation process is markedly similar to Linux From Scratch.
    - Gentoo scripts are written in Python

<div class="content" id="binary-packages">

Package Contents: Metadata and Payload
        Rewrite to use Arch Linux's packaging as example

    The contents of a package may be split into two
        parts: Metadata and Payload.
        In Slackware's format, metadata is restricted to the <code>./install</code>
        directory, and consists of the post-copy script <code>doinst.sh</code>
        and a description of the software, <code>slack-desc</code>.
        Other package management schemes incorporate more metadata; here
        we'll take a look at Arch's, since it is more complete.
    </p>

    <p>
        First, we obtain a package and extract it:
    </p>

<div class="code">o.
        $ ls
        vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ tar xf vim-8.2.2489-1-aarch64.pkg.tar.xz &amp;&amp; rm vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ ls -A
        .BUILDINFO  .MTREE  .PKGINFO  usr/
</div>


Package managers:
    <div class="code">
        sudo apt install ./atom-amd64.deb
    </div>

    <p>
        That's it. There's nothing more to it.
    </p>

    Expressing the Operating System:
        Arch: base

        The system may be viewed as a collection of installed packages,
        and, the package manager could be viewed as a manager of the
        operating system.


        This is how the Arch guys view packages: The system is viewed
        as a repository, and when new software is released, the local
        repository becomes out of sync with the upstream repository.
        "Upgrading" becomes a matter of synchronizing these repositories.

        Thus, the software that composes a system defines the
        operating system, and,

    Repositories:
        Subsection?


        Some people think that rolling releases are
        the future of Linux distributions
        <sup><a href="https://frontpagelinux.com/news/centos-crosses-streams-with-the-community/">[1]</a></sup>

        Debian Personal Package Archive
        https://itsfoss.com/ppa-guide/
        Arch User's Repository, AUR


    Rolling Releases:

    https://wiki.archlinux.org/index.php/Meta_package_and_package_group

<h2>Package Groups and Metapackages</h2>
<p>
        A package that contains nothing but dependencies.
        When "installed", the effect is to install a group of packages.
</p>


Debian-specific virtual package: A faux target, only realized by other,
actual packages.

A section from the Linux Mint User Guide (old)
https://www.linuxmint.com/documentation/user-guide/Cinnamon/english_18.0.pdf

Debian Recommends vs. Suggests ("Declaring relationships between packages")
https://www.debian.org/doc/debian-policy/ch-relationships.html

Other Package Managers:
    PIP:
    Cargo:

        Cross-platform packages:
                Great in theory, horrific in practice (See Torvald's quote).
    Snap
    Zero Install
    https://blog.linuxmint.com/?p=3766 (Critique of Snap)
    https://blog.linuxmint.com/?p=3906 (Chromium empty package) "In Linux Mint 20, APT will forbid snapd from getting installed.""
    From https://linuxmint-user-guide.readthedocs.io/en/latest/snap.html
           "The Snap Store, also known as the Ubuntu Store, is a commercial centralized software store operated by Canonical."
           Snap is unique in that it solves a problem that didn't actually exist:


    https://docs.freebsd.org/en/books/handbook/ports/#ports-using
    Package Benefits

            Thanks for reading!
                Ecosystem
            Where to go from here?
                Install Ubuntu
                The Linux Command Line
                Arch Linux or Linux From Scratch

    Like if you looked at computing from outer space:
    https://tomaka.medium.com/the-future-of-operating-systems-efa31e17d66d


Repositories
    <p>
        A <em>repository</em> is a tracked collection of files.  
        Maintaining and making available a repository of binary packages
        is a nontrivial component of distribution.
    </p>

    <p>
        <p>
            Github offers services for creating your own repository,
            and forking those of others.
        </p>

    <p>
        Known-good ideas:
            Dynamic Linking
        Known-bad ideas:
            Static Linking!
    </p>
</div>

<p>
    For instance, it is common (though fading) practice for
    distributions to offer a new release every six months.
</p>


    <p>
        a view that is reiterated by each distribution considered below.
    </p>


<div class="content" id="closing-remarks">
   <h2>Closing Remarks:</h2>
    <h4><code>make</code></h4>

    <div class="aside-left">
    <h4>Aside:</h4>

        <p>
            An introduction to UNIX or UNIX-likes would not be complete without
            <code>make</code>!
        </p>
    </div>

    One expresses a program to be compiled in "recipes" of the form,

    hello: hello.c
        gcc -o hello hello.c


    and stores them in a file named <code>Makefile</code>.
    Now, whenever a source file changes (in this example, <code>hello.c</code>),
    the command <code>make hello</code> will recompile the program,
    via <code>gcc -o hello hello.c</code>.


    Quite a novel little utility, and it is general in the sense that the files
    in question need not be source/binary.
    However,


    Kernighan:  p96
    Invented 1976, 7th ed UNIX
    "an instant success"

    "This approach replaces code with data, and that's almost always a win."


    https://en.wikipedia.org/wiki/Make_(software)
    Original Make was conceived and written over a weekend
    [It's rediculous to funnel such quantities of software through such a tool]
    <a href="https://en.wikipedia.org/wiki/GNU_Autotools#Components">obtuse to say the least</a>
</div>

-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#open-source"> Open Source</a></li>
        <li><a href="#building-from-source">Building an OS from Source</a></li>
        <li><a href="#binary-packages">Binary Packages</a></li>
        <li><a href="#package-managers">Package Managers</a></li>
        <li><a href="#closing-remarks">Closing Remarks</a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div class="content" id="introduction">
    <h1>Packages and Distributions </h1>

    <p>
        A <em>package</em> is a logical unit of software.
        The obvious example is a program, but libraries are packages, too.
        The purpose of this article is to orient the user to the package-centric
        landscape of pragmatic open-source software.
    </p>
</div>

<div class="content" id="open-source">
    <h2>Open Source</h2>

    <p>
        The GNU GPL stipulates that licensed software be available in source-code
        form. The GNU-way of building and installing their stuff is:
    </p>

    <div class="code">
        $ ./configure &amp;&amp; make &amp;&amp; make install
    </div>

    <p>
        Each project uses its own language and build system;
        the above 
        <a href="https://www.gnu.org/software/bash/manual/html_node/Lists.html#Lists">list</a> 
        of commands presupposes C/C++ source built via
        GNU's <em>Autoconf.</em>
        Most packages include a <code>README</code> file that contains
        instructions to build, install, or tinker.
    </p>

    <p>
        The traditional UNIX package format is a compressed tarball, a file
        ending in <code>.tar.xz</code>, or <code>.tar.gzip</code>.
        One extracts such an archive with:
    </p>

    <div class="code">
        $ tar xf kernel-5.10.tar.xz
    </div>

    <p>
        yielding a directory reflective of its original packager's.
    </p>

    <p>
        Finally, to configure and compile source code into usable software 
        is to <em>build</em> it.  
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.slackware.com/releasenotes/packages14.2.php">Slackware 14.2 Package List</a></li>
        <li><a href="http://linuxfromscratch.org/lfs/view/stable/chapter03/packages.html">Linux From Scratch Package List</a></li>
    </ul>
</div>

<div id="building-from-source" class="content">
    <h2>Building an OS from Source</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            A new version of the documentation is released about every six months.
        </p>
    </div>

    <p>
        <a href="http://linuxfromscratch.org/">Linux From Scratch</a> is
        documentation describing how to build a working
        GNU/Linux system entirely from source.
        One obtains each package, configures, compiles and
        installs it by hand.
    </p>

    <p>
        Open-source is all about choice, and for some,
        Linux from Scratch is the only way to go.
        However, building anything from source is time-consuming and labor-intensive;
        in particular, feature and security updates are left entirely to the user.
        The ordinary user is not expected to build software from source.
    </p>

    <p>
        If we're just a little bit more clever, we'll recognize that 
        <strike>programming is all about repitition</strike>
        <em>building</em> is per-package specific, so that we 
        could maintain a description of how to build software, to
        be interpretted by some utility program.
    </p>

    <p>
        Gentoo Linux is an operating system built around this strategy.
        The mechanized instructions to build software are kept in 
        "<code>ebuild</code>"'s, 
        which additionally describe where to obtain the original source
        code.
        Gentoo is often referred to as a <em>metadistribution</em> because it
        does not deal in binary packages.
    </p>

    <p>
        Compilation remains a time-consuming step, often taking over a day
        to build a working system, but nonetheless begins to be approachable
        by ordinary users.
        Moreover, even in proper distributions, automation is similarly
        used to ease the burden of project maintenance.
        For example, in Arch Linux,
        <a href="https://wiki.archlinux.org/index.php/PKGBUILD"><code>PKGBUILD</code></a>
        is officially specified as the package's principle build mechanism.
    </p>

    <h3> See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Portage_(software)">Portage (software)</a> - Wikipedia</li>
        <li><a href="http://linuxfromscratch.org/blfs/view/stable/introduction/notes-on-building.html">Notes on Building Software</a> - Beyond Linux From Scratch</a></li>
    </ul>
</div>

<div id="binary-packages" class="content">
    <h2> Binary Packages </h2>

    <p>
        Packages are typically distributed in preconfigured and precompiled form.
        This yields a smaller archive, saves users the
        time-consuming step of compilation, and still allows complete automation of
        installation.
        And software installation is fast!  
        The implication, however, is that each distributed package is preconfigured
        for a particular operating system, running on a particular computer 
        architecture.
    </p>

    <p>
        Among major distributions, the Slackware Project entertains the
        oldest, and possibly simplest, binary packaging scheme.
        By modern standards, it may be considered crude,
        because it leaves dependency resolution to the user.<sup><a href="https://www.slackbook.org/html/package-management.html">[2]</a></sup>
        It is easily dissected, though, and so represents a nice jumping-off point
        for us.
    </p>

    <p>
        A Slackware package arrives to the user as a compressed tarball.
        In this file is a directory tree reflective of the Slackware operating
        system, such as:
    </p>

    <div class="code">
        $ tree slackware-vim-fake <br>
        . <br>
        ├── install <br>
        │   ├── doinst.sh <br>
        │   └── slack-desc <br>
        └── usr <br>
            &ensp;&ensp;&ensp;&ensp;├── bin <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;├── doc <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;├── COPYING <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;└── README <br>
            &ensp;&ensp;&ensp;&ensp;└── man <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── man1 <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── vim.1.gz
    </div>

    <p>
        To install the package, the archive is extracted and the files 
        copied into the appropriate directories of the host operating system.
        If a directory does not exist, it is created;
        the <code>install</code> directory is ignored.
        After these files are copied, the script
        <code>install/doist.sh</code> is executed, if it exists.
    </p>

    <p>
        ...And that's it!
    </p>

    <p>
        The installation utility is, in this case, either
        <a href="https://www.slackbook.org/html/package-management-package-utilities.html"><code>installpkg</code> or <code>pkgtools</code></a>. 
        It must be granted root priveledges.
    </p>

    <p>
        All major distributions deal in binary packages, and use similar 
        compressed archives of "reflective directory trees,"
        though each to their own taste.
        By and large, however, the <em>package</em> is intended to be
        an opaque data format.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Tar_(computing)">tar (computing) - Wikipedia </a></li>
    </ul>
</div>

<div class="content" id="package-managers">
    <h2> Package Managers </h2>

    <p>
        As mentioned, package installation is fully automated.  
        The utility that handles packages is referred to as a 
        <em>package manager.</em>
    </p>

    <ul>
        <li>Debian: <code>apt</code></li>
        <li>Fedora: <code>rpm</code></li>
        <li>openSUSE: <code>zypper</code></li>
    </ul>

    <p>
        To update a machine running on Debian's packaging facilities, for example,
        we must simply run,
    </p>
    <div class="aside-right">
    <h4>Aside:</h4>
        <p>
                See <code>$ apt --help</code>
                and <code><a href="https://manpages.debian.org/buster/apt/apt.8.en.html">apt(8)</a></code> for more information
        </p>
    </div>

    <div class="code">
        $ sudo apt update <br>
        $ sudp apt upgrade
    </div>

    <p>
        The first command, <code>update</code>, synchronizes <code>apt</code>'s
        local package list with those of the configured repositories.
        The second command downloads and installs any revised packages.
        This two-command sequence would install a new kernel
        (via <a href="https://packages.debian.org/search?keywords=kernel-image&searchon=names&suite=stable&section=all">kernel-image</a>), for instance,
        and it would be used on the next reboot.
    </p>

    <h3>Dependencies</h3>
    <p>
        It's relatively common for a given package to depend upon other packages,
        and most mainstream distributions fully automate dependency resolution.
        This is done by listing dependencies within its metadata,
        then recursively satisfying those dependencies.
    </p>

    <p>
        For example, the dependencies of 
        <a href="https://packages.debian.org/buster/vim">Vim</a> on Debian are listed as:
    </p>

    <div class="code">
Depends: vim-common (= 2:8.1.0875-5), vim-runtime (= 2:8.1.0875-5), libacl1 (&gt;= 2.2.23), libc6 (&gt;= 2.15), libgpm2 (&gt;= 1.20.7), libselinux1 (&gt;= 1.32), libtinfo6 (&gt;= 6)
    </div>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.opensuse.org/Package_management">Package management - openSUSE</a></li>
        <li><a href="https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html">Debian Package Basics</a></li>
    </ul>
</div>


<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> <i>Unix Programmer's Manual, First Edition.</i>  <a href="https://www.bell-labs.com/usr/dmr/www/1stEdman.html"> https://www.bell-labs.com/usr/dmr/www/1stEdman.html </a> </li>
        <li> WHATWG HTML Living Standard Section 1.6, History. <a href="https://html.spec.whatwg.org/multipage/introduction.html#history-2">https://html.spec.whatwg.org/multipage/introduction.html#history-2</a> </li>
    </ol>
</div>
