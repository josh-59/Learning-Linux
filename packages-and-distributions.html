---
layout: default
title: Packages and Distributions
last-updated: April 2021
---

<!--

    Gentoo:
        ebuild(5): https://dev.gentoo.org/~zmedico/portage/doc/man/ebuild.5.html
        ebuild phase functions: https://devmanual.gentoo.org/ebuild-writing/functions/

    Distribution Models:
        Regular Release model implies multiple code branches
        Rolling release model requires only a single code branch

    Manjaro updated 235 (out of 965) packages at once, and broke my 
    jekyll installation, for instance.  
    Linux Mint doesn't have that problem!

        <p>
            In open-source software, as in any other field, there are
            known-good ideas and known-bad ideas.
        </p>

        <ul>
            <li>
                Known-good ideas:
                <ul>
                    <li>Dynamic linking</li>
                    <li>Reiterative improvement</li>
                    <li>Breaking a problem down and solving the pieces</li>
                    <li>Abdicating responsibility to people who actually want to do it</li>
                </ul>
            </li>
            <li>
                Known-bad ideas:
                <ul>
                    <li>Static linking</li>
                </ul>
            </li>
        </ul>
-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#open-source"> Open Source</a></li>
        <li><a href="#building-from-source">Building an OS from Source</a></li>
        <li><a href="#binary-packages">Binary Packages</a></li>
        <li><a href="#package-managers">Package Managers</a></li>
        <li><a href="#repositories">Repositories</a></li>
        <li><a href="#closing-remarks">Closing Remarks: Distribution Models</a></li>
        <!--<li><a href="#closing-remarks">Closing Remarks</a></li>-->
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div class="content" id="introduction">
    <h1>Packages and Distributions </h1>

    <div class="quote-text">
        Software components should be small, <br>
        and focused on doing one specific thing well.
    </div>

    <div class="quote-ref">
        <a href="https://github.com/dwmkerr/hacker-laws#the-unix-philosophy">UNIX Philosophy</a>
    </div>

    <p>
        A <em>package</em> is a logical unit of software.
        The obvious example is a program, but libraries are packages, too.
        The purpose of this article is to orient the user to the package-centric
        landscape of pragmatic open-source software.
    </p>
</div>

<div class="content" id="open-source">
    <h2>Open Source</h2>

    <p>
        The GNU GPL stipulates that licensed software be available in source-code
        form. The GNU-way of building and installing their stuff is:
    </p>

    <div class="code">
        $ ./configure &amp;&amp; make &amp;&amp; make install
    </div>

    <p>
        Each project uses its own language and build system;
        the above
        <a href="https://www.gnu.org/software/bash/manual/html_node/Lists.html#Lists">list</a>
        of commands presupposes C/C++ source built via
        GNU's <em>Autoconf.</em>
        Most packages include a <code>README</code> file of
        instructions to build, install, or tinker.
    </p>

    <p>
        The traditional UNIX package format is a compressed tarball, a file
        ending in <code>.tar.xz</code>, or <code>.tar.gzip</code>.
        One extracts such an archive with:
    </p>

    <div class="code">
        $ tar xf kernel-5.10.tar.xz
    </div>

    <p>
        yielding a directory reflective of its original packager's.
    </p>

    <p>
        Naturally, the system may be viewed as a collection of installed
        packages.
        Finally, to configure and compile source code into usable software
        is to <em>build</em> it.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.slackware.com/releasenotes/packages14.2.php">Slackware 14.2 Package List</a></li>
    </ul>
</div>

<div id="building-from-source" class="content">
    <h2>Building an OS from Source</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            A new version of the documentation is released about every six months.
        </p>
    </div>

    <p>
        <a href="http://linuxfromscratch.org/">Linux From Scratch</a> is
        documentation describing how to build a working
        GNU/Linux system entirely from source.
        One obtains 88 different packages, and goes about configuring,
        compiling and installing them by hand.
    </p>

    <p>
        Open-source is all about choice, and for some,
        Linux from Scratch is the only way to go.
        However, building anything from source is time-consuming and labor-intensive;
        in particular, feature and security updates are left entirely to the user.
        The ordinary user is not expected to build software from source.
    </p>

    <p>
        As a first step towards automating this process, we might
        notice that <em>building</em> is per-package specific.
        Hence, we could maintain descriptions of how to build packages, to
        be interpretted by some utility program.
    </p>

    <p>
        Gentoo Linux is an operating system built around this strategy.
        The mechanized instructions to build software are kept in
        <code>ebuild</code>'s&mdash; text files which
        additionally describe where to obtain source code.
        These are interpretted by utilities on the user's machine,
        and ultimately result in a new package being installed.
    </p>

    <p>
        The scheme is minimal, transparent and flexible, and Gentoo is all about
        openness and choice.<sup><a href="https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/About">[a]</a></sup>
        Compilation remains time-consuming: It can take over a day
        to build a working system from source, but nonetheless begins to be
        approachable by ordinary users.
    </p>

    <h3> See Also:</h3>
    <ul>
        <li><a href="http://linuxfromscratch.org/blfs/view/stable/introduction/notes-on-building.html">Notes on Building Software</a> - Beyond Linux From Scratch</a></li>
    </ul>
</div>

<div id="binary-packages" class="content">
    <h2> Binary Packages </h2>

    <p>
        Packages are usually distributed in preconfigured and precompiled form.
        This yields a smaller archive, saves users the
        time-consuming step of compilation, and allows the
        complete automation of installation.
        And software installation is fast!
        The implication, however, is that each distributed package is configured
        for a particular operating system running on a particular computer architecture.
    </p>

    <p>
        Among major distributions, the Slackware Project entertains the
        oldest, and possibly simplest, binary packaging scheme.
        By modern standards, it may be considered crude,
        because it leaves dependency resolution to the user.<sup><a href="https://www.slackbook.org/html/package-management.html">[2]</a></sup>
        It is easily dissected, though, and so represents a nice example
        for us.
    </p>

    <p>
        A Slackware package arrives to the user as a compressed tarball.
        In this file is a directory tree reflective of the Slackware operating
        system, such as:
    </p>

    <div class="code">
        $ tree slackware-vim-fake <br>
        . <br>
        ├── install <br>
        │   ├── doinst.sh <br>
        │   └── slack-desc <br>
        └── usr <br>
            &ensp;&ensp;&ensp;&ensp;├── bin <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;├── doc <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;├── COPYING <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;└── README <br>
            &ensp;&ensp;&ensp;&ensp;└── man <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── man1 <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── vim.1.gz
    </div>

    <p>
        To install the package, the archive is extracted and the files
        copied into the appropriate directories of the host operating system.
        If a directory does not exist, it is created;
        the <code>install</code> directory is ignored.
        After these files are copied, the script
        <code>install/doist.sh</code> is executed, if it exists.
    </p>

    <p>
        ...And that's it!
    </p>

    <p>
        The installation utility is, in this case, either
        <a href="https://www.slackbook.org/html/package-management-package-utilities.html"><code>installpkg</code> or <code>pkgtools</code></a>.
        It must be granted root privilege.
    </p>

    <p>
        All major distributions deal in binary packages, and use similar
        compressed-archives of "reflective directory trees,"
        though each to their own taste.
        By and large, however, the <em>package</em> is intended to be
        an opaque data format, and we will not dissect it further.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Tar_(computing)">tar (computing) - Wikipedia </a></li>
    </ul>
</div>

<div class="content" id="package-managers">
    <h2> Package Managers </h2>

    <p>
        A utility that obtains and installs packages is referred to as a
        <em>package manager.</em>
        Package managers are distribution-specific, and serve
        as the user's front-end for their software.
        To name a few:
    </p>

    <ul>
        <li>Debian: <code>apt</code></li>
        <li>Fedora: <code>rpm</code></li>
        <li>openSUSE: <code>zypper</code></li>
        <li>Arch: <code>pacman</code></li>
    </ul>

    <p>
        Modern package managers are among the most powerful pieces of software
        on GNU/Linux operating systems.
        To update a machine utilizing Debian's packaging facilities, for example,
        we simply,
    </p>

    <div class="code">
        $ sudo apt update <br>
        $ sudp apt upgrade
    </div>

    <p>
        Searching for packages does not require superuser privileges:
    </p>

    <div class="code">
        $ apt search vim
    </div>

    <p>
        Each package contains a description of itself:
    </p>

    <div class="code">
        $ apt show vim
    </div>

    <p>
        And can be installed with:
    </p>

    <div class="code">
        $ sudo apt install vim
    </div>

    <h3>Dependencies</h3>
    <p>
        It's relatively common for a given package to depend upon other packages,
        and most distributions, including Debian, automate dependency resolution.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.debian.org/AptCLI">Apt CLI - Debian Wiki</a></li>
        <li><a href="https://en.opensuse.org/Package_management">Package management - openSUSE</a></li>
    </ul>
</div>

<div class="content" id="repositories">
    <h2>Repositories</h2>

    <p>
        A <em>repository</em> is a tracked collection of files.
        Each distribution necessarily maintains one or more repositories of binary
        packages, and makes them publicly available.
        These can become quite large:
        Debian counts 90,000 available packages.<sup><a href="https://packages.debian.org/stable/">[k]</a></sup>
        More, the collection is repeated once for each supported architecture.
        Mirroring repositories both distributes and reduces the associated cost
        of package distribution; please use mirrors!
    </p>

    <p>
        With that, we can now sketch out how a package update is propogated from source
        to user.
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Typical ("point") releases are
            <a href="https://semver.org/">minor revisions</a>
            that do not affect intended behavior.
        </p>
    </div>

    <p>
        First, some change is made to the source code.
        Minor changes can safely be ignored, but
        security fixes, for instance, cannot.
        A distribution maintainer rebuilds and tests the package.
        This is often done through scripts, similar to
        Gentoo's <code>ebuild</code>.
    </p>

    <p>
        The rebuilt package gets pushed to the distribution's repositories,
        then to mirrors.
        The user's package manager then synchronizes its list of available packages,
        and alerts the user to any relevant changes.
        This is usually done automatically, but can be done manually
        via,
    </p>

    <div class="code">
        $ sudo apt update
    </div>

    <p>
        Updated packages are downloaded and installed by the user.
        This is usually done manually, with
    </p>

    <div class="code">
        $ sudo apt upgrade
    </div>

    <h3>See Also:</h3>

    <ul>
        <li><a href="https://wiki.debian.org/PackageManagement#Repository_management">Package Management</a> - Debian Wiki</a></li>
        <li><a href="https://flight-manual.atom.io/getting-started/sections/installing-atom/">Installing Atom</a> (Example instructions to add repository)</li>
    </ul>
</div>



<div class="content" id="closing-remarks">
    <h2 style="margin-bottom: 0;">Closing Remarks:</h2>
    <h4>Distribution Models</h4>

    <p>
        Distributing binary packages in the manner described above is a
        known-good idea, and there are many successful variations.
        The <em>regular release</em> model deals in discretely released
        operating systems.
        Packages are composed into a working operating system, and undergo
        some testing period.
        After the initial release, updates are restricted to bug
        fixes and security updates; new features do not become available
        within a particular release.
    </p>

    <p>
        This strategy has produced extremely stable operating
        systems.<sup><a href="http://www.slackware.com/about/">[c]</a></sup>
        Each version is supported for some length of time,
        usually asserted beforehand.
        Distributions following the regular release model:
    </p>

    <ul>
        <li> Linux Mint </li>
        <li> openSUSE Leap </li>
        <li> Debian </li>
        <li> Slackware </li>
        <li> Fedora </li>
        <li> Ubuntu </li>
    </ul>

    <p>
        The <em>rolling release</em> model is a newer variant that
        dispenses with any versioning scheme.
        Instead, updates and features are distributed as they become
        available.
        The result is a bleeding-edge operating system&mdash; and
        a constant stream of updates.
    </p>

    <p>
        This strategy is growing in popularity, especially among desktop
        users.  Examples:
    </p>

    <ul>
        <li> Arch </li>
        <li> Garuda </li>
        <li> openSUSE Tumbleweed </li>
    </ul>

    <p>
        Between the two is the <em>semi-rolling release,</em>
        best explained through example:
        <a href="https://getsol.us/home/">Solus Linux</a> is an up-and-coming
        distribution focused on the home desktop.
        They release a set of package updates every Friday, which, taken together,
        form the most recent version of their OS.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.debian.org/News/2021/20210327">Debian -- News -- 10: 10.9 released</a></li>
        <li><a href="https://wiki.archlinux.org/index.php/Arch_Linux">Arch Linux</a> - ArchWiki</li>
    </ul>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> <i>Unix Programmer's Manual, First Edition.</i>  <a href="https://www.bell-labs.com/usr/dmr/www/1stEdman.html"> https://www.bell-labs.com/usr/dmr/www/1stEdman.html </a> </li>
        <li> WHATWG HTML Living Standard Section 1.6, History. <a href="https://html.spec.whatwg.org/multipage/introduction.html#history-2">https://html.spec.whatwg.org/multipage/introduction.html#history-2</a> </li>
    </ol>
</div>
