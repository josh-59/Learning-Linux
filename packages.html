---
layout: default
title: Packages and Package Management
last-updated: March 2021
---

<!--

        Good ideas tend to resurface.  
        Free software is in no danger of <em>being forgotten</em> because it is
        one such idea.
        The UNIX architecture similarly resurfaces.

Rewrite as "Distributing Open-Source"

    Packages and Distributions
                |
                |
                |
               \ /
    Ports / Gentoo's Portage
                |
                |
                |
               \ /
         Binary Packages
                |
                |
                |
               \ /
     Debian / Fedora / openSUSE
                |
                |
                |
               \ /
   Rolling Release Arch's pacman
                |
                |
                |
               \ /
Pip / Gems / Cargo / (JavaScript) NPM / SNAP / APM (Atom)

<div class="content" id="binary-packages">

Package Contents: Metadata and Payload
        Rewrite to use Arch Linux's packaging as example

    The contents of a package may be split into two 
        parts: Metadata and Payload.
        In Slackware's format, metadata is restricted to the <code>./install</code>
        directory, and consists of the post-copy script <code>doinst.sh</code>
        and a description of the software, <code>slack-desc</code>.
        Other package management schemes incorporate more metadata; here
        we'll take a look at Arch's, since it is more complete.
    </p>

    <p>
        First, we obtain a package and extract it:
    </p>

<div class="code">o.
        $ ls
        vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ tar xf vim-8.2.2489-1-aarch64.pkg.tar.xz &amp;&amp; rm vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ ls -A
        .BUILDINFO  .MTREE  .PKGINFO  usr/ 
</div>

        
<p>
        The package's metadata are the hidden files in this directory:
        <code>.BUILDINFO</code>, <code>.MTREE</code>, <code>.PKGINFO</code>.
        The package's payload consists of the non-hidden files 
        (in this case, that is only <code>usr/</code>).
        Not present in this package is the <code>.INSTALL</code> file,
        an optional script which would be executed by the package manager.
</p>


Package managers:
    <div class="code">
        sudo apt install ./atom-amd64.deb
    </div>

    <p>
        That's it. There's nothing more to it.
    </p>

    Expressing the Operating System:
        Arch: base

        The system may be viewed as a collection of installed packages,
        and, the package manager could be viewed as a manager of the 
        operating system.


        This is how the Arch guys view packages: The system is viewed
        as a repository, and when new software is released, the local
        repository becomes out of sync with the upstream repository.
        "Upgrading" becomes a matter of synchronizing these repositories.  

        Thus, the software that composes a system defines the 
        operating system, and, 
        
    Repositories:
        Subsection?


        Some people think that rolling releases are 
        the future of Linux distributions
        <sup><a href="https://frontpagelinux.com/news/centos-crosses-streams-with-the-community/">[1]</a></sup>

        Debian Personal Package Archive
        https://itsfoss.com/ppa-guide/
        Arch User's Repository, AUR


    Rolling Releases:

    https://wiki.archlinux.org/index.php/Meta_package_and_package_group

<h2>Package Groups and Metapackages</h2>
<p>
        A package that contains nothing but dependencies.
        When "installed", the effect is to install a group of packages.
</p>


Debian-specific virtual package: A faux target, only realized by other,
actual packages.  

A section from the Linux Mint User Guide (old)
https://www.linuxmint.com/documentation/user-guide/Cinnamon/english_18.0.pdf

Debian Recommends vs. Suggests ("Declaring relationships between packages")
https://www.debian.org/doc/debian-policy/ch-relationships.html

Other Package Managers:
    PIP:
    Cargo:

        Cross-platform packages:
                Great in theory, horrific in practice (See Torvald's quote).
    Snap
    Zero Install
    https://blog.linuxmint.com/?p=3766 (Critique of Snap)
    https://blog.linuxmint.com/?p=3906 (Chromium empty package) "In Linux Mint 20, APT will forbid snapd from getting installed.""
    From https://linuxmint-user-guide.readthedocs.io/en/latest/snap.html
           "The Snap Store, also known as the Ubuntu Store, is a commercial centralized software store operated by Canonical."
           Snap is unique in that it solves a problem that didn't actually exist:



    The UNIX Way:
        The <em>really</em> old guys, with <em>really</em> long beards
        just distribute source. a la Free BSD's <em>ports</em>
        Also, gentoo does takes this approach as-well.


Closing Remarks:

    https://docs.freebsd.org/en/books/handbook/ports/#ports-using
    Package Benefits

    A compressed package tarball is typically smaller than the compressed 
    tarball containing the source code for the application.
    Packages do not require compilation time. For large applications, such as 
    Mozilla, KDE, or GNOME, this can be important on a slow system.
    Packages do not require any understanding of the process involved in 
    compiling software on FreeBSD.


            Thanks for reading!
                Ecosystem
            Where to go from here? 
                Install Ubuntu 
                The Linux Command Line
                Arch Linux or Linux From Scratch

    Like if you looked at computing from outer space:
    https://tomaka.medium.com/the-future-of-operating-systems-efa31e17d66d
-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#packages">Packages</a></li>
        <li><a href="#building-from-source">Building from Source</a></li>
        <li><a href="#binary-packages">Binary Packages</a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Packages</h1>
    <p>
        In the author's opinion, Free Software works because
        people want to do it.
    </p>
</div>

<div class="content" id="packages">
    <h2>Packaging and Distributions </h2>
    <p>
        A <em>package</em> is a logical unit of software.
        The obvious example is a program, but libraries are packages, too.  
        Typically, packages are presented to the end user in precompiled form;
        more, they are usually installed by a utility program.
    </p>

    <p>
        The GNU GPL stipulates that licensed software be available in source-code
        form. The GNU-way of installing their stuff is:
    </p>

    <div class="code">
        $ ./configure &amp;&amp; make &amp;&amp; make install
    </div>

    <p>
        Each project uses its own language and build system; the above
        presupposes C/C++ source built via GNU's Autoconf.
        The traditional UNIX package format is a compressed tarball, a file 
        ending in <code>.tar.xz</code>, or <code>.tar.gzip</code>.
        One extracts such an archive with:
    </p>

    <div class="code">
        $ tar xf kernel-5.10.tar.xz
    </div>

    <p>
        yielding a directory reflective of its original packager's.
    </p>

    <p>
        Naturally, the system may be viewed as a collection of installed packages.
        More, intalling compiled software is merely a matter of copying files into
        appropriate directories.
    </p>

    <p>
        Packages are typically distributed in configured and compiled form.
        This yields a smaller archive, saves users from the
        time-consuming step of compilation, and allows complete automation of
        installation.
        The implication, however, is that each piece of software is preconfigured 
        for a particular operating system.  
        See your distribution's package management facilities for further information.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://linuxfromscratch.org/blfs/view/stable/introduction/notes-on-building.html">Notes on Building Software</a> - Beyond Linux From Scratch</a></li>
    </ul>
</div>

<div id="building-from-source" class="content">
    <h2>Building From Source</h2>

    <p>
        Linux From Scratch is not a distribution so much as 
        documentation regarding how to build a working GNU/Linux system entirely
        from source.
        One obtains each package in source-code form, configures, compiles and
        installs it by hand.
        While certainly not easy to do, it's not difficult, either; 
        a new version of the documentation is released about every six months.
    </p>

    <p>
        Stepping away from manual configuration and compilation,
        we arrive at the highly UNIX-y notion of 
        <a href="https://man.openbsd.org/ports.7">ports</a>.  
        A port is, in essence, a script that installs a package from source:
    </p>

    <blockquote>
        Each port contains any patches necessary to make the original application 
        source code compile and run on OpenBSD. Compiling an application is as simple 
        as typing <code>make</code> in the port directory! The Makefile automatically 
        fetches the application source code, either from a local disk or via HTTP, 
        unpacks it on the local system, applies the patches, and compiles it. 
        If all goes well, simply type <code>doas make install</code> to install the 
        application.
    </blockquote>

    <p>
        Gentoo Linux uses exactly this approach, and is sometimes referred to
        as a <em>metadistribution</em> owing to the lack of precompiled binaries and
        the system's resulting flexibility.
    </p>

    <h3> See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Ports_collection">Ports Collection</a> - Wikipedia</li>
    </ul>
</div>

<div id="binary-packages" class="content">
    <h2> Binary Packages </h2>

    <p>
        A distribution <em>proper</em>

    <p>
        Among major distributions, the Slackware Project entertains the 
        oldest, and possibly simplest, packaging scheme.
        By modern standards, it may be considered crude, 
        because it leaves dependency resolution to the user.<sup><a href="https://www.slackbook.org/html/package-management.html">[2]</a></sup>
        It is easily dissected, though, and so represents a nice jumping-off point.
    </p>

    <p>
        A Slackware package arrives to the user as a single compressed archive.
        In this file is a directory tree reflective of the Slackware operating
        system: 
    </p>

    <div class="code">
        $ tree slackware-vim-fake <br>
        . <br>
        ├── install <br>
        │   ├── doinst.sh <br>
        │   └── slack-desc <br>
        └── usr <br>
            &ensp;&ensp;&ensp;&ensp;├── bin <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;├── doc <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;├── COPYING <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;└── README <br>
            &ensp;&ensp;&ensp;&ensp;└── man <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── man1 <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── vim.1.gz
    </div>

    <p>
        To install the package, the files are 
        copied into the appropriate directories of the operating system;
        if a directory does not exist, it is created; 
        the <code>install</code> directory is ignored.
        After these files are copied, the script 
        <code>./install/doist.sh</code> is executed, if it exists.
    </p>

    <p>
        ...And that's it! 
    </p>

    <p>
        Installation is usually handled by a utility&mdash; in this case either
        <a href="https://www.slackbook.org/html/package-management-package-utilities.html"><code>installpkg</code> or <code>pkgtools</code></a>&mdash;
        which must be granted superuser priveledges.
        The archive is a <a href="https://en.wikipedia.org/wiki/Tar_(computing)">tarball</a>, courtesy of GNU's <code>tar</code>, 
        and compression upon the archive is, currently, 
        <a href="https://tukaani.org/xz/">Tukaani's</a> <code>xz</code>. 
    </p>

    <p>
        All major distributions package software using compressed archives
        of "reflective directory trees," though each to their own taste:
    </p>

    <ul>
        <li>
            Slackware <code>.txz</code>:
            <code>xz</code>-compressed tarball
        </li>

        <li>
            Fedora / Red Hat <code>.rpm</code>:
            A custom file format which contains four sections: Lead, signature, 
            header, and payload (<code>zstd</code>-compressed <code>cpio</code>
            archive).<sup><a href="https://en.wikipedia.org/wiki/RPM_Package_Manager#Binary_format">[3]</a></sup>
        </li>

        <li>
            Debian <code>.deb</code>: 
            An archive containing three files:
            <code>debian-binary</code>, denoting package format version number;
            <code>control.tar.xz</code>, serving a role analogous to <code>install</code> above; and
            <code>data.tar.xz</code>, the actual payload
        </li>

        <li>
            Arch:
            <code>zstd</code>-compressed tarball 
        </li>
    </ul>

    <p>
        Whil packages of the same program (e.g., <codde>vim</code>) may 
        be similar across distributions, they are not cross-distribution compatible.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Tar_(computing)">tar (computing) - Wikipedia </a></li>
    </ul>

</div>

<div class="content" id="metadata-and-payload">
    <h2 style="margin-bottom: 0;">Package Contents:</h2>
    <h4>Metadata and Payload</h4>

    <p>
        The contents of a package may be split into two 
        parts: Metadata and Payload.
        In Slackware's format, metadata is restricted to the <code>./install</code>
        directory, and consists of the post-copy script <code>doinst.sh</code>
        and a description of the software, <code>slack-desc</code>.
        Other package management schemes incorporate more metadata; here
        we'll take a look at Debian's, since it is more complete,
        and well-documented. 
    </p>

    <p>
        First, we obtain a package and extract it:
    </p>

    <div class="code">
        $ ls <br>
        vim_8.1.0875-5_amd64.deb <br>
        <br>
        $ ar -xf vim_8.1.0875-5_amd64.deb <br>
        <br>
        $ ls <br>
        control.tar.xz<br>
        data.tar.xz<br> 
        debian-binary<br>  
        vim_8.1.0875-5_amd64.deb 
    </div>

    <p>
        The package's metadata is found in the <code>control</code>
        archive, and the <code>debian-binary</code> file. 
        The payload is here referred to as <code>data</code>. 
        Both can be extracted with <code>tar</code>, but for now we'll just 
        take a peek:
    </p>

    <div class="code">
        $ tar --list -f control.tar.xz <br>
        ./ <br>
        <a href="./pre/control.html">./control</a> <br>
        <a href="./pre/md5sums.html">./md5sums </a><br>
        <a href="./pre/postinst.html">./postinst</a> <br>
        <a href="./pre/postrm.html">./postrm</a> <br>
        <a href="./pre/preinst.html">./preinst</a> <br>
        <a href="./pre/prerm.html">./prerm</a> <br>
    </div>

<p>
According to <a href="https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html">Debian</a>:
</p>

<ul>
        <li>
        The file <code>control</code> describes the package, giving its
        version number, a description of it, and other information about it.
        </li>

        <li>
        The file <code>md5sums</code> is a collection of hash signatures of
        files within the package.  These allow one to verify the 
        integrity of those files after they've been downloaded.
        </li>

        <li>
        The remaining files are scripts, called when installing or removing
        the package.
        For instance, when one uses <code>apt remove vim</code>, or
        <code>apt purge vim</code>, the
        <code>postrm</code> script is called with argument <em>remove</em>,
        or <em>purge</em>, as appropriate.

        Note that the <em>install</em> phase is the copying of files
        into the system directory tree, and that 
        <code>preinst</code> and <code>postinst</code>
        are called relative to that step.
        </li>
</ul>
</p>

    <p>
        For completeness, here is the <code>data</code> directory:
    </p>
        
    <div class="code">
        $ tree data<br>
        . <br>
        └── usr <br>
        ├── bin <br>
        │   └── vim.basic <br>
        └── share <br>
        ├── bug <br>
        │   └── vim <br>
        │       ├── presubj <br>
        │       └── script <br>
        ├── doc <br>
        │   └── vim <br>
        │       ├── changelog.Debian.gz <br>
        │       ├── changelog.gz <br>
        │       ├── copyright <br>
        │       └── NEWS.Debian.gz <br>
        └── lintian <br>
        └── overrides <br>
        └── vim <br>
        <br>
        9 directories, 9 files <br>
    </div>
</div>

<div class="content" id="package-managers">
        <h2> Package Managers </h2>

        <p>
        In layman's terms, a <em>package</em> is a program sans installation
        facilities.  
        Installation is instead handled by the <em>package manager.</em> 
        Further, a package may contain some universal or shared facilities:
        It may be a library, for instance.
        </p>

        <p>
        There are numerous reasons to prefer the package abstraction.
        Most notably, the system may be viewed as a <a href="http://www.slackware.com/releasenotes/packages14.2.php">collection</a> of installed packages.
        Other reasons include refactoring of code, centrality of administration,
        and ease of software location and installation.
        </p>

        <p>
        To update a machine running on Debian's packaging facilities, for example,
        we must simply run,
        </p>

        <div class="aside-right">
        <h4>Aside:</h4>
                <p>
                        See <code>$ apt --help</code>
                        and <code><a href="https://manpages.debian.org/buster/apt/apt.8.en.html">apt(8)</a></code> for more information
                </p>
        </div>

        <div class="code">
        $ sudo apt update <br>
        $ sudp apt upgrade 
        </div>

        <p>
        The first command, <code>update</code>, synchronizes <code>apt</code>'s 
        local package list with those of the configured repositories.  
        The second command downloads and installs any revised packages.
        This two-command sequence would install a new kernel 
        (via <a href="https://packages.debian.org/search?keywords=kernel-image&searchon=names&suite=stable&section=all">kernel-image</a>), for instance,
        and it would be used on the next reboot.
        </p>

</div>



<div class="content" id="dependencies">
    <h2>Dependencies</h2>
    <p>

https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html
    </p>
</div>



<div class="content" id="make">
    <h2>Closing Remarks:</h2>
    <h4><code>make</code></h4>

    <div class="aside-left">
    <h4>Aside:</h4>
    
        <p>
            An introduction to UNIX or UNIX-likes would not be complete without
            <code>make</code>!
        </p>
    </div>

    One expresses a program to be compiled in "recipes" of the form,

    hello: hello.c
        gcc -o hello hello.c 


    and stores them in a file named <code>Makefile</code>.
    Now, whenever a source file changes (in this example, <code>hello.c</code>), 
    the command <code>make hello</code> will recompile the program, 
    via <code>gcc -o hello hello.c</code>.
    

    Quite a novel little utility, and it is general in the sense that the files 
    in question need not be source/binary.
    However, 


    Kernighan:  p96
    Invented 1976, 7th ed UNIX
    "an instant success"

    "This approach replaces code with data, and that's almost always a win."


    https://en.wikipedia.org/wiki/Make_(software)
    Original Make was conceived and written over a weekend
    [It's rediculous to funnel such quantities of software through such a tool]
    <a href="https://en.wikipedia.org/wiki/GNU_Autotools#Components">obtuse to say the least</a>

</div>



<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> <i>Unix Programmer's Manual, First Edition.</i>  <a href="https://www.bell-labs.com/usr/dmr/www/1stEdman.html"> https://www.bell-labs.com/usr/dmr/www/1stEdman.html </a> </li>
        <li> WHATWG HTML Living Standard Section 1.6, History. <a href="https://html.spec.whatwg.org/multipage/introduction.html#history-2">https://html.spec.whatwg.org/multipage/introduction.html#history-2</a> </li>
    </ol>
</div>

