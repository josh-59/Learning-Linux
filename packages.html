---
layout: default
title: Packages and Package Management
last-updated: March 2021
---

<!--


    <div class="quote-text"
        "The key to learning what makes a Linux system work is to know what each package is used for and why you (or the system) may need it."
    </div>

    <div class="quote-ref">
        <a href="http://linuxfromscratch.org/lfs/view/stable/chapter08/introduction.html">Linux From Scratch</a>
    </div>

    Introduction:
    <p>
        In Linux, the idea of <em>installation</em> maps cleanly to 
        "copy files to appropriate directories."
    </p>

    

Rewrite as "Obtaining Free Software"

        Building From Source
                |
                |
                |
               \ /
        Ports / Gentoo's Portage
                |
                |
                |
               \ /
      Slackware's bare tarball 
                |
                |
                |
               \ /
          Arch's pacman
                |
                |
                |
               \ /
     Debian / Fedora / openSUSE
                |
                |
                |
               \ /
    Pip / Gems / Cargo / (JavaScript) NPM / SNAP


<div class="content" id="building-from-source">
<h2>Building From Source</h2>

<p>
Free software is typically intended to be distributed, and its developer
usually offers instructions for end-users to install it (typically, in a README file).
Each project will use its preferred language and toolchain; 
each of <em>Rust</em>, <em>Python</em>, <em>
in particular, GNU produces a lot of software, and
their <a href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html#Autotools-Introduction">build system</a> is fairly widely-used.
It <em>is intended for simplicity for the end user,</em> 
and not for simplicity for developers or maintainers.
</p>

To install GNU products from source, one enters its directory and issues:

$ ./configure && make && make install

<h3><code>make</code></h3>

<div class="aside-left">
<h4>Aside:</h4>

<p>
    An introduction to UNIX or UNIX-likes would not be complete without
    a digression to <code>make</code>!
</p>

One expresses a program to be compiled in "recipes" of the form,

hello: hello.c
    gcc -o hello hello.c 


and stores them in a file named <code>Makefile</code>.
Now, whenever a source file changes (in this example, <code>hello.c</code>), 
the command <code>make hello</code> will recompile the program, 
via <code>gcc -o hello hello.c</code>.


Quite a novel little utility, and it is general in the sense that the files in question
need not be source/binary.
However, 




Kernighan:  p96
Invented 1976, 7th ed UNIX
"an instant success"

"This approach replaces code with data, and that's almost always a win."


https://en.wikipedia.org/wiki/Make_(software)
Original Make was written over a weekend
    [It's rediculous to funnel such quantities of software through such a tool]
    <a href="https://en.wikipedia.org/wiki/GNU_Autotools#Components">obtuse to say the least</a>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://linuxfromscratch.org/blfs/view/stable/introduction/notes-on-building.html">Notes on Building Software</a> - Beyond Linux From Scratch</a></li>
    </ul>
</div>



Package Contents: Metadata and Payload
        Rewrite to use Arch Linux's packaging as example

    The contents of a package may be split into two 
        parts: Metadata and Payload.
        In Slackware's format, metadata is restricted to the <code>./install</code>
        directory, and consists of the post-copy script <code>doinst.sh</code>
        and a description of the software, <code>slack-desc</code>.
        Other package management schemes incorporate more metadata; here
        we'll take a look at Arch's, since it is more complete.
    </p>

    <p>
        First, we obtain a package and extract it:
    </p>

<div class="code">o.
        $ ls
        vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ tar xf vim-8.2.2489-1-aarch64.pkg.tar.xz &amp;&amp; rm vim-8.2.2489-1-aarch64.pkg.tar.xz
        $ ls -A
        .BUILDINFO  .MTREE  .PKGINFO  usr/ 
</div>

        
<p>
        The package's metadata are the hidden files in this directory:
        <code>.BUILDINFO</code>, <code>.MTREE</code>, <code>.PKGINFO</code>.
        The package's payload consists of the non-hidden files 
        (in this case, that is only <code>usr/</code>).
        Not present in this package is the <code>.INSTALL</code> file,
        an optional script which would be executed by the package manager.
</p>


Package managers:
    <div class="code">
        sudo apt install ./atom-amd64.deb
    </div>

    <p>
        That's it. There's nothing more to it.
    </p>

    Expressing the Operating System:
        Arch: base

        The system may be viewed as a collection of installed packages,
        and, the package manager could be viewed as a manager of the 
        operating system.


        This is how the Arch guys view packages: The system is viewed
        as a repository, and when new software is released, the local
        repository becomes out of sync with the upstream repository.
        "Upgrading" becomes a matter of synchronizing these repositories.  

        Thus, the software that composes a system defines the 
        operating system, and, 
        
    Repositories:
        Subsection?


        Some people think that rolling releases are 
        the future of Linux distributions
        <sup><a href="https://frontpagelinux.com/news/centos-crosses-streams-with-the-community/">[1]</a></sup>

        Debian Personal Package Archive
        https://itsfoss.com/ppa-guide/
        Arch User's Repository, AUR


    Rolling Releases:

    https://wiki.archlinux.org/index.php/Meta_package_and_package_group

<h2>Package Groups and Metapackages</h2>
<p>
        A package that contains nothing but dependencies.
        When "installed", the effect is to install a group of packages.
</p>

Debian-specific virtual package: A faux target, only realized by other,
actual packages.  

A section from the Linux Mint User Guide (old)
https://www.linuxmint.com/documentation/user-guide/Cinnamon/english_18.0.pdf

Debian Recommends vs. Suggests ("Declaring relationships between packages")
https://www.debian.org/doc/debian-policy/ch-relationships.html

Other Package Managers:
    PIP:
    Cargo:

        Cross-platform packages:
                Great in theory, horrific in practice (See Torvald's quote).
    Snap
    Zero Install
    https://blog.linuxmint.com/?p=3766 (Critique of Snap)
    https://blog.linuxmint.com/?p=3906 (Chromium empty package) "In Linux Mint 20, APT will forbid snapd from getting installed.""
    From https://linuxmint-user-guide.readthedocs.io/en/latest/snap.html
           "The Snap Store, also known as the Ubuntu Store, is a commercial centralized software store operated by Canonical."
           Snap is unique in that it solves a problem that didn't actually exist:



    The UNIX Way:
        The <em>really</em> old guys, with <em>really</em> long beards
        just distribute source. a la Free BSD's <em>ports</em>
        Also, gentoo does takes this approach as-well.


Closing Remarks:
        In layman's terms, a <em>package</em> is a program sans installation
        facilities.  
        Installation is handled by some other program (a utility).  
        Further, a package may contain some universal or shared facilities:
        It may be a library, for instance, or the kernel.

        Not mentioned here are the myriad of reasons to prefer the 
        abstract <em>package</em> and
        centralized management over per-program installation.


    https://docs.freebsd.org/en/books/handbook/ports/#ports-using
    Package Benefits

    A compressed package tarball is typically smaller than the compressed tarball containing the source code for the application.

    Packages do not require compilation time. For large applications, such as Mozilla, KDE, or GNOME, this can be important on a slow system.

    Packages do not require any understanding of the process involved in compiling software on FreeBSD.


            Thanks for reading!
                Ecosystem
            Where to go from here? 
                Install Ubuntu 
                The Linux Command Line
                Arch Linux or Linux From Scratch
-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#packages-intro"> Introduction to Packages </a></li>
        <li><a href="#metadata-and-payload"> Package Contents </a></li>
        <li><a href="#package-managers">Package Managers</a></li>
        <li><a href="#repositories"> Repositories </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Packages </h1>
    <h4>and Package Management</h4>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            Throughout this chapter, we will restrict our attention to binary 
            packages (programs).
        </p>
    </div>

    <p>
        A package is a file that contains the things 
        required to implement a program, a set of related programs,
        or a set of related features.<sup><a href="https://wiki.debian.org/Packaging/Intro">[1]</a></sup>
        They obviate the need to obtain
        source code, configure it, compile it and install the results by hand,
        and simplify software management greatly.<sup><a href="https://www.slackbook.org/html/package-management.html">[2]</a></sup>
        They are well-suited to automation by utility programs,
        and aid the distribution of software.
        Each Linux distribution handles packages in their own way.
    </p>
</div>

<div id="packages-intro" class="content">
    <h2> Introduction to Packages</h2>

    <p>
        Among major distributions, the Slackware Project entertains the 
        oldest, and possibly simplest, packaging scheme.
        By modern standards, it may be considered crude, 
        because it leaves dependency resolution to the user.<sup><a href="https://www.slackbook.org/html/package-management.html">[2]</a></sup>
        For us, it represents a nice jumping-off point.
    </p>

    <p>
        A Slackware package arrives to the user as a single compressed archive.
        In this file is a directory tree reflective of the Slackware operating
        system: 
    </p>

    <div class="code">
        $ tree slackware-vim-fake <br>
        . <br>
        ├── install <br>
        │   ├── doinst.sh <br>
        │   └── slack-desc <br>
        └── usr <br>
            &ensp;&ensp;&ensp;&ensp;├── bin <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;├── doc <br>
            &ensp;&ensp;&ensp;&ensp;│   └── vim <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;├── COPYING <br>
            &ensp;&ensp;&ensp;&ensp;│   &ensp;&ensp;&ensp;&ensp;└── README <br>
            &ensp;&ensp;&ensp;&ensp;└── man <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── man1 <br>
            &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;└── vim.1.gz
    </pre>
    </div>

    <p>
        To install the package, the files are 
        copied into the appropriate directories of the operating system;
        if a directory does not exist, it is created; 
        the <code>install</code> directory is ignored.
        After these files are copied, the script 
        <code>./install/doist.sh</code> is executed, if it exists.
    </p>

    <p>
        ...And that's it! 
    </p>

    <p>
        Installation is usually handled by a utility&mdash; in this case either
        <a href="https://www.slackbook.org/html/package-management-package-utilities.html"><code>installpkg</code> or <code>pkgtools</code></a>&mdash;
        which must be granted superuser priveledges.
        The archive is a <a href="https://en.wikipedia.org/wiki/Tar_(computing)">tarball</a>, courtesy of GNU's <code>tar</code>, 
        and compression upon the archive is, currently, 
        <a href="https://tukaani.org/xz/">Tukaani's</a> <code>xz</code>. 
    </p>

    <p>
        All major distributions package software using compressed archives
        of "reflective directory trees," though each to their own taste:
    </p>

    <ul>
        <li>
            Slackware <code>.txz</code>:
            <code>xz</code>-compressed tarball
        </li>

        <li>
            Fedora / Red Hat <code>.rpm</code>:
            A custom file format which contains four sections: Lead, signature, 
            header, and payload (<code>zstd</code>-compressed <code>cpio</code>
            archive).<sup><a href="https://en.wikipedia.org/wiki/RPM_Package_Manager#Binary_format">[3]</a></sup>
        </li>

        <li>
            Debian <code>.deb</code>: 
            An archive containing three files:
            <code>debian-binary</code>, denoting package format version number;
            <code>control.tar.xz</code>, serving a role analogous to <code>install</code> above; and
            <code>data.tar.xz</code>, the actual payload
        </li>

        <li>
            Arch:
            <code>zstd</code>-compressed tarball 
        </li>
    </ul>

    <p>
        Whil packages of the same program (e.g., <codde>vim</code>) may 
        be similar across distributions, they are not cross-distribution compatible.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Tar_(computing)">tar (computing) - Wikipedia </a></li>
    </ul>

</div>

<div class="content" id="metadata-and-payload">
    <h2 style="margin-bottom: 0;">Package Contents:</h2>
    <h4>Metadata and Payload</h4>

    <p>
        The contents of a package may be split into two 
        parts: Metadata and Payload.
        In Slackware's format, metadata is restricted to the <code>./install</code>
        directory, and consists of the post-copy script <code>doinst.sh</code>
        and a description of the software, <code>slack-desc</code>.
        Other package management schemes incorporate more metadata; here
        we'll take a look at Debian's, since it is more complete,
        and well-documented. 
    </p>

    <p>
        First, we obtain a package and extract it:
    </p>

    <div class="code">
        $ ls <br>
        vim_8.1.0875-5_amd64.deb <br>
        <br>
        $ ar -xf vim_8.1.0875-5_amd64.deb <br>
        <br>
        $ ls <br>
        control.tar.xz<br>
        data.tar.xz<br> 
        debian-binary<br>  
        vim_8.1.0875-5_amd64.deb 
    </div>

    <p>
        The package's metadata is found in the <code>control</code>
        archive, and the <code>debian-binary</code> file. 
        The payload is here referred to as <code>data</code>. 
        Both can be extracted with <code>tar</code>, but for now we'll just 
        take a peek:
    </p>

    <div class="code">
        $ tar --list -f control.tar.xz <br>
        ./ <br>
        <a href="./pre/control.html">./control</a> <br>
        <a href="./pre/md5sums.html">./md5sums </a><br>
        <a href="./pre/postinst.html">./postinst</a> <br>
        <a href="./pre/postrm.html">./postrm</a> <br>
        <a href="./pre/preinst.html">./preinst</a> <br>
        <a href="./pre/prerm.html">./prerm</a> <br>
    </div>

<p>
According to <a href="https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html">Debian</a>:
</p>

<ul>
        <li>
        The file <code>control</code> describes the package, giving its
        version number, a description of it, and other information about it.
        </li>

        <li>
        The file <code>md5sums</code> is a collection of hash signatures of
        files within the package.  These allow one to verify the 
        integrity of those files after they've been downloaded.
        </li>

        <li>
        The remaining files are scripts, called when installing or removing
        the package.
        For instance, when one uses <code>apt remove vim</code>, or
        <code>apt purge vim</code>, the
        <code>postrm</code> script is called with argument <em>remove</em>,
        or <em>purge</em>, as appropriate.

        Note that the <em>install</em> phase is the copying of files
        into the system directory tree, and that 
        <code>preinst</code> and <code>postinst</code>
        are called relative to that step.
        </li>
</ul>
</p>

    <p>
        For completeness, here is the <code>data</code> directory:
    </p>
        
    <div class="code">
        $ tree data<br>
        . <br>
        └── usr <br>
        ├── bin <br>
        │   └── vim.basic <br>
        └── share <br>
        ├── bug <br>
        │   └── vim <br>
        │       ├── presubj <br>
        │       └── script <br>
        ├── doc <br>
        │   └── vim <br>
        │       ├── changelog.Debian.gz <br>
        │       ├── changelog.gz <br>
        │       ├── copyright <br>
        │       └── NEWS.Debian.gz <br>
        └── lintian <br>
        └── overrides <br>
        └── vim <br>
        <br>
        9 directories, 9 files <br>
    </div>
</div>

<div class="content" id="package-managers">
        <h2> Package Managers </h2>

        <p>
        In layman's terms, a <em>package</em> is a program sans installation
        facilities.  
        Installation is instead handled by the <em>package manager.</em> 
        Further, a package may contain some universal or shared facilities:
        It may be a library, for instance.
        </p>

        <p>
        There are numerous reasons to prefer the package abstraction.
        Most notably, the system may be viewed as a collection of installed packages.
        Other reasons include refactoring of code, centrality of administration,
        and ease of software location and installation.
        </p>

        <p>
        To update a machine running on Debian's packaging facilities, for example,
        we must simply run,
        </p>

        <div class="aside-right">
        <h4>Aside:</h4>
                <p>
                        See <code>$ apt --help</code>
                        and <code><a href="https://manpages.debian.org/buster/apt/apt.8.en.html">apt(8)</a></code> for more information
                </p>
        </div>

        <div class="code">
        $ sudo apt update <br>
        $ sudp apt upgrade 
        </div>

        <p>
        The first command, <code>update</code>, synchronizes <code>apt</code>'s 
        local package list with those of the configured repositories.  
        The second command downloads and installs any revised packages.
        This two-command sequence would install a new kernel 
        (via <a href="https://packages.debian.org/search?keywords=kernel-image&searchon=names&suite=stable&section=all">kernel-image</a>), for instance,
        and it would be used on the next reboot.
        </p>

        <h3>Repositories</h3>

        <p>
        </p>

        <div class="code">
        </div>

        <p>
        </p>

        <div class="code">
        </div>

        <p>
        The above command will also work with 

        Repositories are listed locally at <code>/etc/apt/sources.list.d/</code>



</div>


<div class="content" id="dependencies">
    <h2>Dependencies</h2>
    <p>

https://www.debian.org/doc/manuals/debian-faq/pkg-basics.en.html
    </p>
</div>


<div class="content" id="repositories">
    <h2>Repositories</h2>
    <p>
        Collections of packages are called <em>repositories,</em> or
        sometimes, <em>archives.</em>
        A repository may be remote (the usual case), or it may be local
        (e.g., on a thumb-drive).
    </p>

    <p>
        A repository belonging to a large project, such as Debian's,
        is often mirrored by other organizations.
    </p>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> <i>Unix Programmer's Manual, First Edition.</i>  <a href="https://www.bell-labs.com/usr/dmr/www/1stEdman.html"> https://www.bell-labs.com/usr/dmr/www/1stEdman.html </a> </li>
        <li> WHATWG HTML Living Standard Section 1.6, History. <a href="https://html.spec.whatwg.org/multipage/introduction.html#history-2">https://html.spec.whatwg.org/multipage/introduction.html#history-2</a> </li>
    </ol>
</div>

