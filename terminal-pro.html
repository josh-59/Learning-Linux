---
layout: default
title: Terminal Pro
last-updated: February 2020
---

<!--


    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Most shells support "tab completion:"
            If you've typed enough of a command or filename to
            uniquely identify it, you can press "tab," and it will complete it for you.
        </p>
    </div>


    Variants of "which"
        $ type bash
        $ which bash
        $ file $(which bash)


    <div class="content" id="advanced-man">
        <h2>Advanced <code>man</code> Usage</h2>
        Utilities to figure things out:
            man
            whatis
            apropos manpath

        Random Useful Man Pages:
            <ul>
                <li> heir </li>
                <li> ascii </li>
                <li> elf </li>
            </ul>
    </div>

    <div class="content" id="redirection">
        <h2>Redirection</h2>

        <p>
            "Here documents"
            Pipes
        </p>
    </div>

    Command-Line Signals:
        Ctrl-c sends the interrupt signal, SIGINT, which most programs respond
        to by terminating immediately.  Handy for killing an unresponsive
        foreground process.

        Ctrl-c is handled by the shell in a different manner: It stops what
        it's doing and returns control to the main loop, presenting the
        user with a new prompt (Kerrisk, p389)
        Some people use this rather than backspacing an erroeous line
    
    Copying and Pasting
        The desktop's familiar copy/paste is overruled on the terminal 
        emulator (ctrl-v is interpretted as an escape sequence); 
        use either ctrl-shift-v or middle-click to paste.
    
Closing Remarks:
    Further Advanced Tools
    AWK
    Awk handles strings of characters as conveniently as most languages handle numbers.

Text Editor: vim
    These controls have made their way into many other programs: man, git, less.
    In fact, even Firefox lets you 'Quick Search' a web page with <code>/</code>.
    Once you are (well) familiar with them, you can set Bash to vi-mode with
    <code>set -o vi</code>.

    Explanation of sudo:
    https://www.linuxjournal.com/sites/default/files/2018-11/GeekGuide-BeyondTrust-BeyondSudo.pdf

Exercises:
    <ol>
        <li>
            Explain the behavior of:
            $ PATH="" printenv
        </li>
        <li>
            The shell is a process, like any other.
            For your current shell:
            <ol>
                <li>What was its command-line arguments</li>
                <li>
            </ol>
        </li>
        <li>
            Let <code>script</code> be an executable file containing
            #!/bin/sh
            echo hello world
            There are three ways to execute this command:
            1) In the current shell context
            2) In a forked subshell context
            3) In an <code>exec</code>-induced sh context
            Produce each, and verify with <code>strace</code>
        </li>
    </ol>
-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
		<li><a href="#model"> Shell Execution Model </a></li>
        <li><a href="#shell-expansion">Shell Expansion</a></li>
		<li><a href="#redirection">I/O Redirection</a></li>
		<!--
		<li><a href="#shell-features"> Other Shell Features </a></li>
        <li><a href="#special-characters">Terminal Special Characters</a></li>
        -->
        <li><a href="#finding-files">Finding Files</a></li>
        <!--<li><a href="#references"> References </a></li>-->
	</ul>
</div>

<div class="content" id="introduction">
    <h1>Terminal Pro</h1>
    <!-- Advanced Terminalistics-->

    <p>
        This
        
    </p>

</div>

<div class="content" id="model">
	<h2>Shell Execution Model</h2>

    <p>
        In <em>The Evolution of the Unix Time-Sharing System,</em>
        Dennis Ritchie summarizes shell behavior:<sup><a href="http://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf">[1]</a></sup>
    </p>


    <blockquote style="background-color: #f9f9f9;
                    border: 2px solid #ddd;
                    padding: 5px;">
 Today, the way in which commands are executed by the shell can be summarized as follows:
        <ol> 
            <li> The shell reads a command line from the terminal. </li>
            <li> It creates a child process by fork.</li>
            <li> The child process uses exec to call in the command from a file. </li>
            <li> Meanwhile, the parent shell uses wait to wait for the child (command) process to terminate by calling exit. </li>
            <li> The parent shell goes back to step </li>
        </ol>
    </blockquote>

    <p>

    </p>



	<a href="assets/img/shell-model.pdf" title="Click for PDF">
		<img src="assets/img/shell-model-pic.png" style="height: 400pt;">
	</a>


    <p>
        All shell behavior may be understood within the context of this
        model, though it is not complete.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Operation.html">Shell Operation (Bash Reference Manual)</a></li>
    </ul>

</div>

<div class="content" id="finding-files">
    <h2>Finding Files</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Remember: <br>
            <code> fd what where </code>
        </p>
    </div>

    <p>
        The <a href="https://github.com/sharkdp/fd">fd</a>
        utility is a simple, user-friendly alternative to
        <a href="http://www.gnu.org/software/findutils/">find</a>.
        Usage:
    </p>

    <div class="code">
        $ fd [pattern] [path ...]
    </div>

    <p>
        Where <em>pattern</em> is a regular expression, and
        <em>path</em> is the directory you'd like to start looking in.
        It searches there, and then it searches recursively downward through
        the directory tree which started there.
        For each file, it attempts to match its basename against <em>pattern.</em>
        If it matches, it then prints the name of the file.
    </p>

    <p>
        By default, <code>fd</code> checks filenames, but it can check any other
        file characteristic, as well.
        For instance, to restrict results to directories, we could use
    </p>

    <div class="code">
        $ fd --type d [pattern] [path ...]
    </div>

    <p>
        For a few reasons, I recommend <code>fd</code> over the classic
        GNU Findutils:
    </p>

    <ol style="margin-left: 5%; padding-right: 10%;">
        <li>
            <p>
                Only one utility to learn.
                In practice, <code>fd</code> replaces both <code>find</code>
                and <code>locate</code>.
                Specifically, it's fast and friendly enough that there's no longer
                a need for <em>locate</em>.
            </p>
        </li>
        <li>
            <p>
                Ameniable defaults.
                <code>fd</code> matches only basenames, and thereby avoids printing
                pages of results.
                More, it does not require a flag to search for filenames.
            </p>
        </li>
        <li>
            <p>
                Regex by default.
                Regex is a more powerful and expressive string-matching language
                than shell globbing.
            </p>
        </li>
        <li>
            <p>
                Simpler in Construction.
                No database to worry about.
            </p>
        </li>
    </ol>

    <h3>Searching Files with <code>rg</code></h3>
    <p>
        The <a href="https://github.com/BurntSushi/ripgrep"><code>rg</code></a>
        utility recursively descends through a directory tree,
        opens each file, reads its contents and attempts to
        match each line against a given regex pattern.
        If a line contains a match, then it prints the filename and those lines;
        effectively, it searches files for a particular pattern.
	</p>

	<p>
        Its simplest usage is:
    </p>

    <div class="code">
        $ rg <i>pattern</i> [path ...]
    </div>

    <p>
        This, again, is a reimagining of a classic UNIX utility&mdash;
        in this case, the venerable
        <em><a href="https://en.wikipedia.org/wiki/Grep">grep</a></em>.
        It's mostly just easier to use.
    </p>

    <p>
        Your primary documentation for regex is <a href="https://docs.rs/regex/1.4.3/regex/#syntax">here</a>. Trust me on this.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://github.com/sharkdp/fd">fd</a></li>
        <li><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></li>
        <li><a href="https://docs.rs/regex/1.4.3/regex/#syntax">Regex - Rust</a></li>
    </ul>
</div>
