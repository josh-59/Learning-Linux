---
layout: default
title: Terminal Pro
last-updated: February 2020
---

<!--

    Shell Execution Model:

    Also, program <code>explain</code>, implementing this in a how-it-works sorta way


Basic Bash Grammar:
        Pipeline and Lists
    Shell scripting:
        https://medium.com/better-programming/the-ultimate-programmers-guide-to-bash-scripting-2d11d4e6e978
        help for
        help if
        help [[

        https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html#index-parameters
        variable=[value]
            [value] undergoes tilde expansion, parameter and variable expansion,
            command substitution, arithmetic expansion, and quote removal;
            does not undergo filename expansion

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>

            Most shells support <em>tab completion:</em>
            If you've typed enough of a command-name or filename to
            uniquely identify it, you can press "tab," and it will complete it for you.
        </p>
    </div>





-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
		<li><a href="#model"> Shell Execution Model </a></li>
        <li><a href="#shell-expansion">Shell Expansion</a></li>
		<li><a href="#redirection">I/O Redirection</a></li>
		<!--
		<li><a href="#shell-features"> Other Shell Features </a></li>
        <li><a href="#special-characters">Terminal Special Characters</a></li>
        -->
        <li><a href="#finding-files">Finding Files</a></li>
        <!--<li><a href="#references"> References </a></li>-->
	</ul>
</div>

<div class="content" id="introduction">
    <h1>Terminal Pro</h1>

    <p>
        The command-line interface persists because it is a 
        powerful means of interacting with the machine. 
        Here we will discuss some particulars of shell behavior, and
        introduce useful tools.
    </p>

</div>

<div class="content" id="model">
	<h2>Shell Execution Model</h2>

    <p>
        In <em>The Evolution of the Unix Time-Sharing System,</em>
        Dennis Ritchie summarizes shell behavior:<sup><a href="http://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf">[1]</a></sup>
    </p>


    <blockquote style="background-color: #f9f9f9;
                    border: 2px solid #ddd;
                    padding: 5px;">
 Today, the way in which commands are executed by the shell can be summarized as follows:
        <ol> 
            <li> The shell reads a command line from the terminal. </li>
            <li> It creates a child process by fork.</li>
            <li> The child process uses exec to call in the command from a file. </li>
            <li> Meanwhile, the parent shell uses wait to wait for the child (command) process to terminate by calling exit. </li>
            <li> The parent shell goes back to step </li>
        </ol>
    </blockquote>

    <p>

    </p>



	<a href="assets/img/shell-model.pdf" title="Click for PDF">
		<img src="assets/img/shell-model-pic.png" style="height: 400pt;">
	</a>


    <p>
        All shell behavior may be understood within the context of this
        model, though it is not complete.
    </p>

</div>

    <!--

    Terminal Pro:
        fork'ed == subshell environment
        $ type bash
        $ which bash


        $ file $(which bash)




Command-Line Signals:
    Ctrl-c sends the interrupt signal, SIGINT, which most programs respond
    to by terminating immediately.  Handy for killing an unresponsive
    foreground process.

    Ctrl-c is handled by the shell in a different manner: It stops what
    it's doing and returns control to the main loop, presenting the
    user with a new prompt (Kerrisk, p389)
    Some people use this rather than backspacing an erroeous line

    The desktop's familiar copy/paste is overruled on the terminal
    emulator (ctrl-v is interpretted as an escape sequence);
    use either ctrl-shift-v or middle-click to paste.

Text Editor: vim

    These controls have made their way into many other programs: man, git, less.
    In fact, even Firefox lets you 'Quick Search' a web page with <code>/</code>.
    Once you are (well) familiar with them, you can set Bash to vi-mode with
    <code>set -o vi</code>.

    Explanation of sudo:
    https://www.linuxjournal.com/sites/default/files/2018-11/GeekGuide-BeyondTrust-BeyondSudo.pdf



Advanced Redirection:
        "Here documents"

        Pipes




Startup:
    .bash_profile vs .bashrc (see Linux from scratch section 4.4)

Closing Remarks:
    AWK
    "Awk handles strings of characters as conveniently as most languages handle numbers."

Exercises:
    <ol>
        <li>
            Explain the behavior of:
            $ PATH="" printenv
        </li>
        <li>
            The shell is a process, like any other.
            For your current shell:
            <ol>
                <li>What was its command-line arguments</li>
                <li>
            </ol>
        </li>
        <li>
            Let <code>script</code> be an executable file containing
            #!/bin/sh
            echo hello world
            There are three ways to execute this command:
            1) In the current shell context
            2) In a forked subshell context
            3) In an <code>exec</code>-induced sh context
            Produce each, and verify with <code>strace</code>
        </li>
    </ol>
-->

</div>


</div>






<div class="content" id="shell-expansion">
    <h2 style="margin-bottom: 0;">Shell Expansion</h2>
    <h4>and Quote Removal</h4>

    <p>
        After <a href="terminals-and-shells.html#simple-commands">word splitting</a>
        the next step on the journey of command execution is <em>shell
        expansion.</em>
        Bash searches each word, from left to right, in two consequetive passes.
        If a word is single-quoted, then it is exempt from expansion.
    </p>

    <p>
        The first pass searches for:
    </p>

    <ol>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html">Braces</a>&emsp; <code>{}</code>
            <br>
            <code>a{1,2,3}b</code> becomes <code>a1b a2b a3b</code>
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html">Tilde</a>&emsp;  <code>~</code>
            <br>
            Expands to the absolute pathname of your home directory, or
            <code>HOME</code> parameter, if it is set.
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">Parameter</a> &emsp;  <code>$</code>
            <br>
            <code>$NAME</code> is replaced by the value of <code>NAME</code>
            parameter, if it exists, and null string otherwise.
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html">Command</a> &emsp;  <code>$( </code><em>command</em><code> )</code>
            <br>
            Executes <em>command</em> in a subshell environment, captures output
            and replaces <br> <code>$(</code><em>command</em><code>)</code>
            with said output
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html">Arithmetic</a>&emsp;  <code>$(( </code><em>expression</em><code>  ))</code>
            <br>
            Evaluates <em>expression</em> and replaces <code>$((</code><em>expression</em><code>))</code> with result

        </li>
    </ol>

    <p>
        Expansions can be understood through prodigious use of the
        <code>echo</code> command, which simply prints out whatever arguments
        it recieves.
        For instance, in the following example, the <code>echo</code> command
        recieves exactly two arguments, <code>12</code> and <code>13</code>,
        and it is the shell that has done the work:
    </p>

    <div class="code">
        $ echo 1{2,3}<br>
        12 13
    </div>

    <h3 id="globbing"> Filename Expansion </h3>

    <p>
        The second expansion pass is <em>filename expansion,</em> sometimes
        referred to as <em>globbing.</em>
        These expansions let you manipulate multiple files quickly.
        If any word contains an asterisk <code>*</code>, question mark
        <code>?</code>, or brackets <code>[]</code>, then it is regarded as a
        <em>pattern,</em> and is replaced by an alphabetical list of all
        filenames in the current directory matching that pattern.
    </p>

    <p>
        The meanings of these metacharacters are as follows:
    </p>

    <ul style="list-style-type: none;">
        <li>
            <code>*</code>&emsp; Asterisk.  Matches zero-or-more of any character.
        </li>

        <li>
            <code>?</code>&emsp; Question Mark.  Matches zero-or-one of any character.
        </li>

        <li>
            <code>[ ]</code>&emsp; Brackets.  Matches exactly one of any of the characters contained.
        </li>
    </ul>

    <p>
        In patterns, all other characters are treated literally.
        For example,
    </p>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            By default, hidden files must be matched explicitly.
        </p>
    </div>

    <div class="code">
        *
    </div>

    <p>
        expands to all files in the current directory.
    </p>

    <div class="code">
        *.pdf
    </div>

    <p>
        expands to all files ending in <code>.pdf</code>; and,
    </p>

    <div class="code">
        *.[gx]z
    </div>

    <p>
        expands to all files ending in either <code>.xz</code> or <code>.gz</code>.
    </p>

    <p>
        After these steps have been completed, Bash removes unquoted
        quotes, and prepares to execute the command.
    </p>

  <h3> See Also: </h3>
  <ul>
    <li><a href="http://mywiki.wooledge.org/glob"> glob - Greg's Wiki </a></li>
  </ul>
</div>

<div id="redirection" class="content">
	<h2 style="margin-bottom: 0;">I/O Redirection</h2>
    <h4> and Standard File Descriptors</h4>


	<p>
        In interactive use, the shell is connected to its terminal
        by
        <a href="./processes.html#standard-file-descriptors">three open files</a>.
        The first file, <code>STDIN</code>, is the keyboard.
        When <code>bash</code> is waiting for you to enter a new command,
        it's actually asked the kernel to
        read a line from this file, and the kernel has
        paused execution of <code>bash</code> until a line is
        available (a line is available once you hit enter).
        The second and third open files,
        <code>STDOUT</code> and <code>STDERR</code>, are the terminal
        screen: Whenever <code>bash</code> wants to print something out,
        it writes characters to one of these files.
    </p>

    <p>
	    Recall that each process created by the <code>fork</code> system
        call <a href="processes.html#process-creation">inherits</a>
        its parent's attributes, and that these attributes
        include file descriptors (open files).
        This means that we, the users, can reasonably expect each
        child of <code>bash</code> to have our keyboard present at
        <code>STDIN</code> and our terminal screen at both
        <code>STDOUT</code> and <code>STDERR</code>.
    </p>

    <p>
        In interactive use, this is typically what we want, and
        means that our command,
    </p>

    <div class="code">
        $ ls
    </div>

    <p>
        will inherit the terminal as primary I/O, and thereby
        print to the terminal screen.
    </p>

    <h3> Redirection </h3>

    <p>
        Redirection is the act of assigning a different file to the standard
        file descriptors before executing a command.
        Let's start with input.
    </p>

    <ul style="list-style-type: none;">
        <li> <code> command &lt; file </code> &emsp; Open <code>file</code>
            for reading,
            assign to <code>STDIN</code>, then execute <code>command</code></li>
    </ul>

    <p>
        This removes the keyboard from <code>STDIN</code> and replaces it with
        <code>file</code>; the command is no longer interactive, but will
        still print output to the terminal.
        This can be useful for scripting: Rather than
        repeatedly entering the same sequence of input multiple times,
        just save said input to a file and redirect.
    </p>

    <p>
        Here, as in all redirections, <code>command</code> is oblivious.
        Redirection is shell functionality, and <code>bash</code>
        remaps the appropriate open files before execution takes place.
        More, <code>command</code> does not recieve <code>&lt; file</code>
        as arguments; <code>bash</code> removes them after
        the changes have been made.
    </p>

    <p>
        To redirect output:
    </p>

    <ul style="list-style-type: none;">
        <li> <code> command &gt; file </code> &emsp; Open <code>file</code>
            for writing; set length to zero; assign to <code>STDOUT</code>.
            Then search for command.</li>
        <li> <code> command &gt;&gt; file </code> &emsp; Open <code>file</code>
            for writing; seek to end; assign to <code>STDOUT</code>.
            Then search for command.</li>
    </ul>

    <p>
        Since <code>STDERR</code> has been left unchanged, errors will
        still be printed to our terminal screen.
    </p>

    <p>
        Redirection can become quite involved.
        It is possible to redirect <code>STDERR</code>,
        to open a file and assign it an arbitrary file descriptor,
        to copy the assignment of a file descriptor,
        and to close an arbitrary file descriptor.
        All of this occurs within <code>bash</code>, after shell expansion
        and forking, and before it begins searching for the command.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.bash-hackers.org/syntax/redirection">Redirection - Bash Hackers Wiki</a></li>
        <li><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html"> Redirections - Bash Reference Manual</a></li>
    </ul>

</div>

<div class="content" id="finding-files">
    <h2>Finding Files</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Remember: <br>
            <code> fd what where </code>
        </p>
    </div>

    <p>
        The <a href="https://github.com/sharkdp/fd">fd</a>
        utility is a simple, user-friendly alternative to
        <a href="http://www.gnu.org/software/findutils/">find</a>.
        Usage:
    </p>

    <div class="code">
        $ fd [pattern] [path ...]
    </div>

    <p>
        Where <em>pattern</em> is a regular expression, and
        <em>path</em> is the directory you'd like to start looking in.
        It searches there, and then it searches recursively downward through
        the directory tree which started there.
        For each file, it attempts to match its basename against <em>pattern.</em>
        If it matches, it then prints the name of the file.
    </p>

    <p>
        By default, <code>fd</code> checks filenames, but it can check any other
        file characteristic, as well.
        For instance, to restrict results to directories, we could use
    </p>

    <div class="code">
        $ fd --type d [pattern] [path ...]
    </div>

    <p>
        For a few reasons, I recommend <code>fd</code> over the classic
        GNU Findutils:
    </p>

    <ol style="margin-left: 5%; padding-right: 10%;">
        <li>
            <p>
                Only one utility to learn.
                In practice, <code>fd</code> replaces both <code>find</code>
                and <code>locate</code>.
                Specifically, it's fast and friendly enough that there's no longer
                a need for <em>locate</em>.
            </p>
        </li>
        <li>
            <p>
                Ameniable defaults.
                <code>fd</code> matches only basenames, and thereby avoids printing
                pages of results.
                More, it does not require a flag to search for filenames.
            </p>
        </li>
        <li>
            <p>
                Regex by default.
                Regex is a more powerful and expressive string-matching language
                than shell globbing.
            </p>
        </li>
        <li>
            <p>
                Simpler in Construction.
                No database to worry about.
            </p>
        </li>
    </ol>

    <h3>Searching Files with <code>rg</code></h3>
    <p>
        The <a href="https://github.com/BurntSushi/ripgrep"><code>rg</code></a>
        utility recursively descends through a directory tree,
        opens each file, reads its contents and attempts to
        match each line against a given regex pattern.
        If a line contains a match, then it prints the filename and those lines;
        effectively, it searches files for a particular pattern.
	</p>

	<p>
        Its simplest usage is:
    </p>

    <div class="code">
        $ rg <i>pattern</i> [path ...]
    </div>

    <p>
        This, again, is a reimagining of a classic UNIX utility&mdash;
        in this case, the venerable
        <em><a href="https://en.wikipedia.org/wiki/Grep">grep</a></em>.
        It's mostly just easier to use.
    </p>

    <p>
        Your primary documentation for regex is <a href="https://docs.rs/regex/1.4.3/regex/#syntax">here</a>. Trust me on this.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://github.com/sharkdp/fd">fd</a></li>
        <li><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></li>
        <li><a href="https://docs.rs/regex/1.4.3/regex/#syntax">Regex - Rust</a></li>
    </ul>
</div>
