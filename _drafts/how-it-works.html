---
layout: default
title: How Open Source Works
last-updated: March 2021
---

<!--

    Community-Driven vs. ...?
        

    Classic Business Model:
        Red Hat Enterprise Linux
        Cannonical

    Offset-with-Open-Source Model:
        PINE-64, 

    Radio Station Model:
        Like a radio station, they accept donations from users and sponsors,  
        and generate revenue from search-engine 
        traffic<sup><a href="http://web.archive.org/web/20150409023855/http://www.techworld.com.au/article/529572/q_clement_lefebvre_man_behind_linux_mint/">[a]</a></sup>
-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#fork-merge">Fork/Merge</a></li>
        <li><a href="#train-schedules">Train Schedules</a></li>
        <li><a href="#bazaar">Bazaar Development Model</a></li>
        <li><a href="#unix-philosophy">The UNIX Philosophy</a></li>
        <li><a href="#bryan-cantrill"> Bryan Cantrill </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>


<div id="introduction" class="content">
    <h1>How Open Source Works</h1>

    <p>
        So what makes it all tick?
        In this dramatic conclusion, we'll pick apart the characteristic
        features of the open-source ecosystem, from the mechanics
        of contributing, to the underlying motivations of its members.
        Hope you enjoyed!
    </p>
</div>

<div id="fork-merge" class="content">
    <h2>Fork/Merge</h2>

    <p>
        Recall that a repository is tracked collection of files,
        usually containing a package.
        Open-source repositories are made publicly available, and anyone
        may download or otherwise copy them.
        Such a copy is called a <em>fork.</em> 
    </p>

    <p>
        Having created a fork, the software is now *yours*.
        You can modify it, inspect it, install it, 
        discard it&mdash; whatever you want.
        If you want to contribute to the project, though, you would naturally
        edit some of the files within your copy.  
    </p>

    <p>
        Having done so, we say that your copy and the source have <em>diverged.</em>
    </p>

    <p>
        Having endeavored to contribute to the project, your next step is
        to request your changes be <em>merged</em> with the original.
        This is done through a <em>pull request.</em>
        In practice, a pull request initiates a discussion about
        the proposed changes; if accepted, the changes are made to the original,
        and the two repositories are identical again.
    </p>

    <p>
        This pattern repeats at various scales. 
        Using <code>git</code> or <code>subversion</code>, it is 
        possible to create distinct branches within your local repository,
        and merge or abandon changes as you see fit.
        At the macro scale, we saw this pattern repeat with GNU's compiler 
        collection, when a fork became a concurrent project, and was eventually merged
        into GNU's main trunk. https://en.wikipedia.org/wiki/GNU_Compiler_Collection#EGCS_fork
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://opensource.guide/"> Open Source Guide</a></li>
    </ul>
</div>

https://en.wikibooks.org/wiki/FOSS_A_General_Introduction/Introduction

<div class="content" id="train-schedules">
    <h2>  Train Schedules </h2>

    <p>
        Open-source software development is fundamentally reiterative:
        You build something, publish it, improve it, then re-release it.
        "Train scheduling" is a method commonly adopted to add structure 
        to this: They put the cycle on a schedule.
        It is used to enormous effect by Mozilla, to provide
        "stability without stagnation."<sup><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">[6]</a></sup>
    </p>

    <p>
        A new Firefox version is scheduled for release every four weeks.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[7]</a></sup>
    </p>

    <figure>
        <img src="assets/img/train-schedules.png" style="width: 100%;">
    </figure>

    <p>
        That is, each version spends four weeks in the <em>Mature</em> category,
        being the officially-supported, current version of Firefox.
        When here, no new features are implemented&mdash; rather, only 
        security patches and bug-fixes are implemented and pushed to the user.
        After its four weeks in the spotlight, it is discarded, 
        for the next version is ready.
    </p>

    <p>
        Before it becomes mature, each version of Firefox has been released as a <a href="https://www.mozilla.org/en-US/firefox/80.0beta/releasenotes/">beta</a>;
        this status corresponds to <em>Initial Release</em> above.
        When a release enters the <em>Beta</em> stage, only patches aimed at improving
        stability are accepted.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[6]</a></sup>
        Each release spends four weeks there.
        Finally, there is the <a href="https://www.mozilla.org/en-US/firefox/80.0a1/releasenotes/">Nightly</a> build,
        which contains the latest (and most untested) features.
    </p>

    <p>
        Here we see that <em>Firefox 80</em> will be released as <em>Firefox 81</em>
        enters Beta and <em>Firefox 82</em> enters Nightly:
    </p>

    <figure>
        <a href="https://wiki.mozilla.org/Release_Management/Calendar">
            <img src="assets/img/firefox-train-schedule.png" style="width: 90%; padding-bottom: 10pt;">
        </a>
        <figcaption><center><b><a href="https://wiki.mozilla.org/Release_Management/Calendar">Firefox Release Schedule</a></b></center></figcaption>
    </figure>

    <p>
        The train schedule is often adopted by larger projects to help cope with,
        potentially, thousands of merges each month.
        For instance, it is a common (though fading) practice for distributions
        to offer a new official release every six months.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://blog.rust-lang.org/2014/10/30/Stability.html"> Stability as a Deliverable | Rust Blog</a></li>
        <li><a href="http://thinking-in-code.blogspot.com/2010/07/train-model-of-software-development.html"> Thinking in Code: Train Model of Software Development</a></li>
    </ul>
</div>

<div class="content" id="bazaar">
    <h2>The Bazaar Development Model</h2>

    <p>
        <strike>A collection of open-source projects is 
        called a <em>bazaar.</em></strike>
        The term <em>bazaar</em> was first used by Raymond
        to describe the Linux development model&mdash; "release early and often,
        be open to the point of promiscuity, delegate everything in sight"&mdash; 
        which he contrasted with the "cathedral"-style development model of the time. 
    </p>

    <p>
        In the cathedral development model, software is openly available,
        sure, but is developed principally in-house; the above
        remarks on forking and merging effectively don't apply.
        The cathedral has its proponents (namely, all of BSD's);
        they argue that a traditional model affords greater opportunity for
        design and craftsmanship, important considerations when considering
        the magnitude of these endeavors.
        <!-- Mention OpenBSD's focus on security-->
    </p>

    <p>
        It is rightfully GNU/Linux, and I can't help but agree that each
        significant open-source project requires some central authority.
        The question is, how do <em>we</em> do it?
    </p>

    <h3> Benevolent Dictator for Life </h3>

    <p>
        In the case of Linux, it is Linus Torvalds, original proprieter.
        For example, Linus Torvalds is the <em>BDFL</em> of Linux.

    </p>

    <p>
    Conveniently, a who's-who of the open-source community:
https://en.wikipedia.org/wiki/Benevolent_dictator_for_life#Referent_candidates
    </p>


    "Open source democracy doesn't work."&mdash; Brian Camprill

        
<!--
    <p>
        If a solution to this situation exists, then it rests in developing 
        open-source programming tools, and collections of free assets,
        which significantly reduce the time
        required to yield a playable game&mdash; e.g.
        <a href="https://godotengine.org">Godot Game Engine</a>.
    </p>

    <p>
         Whether this development model is best or not is a 
         <a href="https://queue.acm.org/detail.cfm?id=2349257">subject of
         debate</a>, but there can be no doubt that it has been successful:
         GNU/Linux is the most-used Unix-like 
         operating system in existence today.
         I view these pieces as "competing", expect the best of
         them to rise in popularity, and let someone else worry about
         fitting them all together.
    </p>

</div>


<div class="content" id="unix-philosophy">
    <h2><strike>Modularity</strike></h2>
    <h2>The Unix Philosophy</h2>

    <p>
        GNU/Linux can be likened to a 1000-piece puzzle with 5000 available pieces: 
        For any piece of the puzzle&mdash; shell, desktop environment,
        <em>init</em> system, right down to C libraries&mdash; there are, I'd 
        guess, five competent options to choose from.
    </p>



Modularity:
    Key to good software anyways
    Open Source Architecture
    Notepad++ built upon the "scintilla editor component"
    https://en.wikipedia.org/wiki/Scintilla_(software)

    Kernel drivers

    systemd is a collection of cooperating processes
    as is xfce https://www.xfce.org/about


In Proprietary Land: CClang
https://en.wikipedia.org/wiki/Clang
Its contributors include Apple, Microsoft, Google, ARM, Sony, 
Intel and Advanced Micro Devices (AMD). It is open-source 
software,[10] with source code released under the University of Illinois/NCSA 
License, a permissive free software licence. Since v9.0.0, it was relicensed to 
the Apache License 2.0 with LLVM Exceptions.[4]
o






<div class="content" id="closing-remakrs">
    <h2>Closing Remarks:</h2>
    
    <p>
        The crux of open-source is <em>sharing,</em> not gifting.
        "Software is not like material objects," says 
        Richard Stallman.  "It can be copied easily, cheaply..." (Check this)
    </p>

    <p>
        Free software persists.
        It is cheap to store, present, and offer.
        For this reason alone, I found it worth studying.
    </p>

    <p>
        The principal investment is time, and when a non-profit organization
        endeavors to build free software, their principle concern is paying
        their employees, not making money.
    </p>

    <p>
        The skills required are nontrivial.
        The brilliant minds of Bell Labs were, prinicipally, mathematicians;
        each held a Ph.D. in their respective field.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.linuxcommand.org/tlcl.php">The Linux Command Line</a> by William Shotts</li>
    </ul>
</div>

<div class="content" id="bryan-cantrill">
    <h2>Bryan Cantrill: Rust and Other Interesting Things</h2>
    <iframe class="video" src="https://www.youtube.com/embed/2wZ1pCpJUIM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from <a href="https://wiki.osdev.org/Required_Knowledge">https://wiki.osdev.org/Required_Knowledge</a></li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
        <li>Turon, A., &amp; Matsakis, N. (2014, October 30).  Stability as a Deliverable:  Rust Blog.  Retrieved August 18, 2020, from
            <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">https://blog.rust-lang.org/2014/10/30/Stability.html</a></li>
        <li> The Firefox release process. (n.d.). Retrieved August 18, 2020, from <a href="https://wiki.mozilla.org/Release_Management/Release_Process">https://wiki.mozilla.org/Release_Management/Release_Process</a></li>
    </ol>
</div>
