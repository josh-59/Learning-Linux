Rust represents a major advancement in production programming languages because of its success in bridgingthe gap betweenhigh-levelapplication programming andlow-levelsystems programming.
http://www.ccs.neu.edu/home/amal/papers/rustdistilled.pdf

<h2> Expressive </h2>
<p>
    Rust is an expressive language.  That means:
</p>

    <ol>
        <li>It's enormous</li>
        <li>(Optionally) Everything is an expression</li>
    </ol>

<p>
    Everything in Rust really is an expression, and evaluates to some
    value.  
    The none value is <code>()</code>, the unit tuple; this is the 
    return type of a function which returns nothing, for instance,
    or, the value a <code>let<code> statement resolves to.
</p>

<p>
    "<code>()<code> is a value of the type <code>()</code> and its purpose is
    to be useless," says A.B. the Wise.
    Being an object with zero size, it stands to reason that
    its existence would have no effect on machine state.
</p>

<p>
    We can map an expression's value to <code>()</code>) by
    appending a semicolon <code>;</code>. 
    We will say that the value is <em>discarded.</em>
    Semicolons on empty lines have no effect, and
    discarding <code>()</code> has no effect.
</p>

<h3>Result</h3>

<p>
    One type is special, and that is the <em>Result</em> type:
    It is an error to discard a Result.  
    This caveat forms the bread and butter of Rust's error propogation,
    and any function which can fail returns a Result.
</p>

<p>
    Formally, a Result is an <code>enum</code> containing either
    <code>OK(s)</code> for some success value <code>s</code>,
    or <code>Err(e)</code> for an error <code>e</code>.
    Any function which calls a fallable function is expected to
    handle the resulting Result.
</p>

<p>
    The available means of dealing with Results are many and beautiful,
    but too many to introduce here.
</p>

</div>

<div class="content" id="types">
    <h2>Types</h2>

    <p>
        Rust's greatest strength, by far, is its type system.



<p>
    (The Rust compiler is a real bear).
    Matter of fact,
</p>

<code>
    alias bear="cargo"
</code>

<p>
    Where Rust truly shines is in medium- to large-sized projects.
</p>

<div class="content" id="crate">
    <h2>Crate</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            A crate is a Rust package.
        </p>
    </div>

    <p>
        The <em>crate</em> structure is well-defined.
        For each crate, there exists a unique <em>crate root,</em>
        denoted by either <code>main.rs</code> in the case of a binary
        package, or <code>lib.rs</code> in the case of a library.
    </p>

    <p>
        A crate is composed of modules, and the crate root is the crate's
        root module.
        A module named  "mod" may either be a file, <code>mod.rs</code>
        or a directory, <code>mod/</code>.
        Modules are kept in the <code>src/</code> directory.
    </p>
</div>


https://learning-rust.github.io/

Apps using TUI Crate
https://github.com/fdehau/tui-rs#apps-using-tui

Rust is REALLY hard to learn:
https://medium.com/journey-to-rust/implementing-display-trait-for-a-structure-c20587b64c8f
