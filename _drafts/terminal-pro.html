--- 
layout: default
title: Terminal Pro
last-updated: February 2020
---


<div class="content" id="history">
    <h2> History </h2>
    Commands not Programs:

    We don't want to <em>notepad</em> our file! We want to <em>edit</em> it!
    And so, the first text editor was <em>ed</em>.

    Abbreviations:

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            <em>tar</em> is an abbreviation of <em>Tape ARchive</em>.<sup><a href="https://en.wikipedia.org/wiki/Tar_(computing)">[a]</a></sup>
        </p>
    </div>

    $ tar xf <em>archive</em>

    stands for <em>extract file</em>

    From here, the UNIX notion of chaining commands seems perfectly obvious:
    Computer: do thing one, then do thing two, then do thing three...


    Conception:
        Argument <em>switches</em> vs. argument <em>commands</em>
</div>

<div class="content" id="small-composable-utilities">
    <h2>Small Composable Utilities</h2>


    Example: Bzip2 from $ bzip2 --help

     If invoked as `bzip2', default action is to compress.
              as `bunzip2',  default action is to decompress.
              as `bzcat', default action is to decompress to stdout.

    If no file names are given, bzip2 compresses or decompresses
    from standard input to standard output.  You can combine
    short flags, so `-v -4' means the same as -v4 or -4v, &c.

</div>

<div class="content" id="finding-files">
    <h2>Finding Files with <code>fd</code></h2>

    <p>
        <a href="https://github.com/sharkdp/fd">fd</a> is a simple, fast
        and user-friendly alternative to <a href="http://www.gnu.org/software/findutils/">find</a>.
        Its simplest usage searches for basenames:
    </p>

    <div class="code">
        $ fd [PATTERN] [PATH]
    </div>

    <p>
        Where <em>pattern</em> is a regular expression, and
        <em>path</em> is the directory you'd like to start looking in.
        It searches there, and then it searches recursively downward through 
        the directory tree which started there.
        By default it checks filenames, but can check any other file characteristic;
        for instance, to restrict results to directories, we could use
    </p>

    <div class="code">
        $ fd --type d [pattern] [path]
    </div>

    <p>
        For a few reasons, I recommend <code>fd</code> over the classic 
        GNU Findutils:
    </p>

    <ol>
        <li>
            Only one utility to learn
            <p>
                In practice, <code>fd</code> replaces both <code>find</code> 
                and <code>locate</code>.
                Specifically, it's fast and friendly enough that there's no longer
                a need for <em>locate</em>.
            </p>
        </li>
        <li>
            Ameniable defaults
            <p>
                <code>fd</code> matches only basenames, and thereby avoids printing
                pages of results
            </p>
        </li>
        <li>
            Regex by default
            <p>
                Regex is a more powerful and expressive string-matching language
                than shell globbing
            </p>
        </li>
        <li>
            Simpler in Construction
            <p>
                No database to worry about
            </p>
        </li>
    </ol>

    <h3>Searching Files with <code>rg</code></h3>
    <p>
        The <a href="https://github.com/BurntSushi/ripgrep"><code>rg</code></a> 
        utility recursively descends through a directory tree, 
        opening each file, reading its contents and attempting to
        match each line against a regex pattern.
        If a line matches, it then prints the filename and those lines;
        effectively, it searches files for a particular pattern.
        Its simplest usage is:
    </p>

    <div class="code">
        $ rg PATTERN [PATH...]
    </div>

    <p>
        This, again, is a reimagining of a classic UNIX utility&mdash; 
        in this case, the venerable 
        <em><a href="https://en.wikipedia.org/wiki/Grep">grep</a></em>.
        It's mostly just easier to use.
    </p>

    <p>
        Your primary documentation for regex is <a href="https://docs.rs/regex/1.4.3/regex/#syntax">here</a>. Trust me on this.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://github.com/sharkdp/fd">fd</a></li>
        <li><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></li>
        <li><a href="https://docs.rs/regex/1.4.3/regex/#syntax">Regex - Rust</a></li>
    </ul>
</div>



Command-Line Signals:
    Ctrl-c sends the interrupt signal, SIGINT, which most programs respond
    to by terminating immediately.  Handy for killing an unresponsive
    foreground process.

    Ctrl-c is handled by the shell in a different manner: It stops what
    it's doing and returns control to the main loop, presenting the
    user with a new prompt (Kerrisk, p389)
    Some people use this rather than backspacing an erroeous line

    The desktop's familiar copy/paste is overruled on the terminal 
    emulator (ctrl-v is interpretted as an escape sequence); 
    use either ctrl-shift-v or middle-click to paste.

Advanced Redirection:
        "Here documents"

        Pipes

Startup:
    .bash_profile vs .bashrc (see Linux from scratch section 4.4

Closing Remarks:
    AWK
    Awk handles strings of characters as conveniently as most languages handle numbers.
