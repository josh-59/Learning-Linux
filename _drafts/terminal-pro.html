--- 
layout: default
title: Terminal Pro
last-updated: February 2020
---


Commands vs. Programs:
    Example: Editor
    Original editor was <em>ed,</em> 

    Rather than <em>Notepad'</em>ing our file, we want to <em>edit</em> it.

    But ed brought forth ex, begat vi, begat <em>vi-improved</em>, and now
    it's neovim, so what, we're going to
    <em>neovim green-eggs-and-ham</em>

    I take the view that, <em>What you do in ~/.bashrc is your business</em>
    That, in fact, is the entire purpose of that file: It is read only by 
    <code>bash</code> and only when executed by its owner and only in
    an interactive mode.

    So I want to edit files with <code>neovim</em>-- So what? 
    Most full-screen utilities use <code>vi</code> controls, so learn them!
    (In fact, even Firefox lets you 'Quick Search' a web page with 
    <code>/</code>.)
    Once you are (well) familiar with these controls, you can set Bash to 
    vi-mode with <code>set -o vi</code>.

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://vim-adventures.com/">Vim Adventures</a> (Not free)</li>
    </ul>
    
Conception:
    Argument <em>switches</em> vs. argument <em>commands</em>

<div class="content" id="finding-files">
    <h2>Finding Files with <code>fd</code></h2>

    <p>
        <a href="https://github.com/sharkdp/fd">fd</a> is a simple, fast
        and user-friendly alternative to find(1).
        It recurses through a given directory tree, checking filenames and other 
        file characteristics, and prints out a list of files that match 
        your criteria.
        Its simplest usage searches for filenames:
    </p>

    <div class="code">
        $ fd [PATTERN] [PATH]
    </div>

    <p>
        Where <em>pattern</em> is a regular expression, and
        <em>path</em> is the directory you'd like to start looking in.
    </p>

    <h3>Searching Files with <code>rg</code></h3>

    <p>
        The <a href="https://github.com/BurntSushi/ripgrep"><code>rg</code></a> 
        utility recursively descends through a directory tree, 
        opens each file, reads its contents and prints out
        any lines (and filenames) matching a given pattern&mdash; effectively
        searching for a particular pattern.
        Its simplest usage is:
    </p>

    <div class="code">
        $ rg PATTERN [PATH...]
    </div>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://github.com/sharkdp/fd">fd</a></li>
        <li><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></li>
    </ul>
</div>



Command-Line Signals:
    Ctrl-c sends the interrupt signal, SIGINT, which most programs respond
    to by terminating immediately.  Handy for killing an unresponsive
    foreground process.

    Ctrl-c is handled by the shell in a different manner: It stops what
    it's doing and returns control to the main loop, presenting the
    user with a new prompt (Kerrisk, p389)
    Some people use this rather than backspacing an erroeous line

    The desktop's familiar copy/paste is overruled on the terminal 
    emulator (ctrl-v is interpretted as an escape sequence); 
    use either ctrl-shift-v or middle-click to paste.

Advanced Redirection:
        "Here documents"

        Pipes

Closing Remarks:
    AWK
    Awk handles strings of characters as conveniently as most languages handle numbers.
