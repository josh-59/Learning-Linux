---
layout: default
title: "Going Further: Programming in *nix"
last-updated: December, 2020
---


<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#c"> C </a></li>
        <li><a href="#rust"> Rust </a></li>
        <li><a href="#scripting-languages">Scripting Languages</a></li>
        <li><a href="#general-cs"> General Computer Science </a></li>
        <li><a href="#train-schedules"> Train Schedules </a></li>
        <li><a href="#thanks">Thanks for Reading!</a></li>
        <li><a href="#bryan-cantrill"> Bryan Cantrill </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Going Further: Programming in *nix</h1>
    <!--
        GNU/Linux, like any operating system, is an intermediary
        software layer.  
    -->

    <p>
        GNU/Linux, like any operating system, is a tool:
        It enables individuals to use computer hardware.
        For several decades, it has been the operating system of 
        choice for servers, mainframes and supercomputers.
        For its openness, community and adherence to an 
        intelligent architecture, there does not exist a 
        better programming environment than GNU/Linux.
    </p>
</div>

<div id="c" class="content">
    <h2> C </h2>
    <p>
        C was developed alongside Unix at Bell Laboratories, 
        and is considered to be the <em>lingua franca</em> of
        programming.<sup><a href="https://wiki.osdev.org/Required_Knowledge">[1]</a><a href="#references">[2]</a></sup>
        Consider some of the projects carried out in C:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            In Linux, a C compiler is almost always preinstalled.
            Check with <br><center><code>$ gcc --version</code></center>
        </p>
    </div>

    <ul>
        <li>
            The Unix kernel, starting with version 6
        </li>

        <li> 
            The Linux Kernel
        </li>

        <li>
            Bash, Zsh
        </li>

        <li>
            <a href="https://en.wikipedia.org/wiki/CPython">CPython</a>, the reference Python interpreter
        </li>

        <li>
            <a href="https://elinux.org/Executable_and_Linkable_Format_(ELF)">ELF</a>, the format of the executable binary file in Linux
        </li>

    </ul>

    <p>
        "C is not a large language," say Brian Kerninghan and Dennis Ritchie,<sup><a href="#references">[3]</a></sup>
        but it is difficult to master.
        A central feature of the language, and the principal reason for its
        difficulty, is that C expects the programmer to manually (explicitly)
        address memory, through variables called <em>pointers.</em>
        Moreover, memory is often allocated and deallocated manually (explicitly)
        by the programmer.
        With this combination, there are many possible avenues of failure, including
        dangling pointers, double-free-ing, memory leaks, and running off the end of an array.
    </p>

    <p>
        These, in turn can lead to security vulnerabilities, bugs and crashes.
        For instance, even something as elementary as
        <a href="https://www.man7.org/linux/man-pages/man3/strcpy.3.html">copying a string</a>,
        if left unchecked, introduces the possibility of attack and exploitation.
        Because the compiler does not warn you of these possibilities, it
        is very difficult to master the language. 
        Moreover, as Brian Cantrill points out below, even when one does write correct C,
        it is difficult to compose the work of multiple developers into a single
        whole.
    </p>

    <p>
        Nonetheless, C is a great language: 
        It has been the standard systems programming language for fifty years,
        it is considered <a href="https://wiki.osdev.org/Required_Knowledge">required knowledge</a> for operating systems developers, 
        and it is here to stay.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="http://s3-us-west-2.amazonaws.com/belllabs-microsite-dritchie/cbook/index.html">The C Programming Language</a> (2<sup>nd</sup> Edition)</li>
        <li><a href="https://www.linuxlinks.com/wp-content/uploads/2019/07/An_Introduction_to_GCC-Brian_Gough.pdf"> An Introduction to GCC </a></li>
    </ul>
</div>

<div id="rust" class="content">
    <h2> Rust </h2>

    <p>
        Rust is the up-and-coming systems programming language, and in my opinion,
        the bee's knees.
        Rust, like C, is a compiled systems-programming language.
        However, it mitigates C's memory management risks by introducing a rigorous type
        system and new ownership rules.
        Together, these allow the Rust compiler to guarantee (prove) the aforementioned
        "correctness" of code.
    </p>

    <p>
        In addition to guarding against many errors, bugs and exploits, this also
        increases the composability of code.
        Of the source code present and available in Rust's package-management repository (<a href="https://crates.io/">crates.io</a>),
        you, the developer, are guaranteed that the code you choose is memory- and
        concurrency-safe (or you will be warned).
    </p>

    <p>
        Two <em>more</em> things to love are its command-line utility, <a href="https://doc.rust-lang.org/cargo/">cargo</a>, and its
        <a href="https://doc.rust-lang.org/std/">official documentation</a>.
        Both are super-modern, and developer-centric.
        The command-line utility additionally serves as the language's 
        package manager,
        and the documentation is well-organized and easy to navigate.
    </p>

    <p>
        Just check out some of these projects:
    </p>

    <ul>
        <li><a href="https://github.com/sharkdp/bat">bat</a>&mdash; A drop-in replacement
            for <em>cat</em> that does syntax highlighting and paging (when connected
            to an interactive terminal)
        </li>
        <li><a href="https://github.com/alacritty/alacritty">Alacritty</a>&mdash;
            A cross-platform, GPU-accelerated terminal emulator
        </li>
        <li><a href="https://github.com/rust-unofficial/awesome-rust#audio-and-music">Awesome Rust</a>&mdash;
            A big-ass list of such projects
        </li>
    </ul>


    <p>
        Rust is not an easy language to learn, though, so expect to do some studying.
        As with C and C++, it helps to understand
        where and how data is stored on the machine at runtime.
        (This contrasts greatly with interpreted languages like Python or Ruby.)
    </p>

    <p>
        Of the nonprimary resources available to learn Rust, I found these helpful:
    </p>

    <ul>
        <li><a href="https://www.oreilly.com/library/view/programming-rust/9781491927274/">Programming Rust</a>&mdash;
            Informative and entertaining, this book is written by two experienced
            C++ developers.  Great book.  Not free; second edition expected in 2021.
        </li>
        <li><a href="https://github.com/rust-lang/rustlings">Rustlings</a>&mdash;
            A command-line game that teaches you Rust expressions. You open a text editor
            in a second window, and edit the files so that they compile.
        </li>
        <li><a href="https://github.com/josh-59/cargo-watch">cargo-watch</a>&mdash;
            A simple command-line utility that keeps a Cargo package compiled in real-time.
            Inspired by <em>Rustlings</em>
        </li>
    </ul>

    <img style='width: 90%;' src="assets/img/100rust.png">

    <h3>See Also:</h3>
    <ul>
        <li> <a href="https://rustup.rs/"> Rustup - The Rust Toolchain Installer </a></li>
    </ul>
</div>

<div class="content" id="scripting-languages">
    <h2>Scripting Languages</h2>

    <p>
        C and Rust belong to a class of languages called <em>systems programming
        languages:</em> They produce binary executable files 
        which can potentially run on bare metal.
        <em>Scripting languages</em> build upon the work of systems programming
        languages: Their executable files are plain-text (they
        execute source-code files), and they require an interpretting 
        run-time environment.
    </p>

    <p>
        Some examples of scripting languages:
    </p>

    <ul> 
        <li> 
            <code>bash</code> 
        </li>
        <li> 
            <code>python</code> 
        </li>
    </ul>

    <p>
        Scripting languages are, for several reasons, easier to work within
        than systems programming languages.
        First, since they have an interpretted runtime environment, they
        can offer abstract data structures not built directly into the machine.
        Python, for instance, uses <em>lists</em> extensively, and also
        offers sets and dictionaries.
    </p>

    <p>
        Second, their source-code files tend to be shorter, and easier to read and write.
        Since we, the authors, are not required to define a <em>list</em>, <em>set</em>
        or <em>dictionary</em>, but can instead just assume their existence,
        we can leave substantial amounts of (highly technical) code out of every program.
    </p>

    <p>
        Third, since their source-code files are their executables,
        there is no need to compile code and no need to track binary executables.
        These facets make scripting languages conceptually simpler, and speed development considerably.
    </p>

    <h3>My Opinion</h3>
    <p>
        Shell scripting has been around since the dawn of shells, 
        but is deprecated and should be relegated to individual use.
        Instead, the shell should be designed for <em>principally interactive</em>
        use, with a single, separate, dedicated language (specifically, Python)
        used for automation and scripting.
        There are a few good reasons for this.
    </p>

    <p>
        First, shells are a <em>pain in the ass</em> to program.
        This makes program creation, and more importantly, maintenance, 
        unnecessarily difficult.
        Since each line may be given from a live user via an interactive
        session, it must pass through a maze of parsing for any meaningful
        programming to be carried out. For instance,
        to express, "If x is less than 5, print 'Hello'" in Bash:
    </p>

    <div class="code">
        if [[ $x -lt 5 ]]; then <br>
            &emsp;&emsp;&emsp;echo 'Hello' <br>
        fi
    </div>

    <p>
        The corresponding code in Python:
    </p>

    <div class="code">
        if x &lt; 5:<br>
            &emsp;&emsp;&emsp;print("Hello")
    </div>

    <p>
        Second, such a delineation between interaction and automation
        more closely follows the Unix philosophy:  Do one thing, and do it 
        well.
        <code>Bash</code> is not easy to use interactively because it 
        also accomodates programming features.
        The shell <em>should not</em> be a full-fledged programming language,
        it should restrict its attention to interactivity.
    </p>

    <p>
        Finally, <em>there is nothing to be gained</em> by continuing to 
        program in shells.  
        All scripting languages require an interpretting runtime environment,
        and are therefore architecturally identical.
        Making this change would make GNU/Linux easier to learn, easier to
        use, and cleaner, from an architectural standpoint.
    </p>

    <p>
        There are two arguments against this.
        The first is that, with Bash in hand, scripting is as
        easy as saving a sequence of commands to a file.
        I say, <em>Preserve that.</em> 
        There's nothing wrong with this, and it would be trivial to implement
        in a new shell.
        What's wrong is including features that are not intended for interactivity.
        A second argument is that Bash is not architecturally
        identical to Python, since most of Bash's 
        commands are executable files.
        To this, I respond the functionality for executing separate
        programs exists within Python, and can be used for the purpose of scripting.
    </p>

</div>

<div class="content" id="general-cs">
    <h2> General Computer Science </h2>
    <p>
        It's worthwhile to draw an outline of computer science, in general.
        A classical undergraduate CS curriculum centers around a few courses:
    </p>

    <ul class="big-list">
        <li>
            <p>
                <strong>Programming Languages</strong>&mdash; Initial courses in Java and C++ are pretty
                typical, but neither language has any business in the open-source ecosystem.
                Advanced studies in programming languages become abstract, discussing and developing
                language theory rather than practice.
                This can be useful in language development and compiler design, for instance.
            </p>

        </li>
        <li style="padding-top: 0;">
            <p><strong>Data Structures</strong>&mdash;
                After learning a programming language or two,
                data structures are the next thing to learn in becoming a developer&mdash;
                some understanding of discrete math is a required.
                To illustrate, the typical methodology in writing a program is to
                <em>first select the most appropriate data structure,</em>
                then build the rest of the program around it.
            </p>

            <p>
                <a href="https://opendatastructures.org/"> Open Data Structures </a> is a great book on the subject, the best that I
                personally have found.
                Advanced studies delve further into mathematics, usually focusing on analysis of algorithms.
                The canonical text of algorithms is <a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to Algorithms</a>.
            </p>
        </li>

        <li style="padding-top: 0;">
            <p>
                <strong>Operating Systems</strong>&mdash; A very large topic, it
                discusses operating systems in the abstract.  
                A good, if lighthearted, development is given by 
                Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau in
                their free <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/"> Operating Systems: Three Easy Pieces</a>.
            </p>
        </li>
        <li style="padding-top: 0; padding-bottom: 10px;">
            <p>
                <strong>Computer Architecture</strong>&mdash; Ah, computer architecture.  I loved studying this subject,
                but honestly wonder how useful it is.  
                It looks into the abstractions presented by
                hardware itself, such as signed and unsigned numbers, 
                and instruction set architectures.
                A good development of this
                material is highly mathematical.
                I liked <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer's Perspective</a>.
            </p>
        </li>

        <li style="padding-top: 0;">
            <p><strong>Discrete Mathematics</strong>&mdash; 
                At the end of abstraction, there is always math, it seems.
                Discrete mathematics is not a difficult subject,
                on par with a first semester in calculus.  
                It will introduce enough logic to give informal proofs, 
                cover graphs and advanced counting techniques, among other things.
                Given the inherently discrete nature of the bit, this
                subject founds all of computer science.
                The canonical text for computer scientists is
                <a href="https://en.wikipedia.org/wiki/Concrete_Mathematics">Concrete Mathematics</a>,
                but I prefer <a href="http://discrete.openmathbooks.org/dmoi3.html"> Discrete Mathematics - An Open Introduction</a>
            </p>
        </li>
                </ul>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.hackerrank.com/">HackerRank</a></li>
        <li><a href="https://emkc.org/">Engineer Man Knowledge Center</a></li>
    </ul>

</div>

<div class="content" id="train-schedules">
    <h2 style="margin-bottom: 2pt;"> Train Schedules </h2>
    <h4>How Open Source Works</h4>

    <p>
        Open-source software development is fundamentally reiterative:
        You build something, publish it, improve it, then re-release it.
        "Train scheduling" formalizes this by placing the cycle on a schedule.
        This approach is used by Mozilla to provide
        "stability without stagnation."<sup><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">[6]</a></sup>
        We will use Firefox as a case study, but note that, for instance,
        Linux kernel development follows a similar approach.
    </p>


    <figure>
        <img src="assets/img/train-schedules.png" style="width: 100%;">
    </figure>

    <p>
        A new Firefox version is scheduled for release every four weeks.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[7]</a></sup>
        That is, each version spends four weeks in the <em>Mature</em> category,
        being the officially-supported, current version of Firefox.
        When here, no new features are implemented&mdash; rather, only 
        security patches and bug-fixes are implemented and pushed to the user.
        After its four weeks in the spotlight, it is discarded, for the next version is ready.
    </p>

    <p>
        Before it becomes mature, each version of Firefox has been released as a <a href="https://www.mozilla.org/en-US/firefox/80.0beta/releasenotes/">beta</a>,
        corresponding to the <em>Initial Release</em> above.
        When a release enters the <em>Beta</em> stage, only patches aimed at improving
        stability are accepted.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[6]</a></sup>
        Each release spends four weeks as a beta.
        Finally, there is the <a href="https://www.mozilla.org/en-US/firefox/80.0a1/releasenotes/">Nightly</a> build,
        which contains the latest (and most untested) features.
    </p>

    <p>
        Here we see that <em>Firefox 80</em> will be released as <em>Firefox 81</em>
        enters Beta and <em>Firefox 82</em> enters Nightly:
    </p>

    <figure>
        <a href="https://wiki.mozilla.org/Release_Management/Calendar">
            <img src="assets/img/firefox-train-schedule.png" style="width: 90%; padding-bottom: 10pt;">
        </a>
        <figcaption><center><b><a href="https://wiki.mozilla.org/Release_Management/Calendar">Firefox Release Schedule</a></b></center></figcaption>
    </figure>

    <p>
        As a rule, only opt for pre-release versions of software
        if you are willing to submit bug-reports.
    </p>

    <p>
        In addition to the mainline releases, Mozilla also supports two others:
        <a href="https://www.mozilla.org/en-US/firefox/developer/">Developer Edition</a>,
        which incorporates tools useful for building web pages;
        and, <a href="https://www.mozilla.org/en-US/firefox/enterprise/">Extended Support Release</a>,
        which is upgraded every 42 weeks, and intended for deployment in
        enterprise settings.
    </p>

    <h3>Game Development</h3>
    <p>
        In the author's opinion, this development model is intrinsic to
        open-source software.  
        Moreover, while it is well-suited to developing stable,
        mature software over long periods of time, 
        it is poorly suited to a significant use-case: Game development.
    </p>

    <p>
        By nature, games are at the forefront of technology.
        Further, they are developed all at once, and are released only once.  
        As a consequence, their development is both time-critical and
        non-reiterative.  
        Both of these characterstics are at odds with the <em>train schedule</em>
        approach.
    </p>

    <p>
        If a solution to this situation exists, then it rests in developing 
        open-source programming tools, and collections of free assets,
        which significantly reduce the time
        required to yield a playable game&mdash; e.g.
        <a href="https://godotengine.org">Godot Game Engine</a>.
    </p>


    <h3>See Also:</h3>
    <ul>
        <li><a href="https://opensource.guide/"> Open Source Guide</a></li>
        <li><a href="https://blog.rust-lang.org/2014/10/30/Stability.html"> Stability as a Deliverable | Rust Blog</a></li>
        <li><a href="http://thinking-in-code.blogspot.com/2010/07/train-model-of-software-development.html"> Thinking in Code: Train Model of Software Development</a></li>
    </ul>

</div>

<!--

<div class="content" id="kernel-development">
    <h2>Kernel Development</h2>

    <p>
        Again, I'm not a kernel developer.
        But, here are some collected resources:
    </p>

    <ul>
        <li>
            <a href="https://www.kernel.org/doc/html/latest/process/index.html"> Working with the Kernel Development Community</a>&mdash;
            How to get your changes merged.
        </li>
        <li>
            <a href="http://www.kroah.com/lkn/">The Linux Kernel in a Nutshell</a>&mdash; Written by Greg Kroah-Hartman, this
            walks the reader through building and installing a Linux kernel from source, a requisite step in becoming a kernel developer.
        </li>
        <li>
            <a href="https://sourcedigger.io/">SourceDigger.io</a>&mdash; An online symbol browser for the Linux kernel
            and other C projects.
        </li>
    </ul>
</div>

-->

<div class="content" id="thanks">
    <h2>Thanks for Reading!</h2>
    <p>
        I'd like to say <em>"Thanks"</em> to a few other people, as well.
    </p>

    <ul>
        <li>
            <a href="https://www.youtube.com/channel/UCrUL8K81R4VBzm-KOYwrcxQ">Engineer Man</a>&mdash;
            Who got me started with Linux and programming
        </li>

        <li>
            Brian Kernigham, Ken Thompson, and all the other geniuses of Bell Labs&mdash; Who
            laid the foundation of <em>Unix</em>
        </li>

        <li>
            Linus Torvalds and all kernel developers&mdash; Who made Linux!
        </li>

    </ul>

    <p>
        Thanks!
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.linuxcommand.org/tlcl.php">The Linux Command Line</a> by William Shotts</li>
    </ul>
</div>

<div class="content" id="bryan-cantrill">
    <h2>Bryan Cantrill: Rust and Other Interesting Things</h2>
    <iframe class="video" src="https://www.youtube.com/embed/2wZ1pCpJUIM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from <a href="https://wiki.osdev.org/Required_Knowledge">https://wiki.osdev.org/Required_Knowledge</a></li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
        <li>Turon, A., &amp; Matsakis, N. (2014, October 30).  Stability as a Deliverable:  Rust Blog.  Retrieved August 18, 2020, from
            <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">https://blog.rust-lang.org/2014/10/30/Stability.html</a></li>
        <li> The Firefox release process. (n.d.). Retrieved August 18, 2020, from <a href="https://wiki.mozilla.org/Release_Management/Release_Process">https://wiki.mozilla.org/Release_Management/Release_Process</a></li>
    </ol>
</div>
