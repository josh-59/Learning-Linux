<!--
    Kind of an interesting take on "programming": Start with the
    end-result, rather than the act of creating it.
-->

<div class="content" id="programs">
    <h2> Programs </h2>
    <p>
        A <em>program</em> is a file that instructions describing how
        to construct a process.
        In GNU/Linux, there is no "executable" file type, and there 
        is not a single extension denoting executable files (e.g., <em>.exe</em>).
        Rather, according to POSIX, a program is a regular file with 
        execute permissions.<sup><a href="https://man7.org/linux/man-pages/man3/execvp.3p.html">[a]</a></sup> 
    </p>
</div>

<div class="content" id="scripts">
    <h2> Interpreter Scripts </h2>
    <p>
        An interpreter script is a text file that is executable.
        A script's first line must be of the form:
    </p>

    <div class="code">
        #!interpreter 
    </div>

    <p>
        where <code>interpreter</code> is an absolute path to an executable file.
        This line is known as <em>hash-bang.</em> 
    </p>

    <div class="code">
        #!/usr/bin/python3

        print("Hello World!")
    </div>


    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            To execute <code>file</code> in the current working directory, use
            <br><center><code>./file</code></center><br>
        </p>
    </div>

    <h3>See Also:</h3>
    <ul>
        <li>execve(2)</li>
    </ul>

</div>

<div class="content" id="first-binary-executables">
    <h2> Binary Executables </h2>
    <h4> and <code>a.out</code> </h4>

    <p>
        A binary executable is a program stored in a format that is 
        natively executable by the host computer.
        Building one from a high-level language is a multistep process, but
        performance is effectively maximized.  
        Preparing a process to execute a binary is known as <em>loading.</em>
    </p>
   
    <ul>
        <li> Text&mdash; Machine instructions </li>
        <li> Data&mdash; Initial values for global and static variables</li>
        <li> BSS&mdash; Uninitialized global and static variable values; 
            assigned arithmetic zero by the kernel upon loading</li>
    </ul>

    <p>
        To execute a program stored in this format, the kernel
        simply copies its data to the process's virtual memeory and 
        assigns the CPU's program counter to point to the first instruction 
        therein.
    </p>

    <p>
        The simplicity of this format became its undoing: 
        It cannot 

    <p>
        The first Unix binary executable file format was <em>a.out,</em>
        shorthand for
        <em>assembler output.</em><sup><a href="https://en.wikipedia.org/wiki/A.out">[5]</a></sup>
        This was a very simple format, consisting of three distinct data 
        segments that coincided with the major components of the 
        process's virtual memory:
    </p>


</div>

<div class="content" id="elf">
    <h2>ELF format</h2>

    <p>
        The binary format of our time is 
        <a href="https://wiki.osdev.org/ELF">ELF</a>.
        Command-line tools for peeking into such a file
        include:<sup><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Tools">[21]</a></sup>
    </p>

    <ul>
        <li> <code>size</code> &mdash; List section sizes above<li>
        <li> <code>readelf</code> &mdash; Display detailed information about ELF files</li>
    </ul>
</div>

<div class="content" id="toolchains">

</div>


