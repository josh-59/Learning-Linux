---
layout: default
title: "Appendix: Getting Your Degree"
last-updated: October 2021
---

<div id="nav_bar_2" class="nav">
	<ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#scripts-and-binaries">Scripts and Binaries</a></li>
        <li><a href="#languages">Languages</a></li>
        <li><a href="#standard-courses">Standard Courses</a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Appendix: Getting Your Degree</h1>

    <div class="quote-text">
        "The best way to learn programming is to read and write code."
    </div>

    <div class="quote-ref">
        My CS Professor
    </div>

    <p>
        Open source is supposed to be fun&mdash; that's the whole point.
        The rule of thumb is that two good projects are worth an
        entire CS degree.
    </p>
</div>

<div class="content" id="scripts-and-binaries">
    <h2> Scripts and Binaries </h2>
    <p>
        An interpreter script, or simply "script", is a text file 
        that is executable.
        A script's first line must be of the form:
    </p>

    <div class="code">
        #!/bin/python3
    </div>

    <p>
        This line is known as <em>hash-bang,</em> 
        and it is interpreted by the kernel when the file is 
        executed.
        For example, the traditional first program, <em>Hello world</em>
        in Python is: 
    </p>

    <div class="code">
        #!/usr/bin/python3

        print("Hello World!")
    </div>

    <h3>Binary Executables</h3>

    <p>
        A binary executable is a program stored in a format that is 
        natively executable by the host computer.
        Such programs are not readable by humans, and requires
        compilation before it can be executed.
    </p>
  
    <p>
        The first Unix binary executable file format was <em>a.out,</em>
        shorthand for
        <em>assembler output.</em><sup><a href="https://en.wikipedia.org/wiki/A.out">[5]</a></sup>
        The binary format of our time is 
        <a href="https://wiki.osdev.org/ELF">ELF</a>.
        Command-line tools for peeking into such a file
        include:<sup><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Tools">[21]</a></sup>
    </p>
</div>

<div class="content" id="languages">
    <h2>Languages</h2>

    <p>
        There are a bazzillion programming languages in use today,
        and you're free to do whatever you want.
        Some people find sport in writing programs in the language
        <em><a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a>,</em> 
        a language intentionally obtuse, to the extreme.
        I'm only going to cover three languages: 
        Two that I think you must know, and one that I think should know.
    </p>

    <p>
        The C programming language is the <em>lingua franca</em> of 
        computing, and any developer worth their salt knows their 
        way around it.  
        As of this writing, it is being relegated to use at 
        the assembly level, with other languages replacing it for
        application development.
        Learning it will expose you to fundamental ideas in computing,
        such as memory addresses and numeric interpretation of bytes.
        The standard text for this language is 
        <em>The C Programming Language,</em>
        affectionately referred to as <em>K&R</em>.
    </p>

    <p>
        The second language that is essential in the modern domain
        is Python. 
        Python is a powerful, general-purpose interpreted language,
        and can be used for everything from data analysis to accounting.
        It's in wide use by the scientific community, and it 
        is widely supported; it's even available on the latest
        generation of TI-84 Graphing calculators!
    </p>

    <p>
        The final programming language worth learning (in my opinion)
        is <em>Rust</em>.
        The goal of the Rust team is to empower everyone to build
        reliable and efficient software.
        They have done this by creating a programming language that
        is fast and memory-safe.
        It's a great language, but it is not easy to learn!
        If you stumble through learning Rust as I did, try to
        keep in mind that <em>what you are doing is not simple.</em>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.hackerrank.com/">HackerRank</a></li>
        <li><a href="https://emkc.org/">Engineer Man Knowledge Center</a></li>
    </ul>
</div>

<div class="content" id="standard-courses">
    <h2>Standard Courses</h2>

    <p>
        At the end of abstraction, there is always math, it seems.
        Discrete mathematics is not a difficult subject,
        on par with a first semester in calculus.  
        It will introduce enough logic to give informal proofs, 
        cover graphs and advanced counting techniques, among other thinGiven the inherently discrete nature of the bit, this
        subject founds all of computer science.
        The canonical text for computer scientists is
        I prefer <a href="http://discrete.openmathbooks.org/dmoi3.html"> Discrete Mathematics - An Open Introduction</a>
    </p>

    <h3>Data Structures and Algorithms</h3>

    <p>
        After learning a programming language or two,
        data structures are the next thing to learn in becoming 
        a developer.
        some understanding of discrete math is a required.
        To illustrate, the typical methodology in writing a program is to
        <em>first select the most appropriate data structure,</em>
        then build the rest of the program around it.
    </p>

    <p>
        Tending towards academic, given that modern standard libraries
        include smart implementations of common data structures.
        As such, you're going to need to know how to use them, but
        building them is more of an exercise than a fruitful
        proposition.
    </p>

    <p>
        <a href="https://opendatastructures.org/">Open Data Structures</a>
        Advanced studies delve further into mathematics, usually focusing on analysis of 
        algorithms.
        The canonical text of algorithms is <a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to Algorithms</a>.
    </p>
 
    <h3>Computer Architecture</h3>

    <p>
        Ah, computer architecture.  I loved studying this subject,
        but honestly wonder how useful it is.  
        It looks into the abstractions presented by
        hardware itself, such as signed and unsigned numbers, 
        and instruction set architectures.
        A good development of this
        material is highly mathematical.
        I liked <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer's Perspective</a>.
    </p>

    <h3>Operating Systems</h3>

    <p>
        A very large topic, it
        discusses operating systems in the abstract.  
        A good, if lighthearted, development is given by 
        Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau in
        their free <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/"> Operating Systems: Three Easy Pieces</a>.
    </p>
</div>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            In two words: <em>Helper Functions!</em>
        </p>
    </div>


                Write code that can be improved.
                This just means that the developer's first responsibility
                is to keep the code simple.
                <ul>
                    <li>Keep it simple</li>
                </ul>
            </li>


    <p>
        Code is read much more often than it is written.
        As such, it is the responsibility of the developer to write
        code which can be read easily&mdash; that is, which is clear.
    </p>

    <p> 
        If you do wish to contribute a modification to a project, 
        then you have a few responsibilities:
        <ul>
            <li>
                Write code that can be read easily
                <ul>
                    <li>Code is read much more often than it is written</li>
                </ul>
            </li>
                       <li>
                Write code that is modular
                <ul>
                    <li>Account for future development</li>
                </ul>
            </li>
        </ul>
        But most of all, do one thing and do it well.
    </p>


<h3> Additional Resources: </h3>
    <ul>
        <li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP">Operating Systems: Three Easy Pieces</a> by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau</li>
        <li><a href="http://www.man7.org/tlpi/index.html">The Linux Programming Interface</a> by Michael Kerrisk</li>
        <li><a href="https://nostarch.com/howlinuxworks3">How Linux Works</a> by Brian Ward</li>
    </ul>


