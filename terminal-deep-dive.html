<h3> Virtual Terminals</h3>
<h4 style="font-size:smaller">You can safely skip this section</h4>
<p>
    The other context in which terminals appear in modern GNU/Linux
    is in <em>virtual terminals.</em>
    These are full-screen terminal displays using the system's video monitor,
    and are accessible by pressing the key combination CTRL+ALT+F[1-9]
    (use CTRL-ALT+F7 to get back!).
</p>

<p>
    Virtual terminals are more than just a throwback to simpler days:
    They allow access to the machine
    without a graphical user interface and without its associated
    software (window server, window manager, desktop environment, etc).
    If, for instance, you were to set up a web server,
    this is how you would expect to do so.
</p>

<p>
    The user of a modern GNU/Linux distribution running a GUI is usually logged in to the
    seventh virtual terminal, <code>/dev/tty7</code>.
    For completeness' sake, we will briefly explore how it is that the system arrives in this
    state.
    At the end of the kernel's boot sequence, the kernel launches <a href="processes.html#proccess-creation">init</a>.
    This process then launches the local window system, which, in turn, logs in at
    an empty virtual terminal.
    This process is almost always X Window Server, which logs in to <code>tty7</code>,
    and launches the graphical user interface<sup><a href=#references>[9]</a></sup>.
    One can emulate this sequence by logging into a virtual terminal and launching
    the system's window server by:
</p>

<div class="code">
    $ sudo startx
</div>

<p>
    <code>/dev/tty0</code> is a somewhat special virtual terminal device because it is
    a synonym for the current virtual terminal.
    That is, if you are currently looking at the seventh virtual terminal, <code>tty7</code>, then data sent to <code>tty0</code>
    is sent to <code>tty7</code> (and not any other terminal).
    <a href="https://unix.stackexchange.com/questions/60641/linux-difference-between-dev-console-dev-tty-and-dev-tty0">
        This unix.stackexchange answer</a> provides a great explanation, and a demonstration.
    </p>

    <h3>The Controlling Terminal:<br> /dev/tty </h3>
    <p>
        <code>/dev/tty</code> is a handle to the process's current tty device, if it exists<sup><a href=#references style="text-decoration: none">[10]</a></sup>.
        It is, effectively, a process-specific file: Any process that is connected to a terminal
        may access its terminal here
        <sup><a href=#references style="text-decoration: none">[11]</a></sup>.
    </p>

    <h4> Demonstration </h4>
    <ol>
        <li> Open up two terminal emulators</li>
        <li> Navigate each to <code>/dev</code></li>
        <li> In each, confirm that <code>tty</code> exists, is a character device, and has universal write permissions</li>
        <li> In each, confirm that writing to <code>tty</code> (e.g. <code>echo "stuff" > tty</code>) does not write to the other </li>
    </ol>

    <h3> Pseudoterminals: <br>pts/ </h3>
    <p>
        From
        <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html#terminal-devices"> Kernel.org Documentation</a>,
        "Pseudoterminals are used to create login sessions or provide other capabilities
        requiring a TTY line discipline to arbitrary data-generation processes."
        Pseudoterminals have no physical devices connected; rather, they are
        intended to pipe information through the kernel's terminal line discipline
        by connecting two distinct points in the file system,
        a <i>master</i>, <code>/dev/ptmx</code>, and a
        <i>slave</i>, a file with an integral filename, found in <code>/dev/pts</code>.
    </p>

        <p>
            A user-space process opens the "master" side, <code>/dev/ptmx</code>,
            as an ordinary file.
            The kernel responds by returning a new file descriptor,
            and also by creating a new <i>slave</i> device file in <code>/dev/pts</code>.
            The process can then call <code>ptsname(int fd)</code>, passing the file
            descriptor given by opening the master side, whereby the kernel will return
            the pathname to the corresponding slave (terminal) device file.
        </p>

        <p>
            At this point, the process can treat the slave side of the pipe
            as a tty device, and the kernel will modify the stream as
            appropriate.
            The most common use of pseudoterminals is by terminal emulator programs.
            See <a href="https://linux.die.net/man/4/ptmx"> man 4 ptmx </a> and
            <a href="https://linux.die.net/man/3/ptsname"> man 3 ptsname </a>
            for more information.
        </p>

        <p>
            There are a lot of things you can do with pseudoterminals, and studying
            them goes a long way towards understanding the Unix filesystem concept.
            What you're doing is, you're piping a stream of characters through the kernel,
            and requesting that the kernel modify this stream in a way peculiar to
            a kernel module called the "terminal line discipline."
            We'll get into more detail about the terminal line discipline in the
            next section.
        </p>

        <h4> Demonstration </h4>
        <ol>
            <li> Open exactly two terminal emulators</li>
            <li> Navigate one to <code>/dev/pts</code></li>
            <li> List the directory contents and note its entries (should be nonempty)</li>
            <li> For each integral entry, write a string to the file, (e.g., <code>echo hello &gt; 2</code>) </li>
        </ol>


        <h3> System Console: <br><code>/dev/console</code> </h3>
        <p>
            This is the superuser's device.
            Kernel errors and other messages are sent here<sup><a href=#references style="text-decoration: none">[12]</a></sup>, and the device
            is owned entirely by the root user:
        </p>

        <div class="code">
            $ ls -lF /dev/console<br>
            crw------- 1 root root 5, 1 Mar 31 05:33 /dev/console
        </div>

    </div>
