---
layout: default
title: Command Line
last-updated: July, 2020
---
<!--
  TODO
  Variable expansions
  Builtins
  Globbing

  A tutorial introduction

  Example of good scripting:
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | cat -
-->


<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#standard-file-descriptors"> Standard File Descriptors </a></li>
    <li><a href="#globbing"> Globbing </a></li>
    <li><a href="#path-environment-variable"> PATH Environment Variable </a></li>
    <li><a href="#introduction-to-make"> Introduction to Make </a></li>
    <li><a href="#closing-remarks"> Closing Remarks </a></li>
    <li><a href="#references"> References </a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>The Command Line</h1>
  <h4>Under Construction!</h4>

  <p>
    The command-line is uniquely *nix.
    As a user interface, it is exceptionally powerful:
    Anything that can be done on a Unix-like system can be done through
    the command-line alone.
    The graphical user interface (desktop environment) is best thought of as a superstructure;
    it is often the case that it is literally a superstructure, with
    GUI interfaces built on top of command-line tools.
  </p>

</div>

<div id="standard-file-descriptors" class="content">
  <h2> The Standard File Descriptors </h2>
  <p>
    Each process on a *nix system is created with three open files,
    <em>Standard In,</em> <em>Standard Out</em> and <em>Standard Error:</em>
  </p>

  <figure>
    <img src="assets/img/stdin-stdout-stderr.png" style="width: 100%;">
  </figure>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Although these files are opened for every process,
      we interact with them most often at the command line.
    </p>
  </div>

  <p>
    Standard in is usually the terminal keyboard.
    Standard out and standard error are usually the terminal screen.
  </p>

  <p>
    Consider the <em>echo</em> utility.
    This program reads each argument passed to it, and prints it to standard
    out:
  </p>

  <div class="code">
    $ echo one two three <br>
    one two three <br>
  </div>

  <p>
    Here, neither STDIN nor STDERR are used (although they are technically open).
    Rather, the arguments are passed to the kernel during the
    <em><a href="https://www.man7.org/linux/man-pages/man2/execve.2.html">execve(pathname, argv, envp)</a></em>
    system call, which places them within the address space of <em>echo</em>,
    which in turn simply reads them from within itself and prints them to its standard out:
  </p>

  <figure>
    <img src="assets/img/echo-std.png" style="width: 80%;">
  </figure>

  <p>
    The name <em>argv</em> is short for <em>argument vector,</em> and
    is an array of character pointers.
    It exists within each process, and the first element it points to
    is always the name of the called program.
    If you want to learn more about the argument vector, see <em>The C Programming Language</em>.
  </p>

  <p>
    We turn back to the operation of the shell.
    As each line is read by the shell, it is broken down into tokens, which
    are delimited by space(s) or tab(s).
    The first token (here, '<code>echo</code>') is always interpreted as a command.
    The other tokens were interpreted as arguments, so that our call to echo
    passed three arguments.
  </p>

  <p>
    By default, the shell connects a command-line tool's <em>Standard-out</em>
    to the terminal screen.  We can change this, though:
  </p>

  <div class="code">
    $ echo one two three > boo <br>
  </div>

  <p>
    This is called <em>redirection</em>&mdash; Formally, we have redirected the
    standard out of the <code>echo</code> utility to a file called <code>boo</code> by using
    the redirection operator <code>&gt;</code>.
    This is a facility of the shell; <code>echo</code> is not involved in any way.
    In the command above, the shell first opens
    the file <code>boo</code>, creating it if it does not exist, and truncating it
    to zero length if it does exist (and is writeable).
    Then the shell connects the standard out to that

  <p>
    Now consider the <em>cat</em> utility:
  </p>

  <div class="code">
    $ cat foo bar <br>
    &lt;contents of 'foo'&gt; <br>
    &lt;contents of 'bar'&gt; <br>
  </div>
</div>

<div class="content" id="globbing">
  <h2> Globbing </h2>
</div>

<div class="content" id="path-environment-variable">
  <h2> PATH Environment Variable </h2>
  <p>
      This variable declares the directories the shell will search
      locate an executable file, when a command is entered.
      We can have a look at its value with,
  <p>

  <div class="code">
      echo $PATH
  </div>

  <p>
      The result is a list of directories;
      the shell searches these directories (from left to right), and executes
      the first executable with the same name as the command given.
      The <code>PATH</code> variable was invented by John Mashey
      and introduced as a workaround so that non-expert users could
      share their own sets of command by lab, department or
      group.<sup><a href="#references">Kernighan page 132 (check not plaigarizing)</a></sup>
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      We can always override this search by specifying the executable's
      location, either absolutely (e.g., <code>/bin/echo</code>), or relatively (e.g., <code>./cat</code>).
    </p>
  </div>

  <p>
    It's fairly common to modify the value of this variable, so we'll go over
    how to do it properly.
  </p>
</div>

<div class="content" id="introduction-to-make">
  <h2> Introduction to Make </h2>
  <p>

  </p>
</div>

<div class="content" id="closing-remarks">
  <h2> Closing Remarks </h2>
  <p>
      A shell is not, fundamentally, a commplicated program.
      Its job is to query the user for their next command,
      then execute that command.
      An outline of the central loop is as follows:
  </p>

  <div class="code">
    while(true) {<br>
      &emsp;print_prompt();<br>
      &emsp;get_line();<br>
      &emsp;parse_line();<br>
      &emsp;execute(line);<br>
    }
  </div>

  <h3> The Builtin Confusion </h3>
  <p>
    Shells contain many functions of their own.
    These commands are called <em>builtins,</em> and implement functionality
    too closely tied with the shell to be separate.
    For instance, the <em>cd</em> command must be implemented as a
    builtin (because the system call to change a process's working directory,
    <em> <a href="https://man7.org/linux/man-pages/man2/chdir.2.html">int chdir(const char *path)</a></em>)=,
    acts on the calling process alone.
  </p>

  <p>
    The confusion arises when the shell implements a command like <em>echo</em>
    as a builtin.
    In this situation, echo exists as a program on PATH, so that <em>which echo</em>
    prints a path, but that program is not called when echo is called.
    Modern shells (in particular, <em>nushell</em>) will warn you of this when you
    call <em>which</em>, but older shells like bash do not.
    In bash, if you suspect that a command like <em>echo</em> is builtin, you can check with,
  </p>

  <div class="code">
    $ help echo
  </div>

  <p>
    If a shell help page exists, then it is a builtin.
    In practice, this detail is rarely an issue, but it occasionally is, and it
    is confusing.
    You can "force" the external program with an absolute pathname,
    e.g.,
  </p>

  <div class="code">
    $ /bin/echo hello world
  </div>

  or

  <div class="code">
    $ $(which echo) hello world.
  </div>

  <h3> Convention: $ and # </h3>
  <p>
    By convention, the dollar-sign symbol <em>$</em> denotes
    the command-line prompt with ordinary user permissions.
    The hash symbol <em>#</em> denotes the command-line prompt with root permissions:
  </p>

  <div class="code">
    $ cat archlinux-2020.07.02-pbp.img > /dev/sdb <br>
    bash: /dev/sdb: Permission denied <br>
    $ sudo -i <br>
    [sudo] password for josh: <br>
    # cat archlinux-2020.07.02-pbp.img > /dev/sdb <br>
  </div>

  <h3> See Also: </h3>
  <ul>
    <li> <a href="https://github.com/alebcay/awesome-shell">Awesome Shell</a> </li>
  </ul>
</div>

<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
    <li>
        Bryant, R. E., & O'Hallaron, D. R. (2016).  Processes. In <em>Computer Systems: A Programmer's Perspective</em> (3rd ed., p. 732).  Upper Saddle River, New Jersey: Pearson. </li>
  </ol>

</div>
