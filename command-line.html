---
layout: default
title: Command Line
last-updated: July, 2020
---
<!--
  TODO
  Variable expansions
  Builtins
  Globbing
-->


<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#standard-file-descriptors"> Standard File Descriptors </a></li>
    <li><a href="#globbing"> Globbing </a></li>
    <li><a href="#path-environment-variable"> PATH Environment Variable </a></li>
    <li><a href="#introduction-to-make"> Introduction to Make </a></li>
    <li><a href="#closing-remarks"> Closing Remarks </a></li>
    <li><a href="#references"> References </a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>The Command Line</h1>
  <h4>Under Construction!</h4>

  <p>
    The command-line is uniquely *nix.
    As a user interface, it is exceptionally powerful:
    Anything that can be done on a GNU/Linux system can be done through
    the command-line alone.
    This is because text is easy to interface with systems software.
    The graphical user interface (desktop environment) is best thought of as a superstructure;
    it is often the case that it is literally a superstructure, with
    GUI interfaces built on top of command-line tools.
  </p>

</div>

<div id="standard-file-descriptors" class="content">
  <h2> The Standard File Descriptors </h2>
  <p>
    Each process on a *nix system is created with three open files,
    <em>Standard In,</em> <em>Standard Out</em> and <em>Standard Error:</em>
  </p>

  <figure>
    <img src="assets/img/stdin-stdout-stderr.png" style="width: 100%;">
  </figure>

  <p>
    Although these files are opened for each process on the system, they
    make the most sense at (and are used most often at) the command line.
    Standard in is usually the terminal keyboard.
    Standard out and standard error are usually the terminal screen.
  </p>

  <p>
    Consider the <em>echo</em> utility.
    This program reads each argument passed to it, and prints it to standard
    out:
  </p>

  <div class="code">
    $ echo one two three <br>
    one two three <br>
  </div>

  <p>
    Neither STDIN nor STDERR are used.
    Rather, the arguments are passed to the kernel in the
    <em><a href="https://www.man7.org/linux/man-pages/man2/execve.2.html">execve(pathname, argv, envp)</a></em>
    system call; they are placed within the address space of <em>echo</em>,
    which simply reads them from itself, and prints them to standard out:
  </p>

  <figure>
    <img src="assets/img/echo-std.png" style="width: 80%;">
  </figure>

  <p>
    As each line is read by the shell, it is broken down into tokens, which
    are delimited by space(s) or tab(s).
    The first token (here, '<code>echo</code>') is always interpreted as a command.
    The other tokens are passed as arguments, so that our call to echo
    passes three arguments.
  </p>

  <p>
    Now consider the <em>cat</em> utility:
  </p>

  <div class="code">
    $ cat foo bar <br>
    &lt;contents of 'foo'&gt; <br>
    &lt;contents of 'bar'&gt; <br>
  </div>
</div>

<div class="content" id="globbing">
  <h2> Globbing </h2>
</div>

<div class="content" id="path-environment-variable">
  <h2> PATH Environment Variable </h2>
  <p>
      This variable declares the directories the shell will search
      locate an executable file, when a command is entered.
      We can have a look at its value with,
  <p>

  <div class="code">
      echo $PATH
  </div>

  <p>
      The result is a list of directories;
      the shell searches these directories (from left to right), and executes
      the first executable with the same name as the command given.
      The <code>PATH</code> variable was invented by John Mashey
      and introduced as a workaround so that non-expert users could
      share their own sets of command by lab, department or
      group.<sup><a href="#references">Kernighan page 132 (check not plaigarizing)</a></sup>
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      We can always override this search by specifying the executable's
      location, either absolutely (e.g., <code>/bin/echo</code>), or relatively (e.g., <code>./cat</code>).
    </p>
  </div>

  <p>
    It's fairly common to modify the value of this variable, so we'll go over
    how to do it properly.
  </p>
</div>

<div class="content" id="introduction-to-make">
  <h2> Introduction to Make </h2>
  <p>

  </p>
</div>

<p>
  Shells contain functions of their own;  that may be
    called as though they were ordinary executables.
    These commands are called <em>builtins,</em> and implement functionality
    too closely tied with the shell to be separate.
    For instance, the <em>cd</em> command must be implemented as a
    builtin because the system call to change a process's working directory
    (<em> <a href="https://man7.org/linux/man-pages/man2/chdir.2.html">int chdir(const char *path)</a></em>) acts on the calling process alone!
  </p>

<div class="content" id="closing-remarks">
  <h2> Closing Remarks </h2>
  <p>
      A shell is not, fundamentally, a commplicated program.
      Its job is to query the user for their next command,
      then execute that command.
      An outline of the central loop is as follows:
  </p>

  <div class="code">
    while(true) {<br>
      &emsp;print_prompt();<br>
      &emsp;get_line();<br>
      &emsp;parse_line();<br>
      &emsp;execute(line);<br>
    }
  </div>

  <h3> Convention: $ and # </h3>

  <h3> See Also: </h3>
  <ul>
    <li> <a href="https://github.com/alebcay/awesome-shell">Awesome Shell</a> </li>
  </ul>
</div>

<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
    <li>
        Bryant, R. E., & O'Hallaron, D. R. (2016).  Processes. In <em>Computer Systems: A Programmer's Perspective</em> (3rd ed., p. 732).  Upper Saddle River, New Jersey: Pearson. </li>
  </ol>

</div>
