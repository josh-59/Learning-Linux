---
layout: default
title: 'Bash (and stuff)'
last-updated: April, 2021
---

<!--

    <li><a href="https://blog.nelhage.com/2009/12/a-brief-introduction-to-termios/">A Brief Introduction to Termios</a> - Made of Bugs</li>

    Explanation of sudo:
    https://www.linuxjournal.com/sites/default/files/2018-11/GeekGuide-BeyondTrust-BeyondSudo.pdf



<div class="content" id="closing-remarks">
    <h2>Closing Remarks:</h2>
    <h4><code>make</code></h4>

    <p>
    </p>

    <p>
        One expresses a program to be compiled in "recipes" of the form,
    </p>

    <div class="code">
    hello: hello.c<br>
        &emsp;&emsp;&emsp;&emsp;gcc -o hello hello.c
    </div>

    <p>
        This tells <code>make</code> that <em>hello</em> is a target file,
        and that it depends upon <em>hello.c</em>.
        One can then run:
    </p>

    <div class="code">
        $ make hello
    </div>

    <p>
        and make will execute the shell command 
        <code>gcc -o hello hello.c</code> if 
        <em>hello</em> does not exist, or it does exist and is older 
        than <em>hello.c</em>.
    </p>

    <p>
        Quite a novel little utility, and it is general in the sense that the files
        in question need not be source/binary.
        An introduction to UNIX would not be complete without an introduction 
        to <em>make</em>!
    </p>


    Invented 1976, 7th ed UNIX
    "an instant success"


    "This approach replaces code with data, and that's almost always a win."


    https://en.wikipedia.org/wiki/Make_(software)
    Original Make was conceived and written over a weekend
    <a href="https://en.wikipedia.org/wiki/GNU_Autotools#Components">obtuse to say the least</a>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://archive.org/details/pdfy-MgN0H1joIoDVoIC7">The AWK Programming Language</a></li>
    </ul>
</div>

Exercises:

    <ol>
        <li>
            Explain the behavior of:
            $ PATH="" printenv
        </li>
        <li>
            The shell is a process, like any other.
            For your current shell:
            <ol>
                <li>What was its command-line arguments</li>
                <li>
            </ol>
        </li>
        <li>
            Let <code>script</code> be an executable file containing
            #!/bin/sh
            echo hello world
            There are three ways to execute this command:
            1) In the current shell context
            2) In a forked subshell context
            3) In an <code>exec</code>-induced sh context
            Produce each, and verify with <code>strace</code>
        </li>
        <li>
            Each section of the manual page has an introduction, <code>intro</code>,
            but no index.  Why not?  Create an index of Section 7 for yourself.
        </li>
        <li>
            <p>
                Scripting exercise:
                Use constructs other than <code>if</code> to append a location
                to path.
            </p>
        </li>
        <li>
            <p>
                The command,
            </p>
            <div class="code">
                $ $(echo cd $PWD)
            </div>
            <p>
                is equivalent to which of the following:
            </p>
            <ol>
                <li>$ cd </li>
                <li>$ cd $HOME</li>
                <li>$ cd .</li>
                <li>$ cd ..</li>
            </ol>
        </li>
    </ol>

-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
        <li><a href="#shell-expansion">Shell Expansion</a></li>
		<li><a href="#standard-file-descriptors">Standard File Descriptors</a></li>
		<li><a href="#terminal-conveniences"> Terminal Conveniences</a></li>
        <li><a href="#finding-files">Finding Files</a></li>
        <li><a href="#startup-files">Startup Files</a></li>
		<li><a href="#missing-semester">Missing Semester</a></li>
        <!-- <li><a href="#references"> References </a></li> -->
	</ul>
</div>

<div class="content" id="introduction">
    <h1>Bash (and other stuff)</h1>

    <div class="quote-text">
        "When you type to UNIX, a gnome deep in the system<br>
        is gathering your characters and saving them in a secret place. <br>
        The characters will not be given to a program until you <br>
        type return (or new-line), as described above in <em>Logging in.</em>"
    </div>

    <div class="quote-ref" style="width: 50%;">
        Ken Thompson and Dennis Ritchie<br>
        <a href="https://ia800600.us.archive.org/19/items/v6-manual/v6-manual.pdf">UNIX Programming Manual, Sixth Edition</a><br>
		May, 1975
    </div>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            In Bash, input is buffered through the 
            <a href="https://en.wikipedia.org/wiki/GNU_Readline">GNU Readline</a> 
            library.
        </p>
    </div>

    <p>
        The above quote refers to <em>buffered i/o,</em> which has been called
        a "necessary evil" of terminal-based computing.
        This article will cover some of the gory detail behind the modern
        GNU/Linux command-line, then introduce some handy command-line tools.
    </p>
</div>

<div class="content" id="shell-expansion">
    <h2 style="margin-bottom: 0;">Shell Expansion</h2>
    <h4>and Quote Removal</h4>

    <p>
        After one presses <em>return</em> at the command line, the preceding
        line of text is sent to Bash.  
        Bash makes several passes over the text, interpretting it and modifying it, 
        before executing any command it contains.
    </p>

    <p>
        The first pass splits the line by whitespace into <em>tokens.</em> 
        Then, two expansion passes follow: <em>shell expansion</em>, 
        followed by <em>filename expansion.</em>
    </p>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            If part of the line is single-quoted, it is exempt from tokenizing and
            expansion.
        </p>
    </div>

    <p>
        In the shell expansion pass, variables are expanded to their
        respective values, and command substitution occurs:
    </p>

    <ol>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html">Braces</a>&emsp; <code>{}</code>
            <br>
            <code>a{1,2,3}b</code> becomes <code>a1b a2b a3b</code>
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html">Tilde</a>&emsp;  <code>~</code>
            <br>
            <code>~</code> becomes <code>/home/josh</code>
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">Parameter</a> &emsp;  <code>$</code>
            <br>
            <code>$NAME</code> is replaced by the value of <code>NAME</code>
            variable, if it exists, and null string otherwise.
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html">Command</a> &emsp;  <code>$( </code><em>command</em><code> )</code>
            <br>
            Executes <em>command</em> in a subshell environment, captures output
            and replaces <br> <code>$(</code><em>command</em><code>)</code>
            with said output.  For example, <br>
            <code>$(which ls)</code> becomes <code>/bin/ls</code>
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html">Arithmetic</a>&emsp;  <code>$(( </code><em>expression</em><code>  ))</code>
            <br>
            Evaluates the arithmetic <em>expression</em> and replaces <code>$((</code><em>expression</em><code>))</code> with result
        </li>
    </ol>

    <p>
        These expansions can be understood through the
        <code>echo</code> command, which, as a rule, simply prints out whatever arguments
        it recieves.
        In the following example, the <code>echo</code> command
        recieves exactly two arguments, <code>12</code> and <code>13</code>,
        and it is Bash that has done the work:
    </p>

    <div class="code">
        $ echo 1{2,3}<br>
        12 13
    </div>

    <h3 id="globbing"> Filename Expansion </h3>

    <p>
        The second expansion pass is <em>filename expansion,</em> sometimes
        referred to as <em>globbing.</em>
        If any token contains an asterisk <code>*</code>, question mark
        <code>?</code>, or brackets <code>[]</code>, then it is regarded as a
        <em>pattern,</em> and is replaced by an alphabetical list of all
        filenames in the current directory matching that pattern.<sup><a href="https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html#Filename-Expansion">[a]</a></sup>
    </p>

    <p>
        The meanings of these metacharacters are as follows:
    </p>

    <ul style="list-style-type: none;">
        <li>
            <code>*</code>&emsp; Asterisk.  Matches zero-or-more of any character.
        </li>

        <li>
            <code>?</code>&emsp; Question Mark.  Matches zero-or-one of any character.
        </li>

        <li>
            <code>[ ]</code>&emsp; Brackets.  Matches exactly one of any of the characters contained.
        </li>
    </ul>

    <p>
        For example,
    </p>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            In patterns, all other characters are treated literally.
            By default, hidden files must be matched explicitly.
        </p>
    </div>

    <div class="code">
        *
    </div>

    <p>
        expands to all files in the current directory;
    </p>

    <div class="code">
        *.pdf
    </div>

    <p>
        expands to all files ending in <code>.pdf</code>; and,
    </p>

    <div class="code">
        *.[gx]z
    </div>

    <p>
        expands to all files ending in either <code>.xz</code> or <code>.gz</code>.
    </p>

    <p>
        Pretty spiffy!
        After these steps have been completed, Bash removes unquoted
        quotes, and prepares to execute the command.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="http://mywiki.wooledge.org/glob"> glob - Greg's Wiki </a></li>
    </ul>
</div>



<div id="standard-file-descriptors" class="content">
	<h2 style="margin-bottom: 0;">Standard File Descriptors</h2>
    <h4> and Redirection</h4>

	<p>
        Recall that the shell is connected to its terminal by open files, and
        that such files are preserved across both <em>fork()</em> 
        and <em>exec()</em> system calls. 
        This means that each child of <code>bash</code> (that is, each command) 
        will, by default, inherit our keyboard and our terminal screen as open files.
    </p>

    <p>
        In practice, there are three files:
    </p>

    <ul>
        <li><code>STDIN</code> the keyboard, at file descriptor 0</li>
        <li><code>STDOUT</code> the terminal screen, buffered, at file descriptor 1</li>
        <li><code>STDERR</code> the terminal screen, unbuffered, at file descriptor 2</li>
    </ul>

    <p>
        These are known as the <em>standard file descriptors,</em> and are 
        universally adhered to across UNIX-like operating systems;
        it is, essentially, part of the UNIX architecture.
        For example, the program <code>/usr/bin/ls</code>
        prints to <code>STDOUT</code>, and our command
    </p>

    <div class="code">
        $ ls
    </div>

    <p>
        runs that program in the context of the terminal.
    </p>

    <h3> Redirection </h3>

    <p>
        <em>Redirection</em> is the act of assigning a different file to the standard
        file descriptors before executing a command.
        They are a powerful tool, letting the user capture output, create scripts,
        and even chain commands together.
    </p>

    <p>
        In Bash, the character <code>&lt;</code> redirects <code>STDIN</code>.
        Its formal semantics are:
    </p>

    <ul style="list-style-type: none;">
        <li> <code>$ <i>command</i> [arg ...] &lt; file </code> &emsp; Open <code>file</code>
            for reading,
            assign to <code>STDIN</code>, then execute <code><em>command</em></code></li>
    </ul>

    <p>
        To redirect output:
    </p>

    <ul style="list-style-type: none;">
        <li> <code>$ <em>command</em> [arg ...] &gt; file </code> &emsp; Open <code>file</code>
            for writing; set length to zero; assign to <code>STDOUT</code>.
            Then execute command.</li>
        <li> <code>$ <em>command</em> [arg ...] &gt;&gt; file </code> &emsp; Open <code>file</code>
            for writing; seek to end; assign to <code>STDOUT</code>.
            Then execute command.</li>
    </ul>


    <p>
        Since <code>STDERR</code> has been left unchanged, errors will
        still be printed to our terminal screen.
    </p>

    <p>
        After expansion and redirection, Bash finds and executes 
        the appropriate command, as mentioned in <a href="./terminals-and-shells.html#commands">Terminals and Shells</a>.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.bash-hackers.org/syntax/redirection">Redirection - Bash Hackers Wiki</a></li>
        <li><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html"> Redirections - Bash Reference Manual</a></li>
    </ul>
</div>

<div class="content" id="terminal-conveniences">
    <h2>Random Stuff</h2>

    <h3>Copying and Pasting:</h3>

    <p>
        The desktop's familiar copy/paste is overruled when using terminal
        emulators.
        Use CTRL+SHIFT+c and CTRL+SHIFT-v instead.
        Also, depending on the desktop environment, middle-clicking may 
        copy and paste.
    </p>

    <h3>Tab Completion</h3>

    <p>
        Most shells support "tab completion":
        If you've typed enough of a filename or command to
        uniquely identify it, pressing <em>tab</em> will complete it for you.
    </p>


    <h3>End of File</h3>

    <p>
        Since the shell is connected to the terminal via open file connections,
        there exists a way to communicate <em>end of file</em> condition.
        It is CTRL+D, and it's similar to a signal in the sense that it is
        sent to the foreground process.
    </p>

    <h3>Manual Sections</h3>

    <p>
        When using <code>apropos</code>, you can restrict your search 
        to a specific section with the <code>-s</code> switch:
    </p>

    <div class="code">
        $ apropos -s 1
    </div>

    <p>
        And you can specify a specific section when using <code>man</code>:
    </p>

    <div class="code">
        $ man 7 intro
    </div>

    <p>
        The manual sections are worth learning, but perhaps not by heart.
        Section 7 contains many interesting articles, and it's a worthwhile
        exercise to generate an index of it.
    </p>

    <p>
        Alright, now we'll introduce some other useful command-line tools.
    </p>
</div>

<div class="content" id="finding-files">
    <h2>Finding Files</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Remember: <br>
            <code> fd what where </code>
        </p>
    </div>

    <p>
        The <a href="https://github.com/sharkdp/fd">fd</a>
        utility is a simple, user-friendly alternative to GNU's
        <a href="http://www.gnu.org/software/findutils/">find</a>.
        Usage:
    </p>

    <div class="code">
        $ fd [pattern] [path ...]
    </div>

    <p>
        Where <em>pattern</em> is a regular expression, and
        <em>path</em> is the directory you'd like to start looking in.
        It searches there, and then it searches recursively downward through
        the directory tree which started there.
        For each file, it attempts to match its basename against <em>pattern.</em>
        If the name matches, <code>fd</code> prints the name of the file.
    </p>

    <p>
        Simple!
    </p>

    <p>
        By default, <code>fd</code> checks filenames, but it can check any other
        file characteristic, as well.
        For instance, to restrict results to directories, we could use
    </p>

    <div class="code">
        $ fd --type d [pattern] [path ...]
    </div>

    <p>
        For a few reasons, I recommend <code>fd</code> over the classic
        GNU Findutils:
    </p>

    <ol style="margin-left: 5%; padding-right: 10%;">
        <li>
            <p>
                Only one utility to learn:
                In practice, <code>fd</code> replaces both <code>find</code>
                and <code>locate</code>.
                Specifically, it's fast enough that there's no longer
                a need for <em>locate</em>.
            </p>
        </li>
        <li>
            <p>
                Ameniable defaults:
                <code>fd</code> matches only basenames, and thereby avoids printing
                pages of results.
                More, it does not require a flag to search for filenames.
            </p>
        </li>
        <li>
            <p>
                Regex by default:
                Regex is a more powerful and expressive string-matching language
                than shell globbing, and it is agreeably implemented here via
                Rust.
            </p>
        </li>
        <li>
            <p>
                Simpler in construction:
                No database to worry about.
            </p>
        </li>
    </ol>

    <h3>Searching Files with <code>rg</code></h3>
    <p>
        <a href="https://github.com/BurntSushi/ripgrep"><code>Ripgrep</code></a>
        recursively descends through a directory tree,
        opening each file, reading its contents and attempting to
        match each line against a given regex pattern.
        If a line contains a match, it prints the filename and those lines;
        effectively, it searches files for a particular pattern.
	</p>

	<p>
        Its simplest usage is:
    </p>

    <div class="code">
        $ rg <i>pattern</i> [path ...]
    </div>

    <p>
        This, again, is a reimagining of a classic UNIX utility&mdash;
        in this case, the venerable
        <em><a href="https://en.wikipedia.org/wiki/Grep">grep</a></em>.
        Like <code>fd</code>, it's mostly just easier to use.
    </p>

    <p>
        Your primary documentation for regex is <a href="https://docs.rs/regex/1.4.3/regex/#syntax">here</a>. Trust me on this.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://github.com/sharkdp/fd">fd</a></li>
        <li><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></li>
        <li><a href="https://docs.rs/regex/1.4.3/regex/#syntax">Regex - Rust</a></li>
    </ul>
</div>



<div class="content" id="startup-files">
    <h2>Startup Files</h2>

    .bash_profile vs .bashrc (see Linux from scratch section 4.4)

    rc might stand for "runcoms", short for "runnable commands", now known as
    "shell scripts."
</div>

<div class="content" id="missing-semester">
	<h2 style="margin-bottom: 2pt;">Missing Semester</h2>
	<h4 style="margin-bottom: 18pt;">Lecture 1: Course Overview + The Shell (2020)</h4>
	<iframe class="video" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
