---
layout: default
title: The Linux Filesystem
---

<!-- To Do: Citation needed in "regular files" -> heirarchical filestructure taken from Multics-->
<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#filesystems"> Filesystems </a></li>
        <li><a href="#directory-tree"> Directory Tree </a></li>
        <li><a href="#mounting-unmounting"> Mounting and Unmounting</a></li>
        <li><a href="#regular-files"> Regular Files </a></li>
        <li><a href="#directories"> Directories </a></li>
		<li><a href="#engineer-man"> Engineer Man </a></li>
        <li><a href="#references"> References </a></li>
        <li><a href="#credits">Credits and Licenses</a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>The Linux Filesystem</h1>
    <!-- <h4>In the beginning, there was a filesystem.</h4> -->
    <h4>Under Construction!</h4>

    <p>
        Unix began life as a filesystem (Kernighan 33-34).  Shortly thereafter, a means
        of interacting with it was created&mdash; initially,
		this consisted of an <code>exec</code>
        function, a shell, text editor and assembler.
        Written entirely by Ken Thompson, these key components formed the nexus of
        the time-sharing operating system that would eventually be called
        <em>Unix</em>.
    </p>

    <p>
        This file-first approach to operating system design is found in
        the implementation as well as the history of Unix and its derivatives:
		Unix and its derivatives use files for many things.
		As such, there is a lot to be said about files.
        This paper introduces the notion of a filesystem, and
        discusses the directory structure implemented with it.
    </p>
</div>

<div id="filesystems" class="content">
    <h2> Filesystems </h2>
    <p>
        A filesystem is a systematic method of organizing data on disk.<sup><a href="https://wiki.osdev.org/Filesystem">[1]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[2]</a></sup>
        Conceptually, it is similar to a data structure, in that it defines a convention
        to be followed to store and retrieve data.
        Preparing a drive for use by a particular filesystem is known as formatting.
    </p>

    <ul>
        <h3>Some Common Filesystems:</h3>
        <li>
            <p>
                EXT4:
                Introduced in 2008,<sup><a href="https://en.wikipedia.org/wiki/Ext4">[1]</a></sup> EXT4 is the most common filesystem used on Linux
                today.  It is an evolutionary enhancement on EXT3,
                supporting larger filesizes, deeper subdirectory support,
                faster handling of large files, along with many other improvements.<sup><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">[3]</a></sup>
                It is mature, fast, and stable.
            </p>
        </li>

        <li>
            <p>
                ZFS:
					"Don't use ZFS.  It's that simple." &mdash;<a href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189841">Linus Torvalds</a>.
			</p>

			<p>
				Introduced in 2005,<sup><a href="https://en.wikipedia.org/wiki/ZFS">[2]</a></sup> ZFS incorporates fancier features that are generally
                out of place on an ordinary Linux desktop.
                It was developed by Sun Microsystems, and became closed-source with Sun's acquisition by
                Oracle.<sup><a href="https://en.wikipedia.org/wiki/ZFS">[2]</a></sup>
                It was intended for enterprise use, and is
                <a href="https://en.wikipedia.org/wiki/ZFS#Inappropriately_specified_systems">relatively easy to configure improperly.</a>
                Also, it is <a href="https://wiki.archlinux.org/index.php/ZFS">not free.</a>
            </p>
        </li>

        <li>
            <p>
                FAT32: The "File Allcoation Table 32-bit" is a DOS-era filesystem,<sup><a href="https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32">[3]</a></sup>
                and is widely supported, though antiquated.
                In particular, it is not a <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling filesystem</a>,
                so that changes to data are not recorded before being carried out (increasing the likelihood of
                corruption in the event of, say, power outage).
                This format is often used to hold the bootloader, since it is virtually guaranteed to be supported by firmware.
            </p>
        </li>
    </ul>

	<p>
		Users of Linux don't often interact with the filesystem
		of their operating systems.
		The term was developed here to make precise the distinction between
		<em>filesystem</em> and <em>directory tree</em>.
	</p>

	<h3> See Also: </h3>
	<ul>
		<li> <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">An Introduction to Disk Partitions - Fedora Docs Site </a> </li>
	</ul>
</div>

<div id="directory-tree" class="content">
    <h2> Directory Tree</h2>

	<p>
		On top of a given filesystem, a directory structure is imposed by the operating system.
        On Linux, that structure is a tree of files, also known as a hierarchy, which begins at "root,"
		denoted with a forward-slash:
	</p>

	<div class="code">
		/
	</div>

	<p>
        This directory tree is defined
		by the <a href="https://www.pathname.com/fhs/pub/fhs-2.3.pdf">Linux Filesystem Heirarchy Standard</a>.
		As such, within any GNU/Linux distribution, some common themes will be found.
        For instance, <code>bin</code> directories are found in several places, such as
        <code>/bin</code> and <code>/sbin</code>, along with <code>/usr/bin</code> and often
        <code>/home/user/bin</code>.
		These contain binary executable files (programs), which
        can be ran as commands from the shell.
    </p>

    <p>
        As per the standard, <code>/etc</code> (usually read "<em>et</em>-c") contains host-specific
        system configuration files; as a consequence, you can expect to fiddle
		with the contents of this directory when configuring the system for the first time
        (or otherwise).
        It contains, for instance, files describing the configuration of the system's package
        manager, printers, and, well, etcetera.
    </p>

	<p>
		The directory tree is used as a general-purpose meeting place:
		In addition to regular files, it also holds, for instance, references to hardware drivers,
		and information about running processes.
		This mechanism is general, extensible, and allows both users and programmers
		access to the running machine; the only trick is keeping it organized.
	</p>

	<p>
		The directory <code>/dev</code> contains files called <em>special device files</em>.<sup><a href="https://www.pathname.com/fhs/pub/fhs-2.3.pdf">[1]</a></sup>
		Special device files represent a device connected to the system (or an aspect of one).
		<code>/dev/sdb</code>, for instance, refers to a hard-disk.
		More precisely, this file is our handle to a specific hard-disk's driver.
		<code>/dev/sdb1</code> refers to the drive's first partition;
		<code>/dev/sdb2</code> refers to the drive's second partition;
		etc..
	</p>

	<p>
		Among device special files, there are two distinct kinds:
		<em>block</em> and <em>character</em>.
		The distinction refers to the way that the kernel reads and writes to these files.
		Character special files are operated on a single character at a time
		(e.g., terminal screen), while block special files are operated on a block of
		bytes at a time (usually, 4096 or 8192), as in a hard drive.
	</p>

	<p>
		While there is too much going on in the <code>/dev</code> directory
		to exhaust the subject here,
		it's worth noting that utilities for displaying the current
		system's hardware often begin with <code>ls</code>:
	</p>

	<ul>
		<li><code><a href="http://man7.org/linux/man-pages/man8/lsblk.8.html">lsblk</a></code> - List block devices (hardrives, CD-drives, etc).  Useful to determine what drive to mount.</li>
		<li><code><a href="http://man7.org/linux/man-pages/man1/lscpu.1.html">lscpu</a></code> - Display information about the CPU architecture </li>
		<li><code><a href="http://man7.org/linux/man-pages/man8/lsusb.8.html">lsusb</a></code> - List usb devices </li>
		<li><code><a href="http://man7.org/linux/man-pages/man8/lspci.8.html">lspci</a></code> - List all PCI devices </li>
		<li><code><a href="http://man7.org/linux/man-pages/man8/lsmod.8.html">lsmod</a></code> - Show the status of modules in the Linux Kernel </li>
	</ul>

	<h3>See Also:</h3>
		<ul>
			<li><a href="https://www.man7.org/linux/man-pages/man7/file-hierarchy.7.html"><code>file-hierarchy(7)</code></a></li>
			<li><a href="https://wiki.archlinux.org/index.php/Device_file">Device File - ArchWiki</a></li>
		</ul>
	</div>

	<div class="content" id="mounting-unmounting">

		<h2>Mounting and Unmounting</h2>

	    <p>
	        Unlike Windows systems, which create a new, distinct directory tree
	        for each storage device on the system (<code>C:\, D:\</code>, etc.),
	        Linux systems place new filesystems within the existing
	        directory structure, in an operation called
			<a href="https://www.man7.org/linux/man-pages/man8/mount.8.html"><em>mounting</em></a>.
			Because the directory structure is not rooted
			on a drive, it is more abstract than those of
			Windows lineage; in addition, the Linux directory tree
			is more stable over the duration of the machine's uptime.
			Finally, since the directory structure is not rooted in a drive,
			files may exist here that do not exist on drives.
		</p>

		<p>
			Let's take a look at the <code>mount</code> operation, for this is new.
			Suppose you have a usb stick with some music on it, and you'd
			like to access its contents.
			After it's plugged into your computer, the hardware, then the kernel,
			recognize it, but it is unaccessible:
		</p>

		<img style="width:80%" src="assets/img/mounting.png">

		<p>
			When mounting new devices manually, the usual method is to identify the device
			to be mounted with <code>lsblk</code>, then mount it with <code>sudo mount [DEVICE] [MOUNTPOINT]</code>.
			The device to be mounted should be a partition, and can usually be determined by its size and
			its mountpoint (which should be none).
			The Linux Filesystem Hierarchy Standard provides two places to mount temporary
			filesystems: <code>/mnt</code> and <code>/media/[user]/</code>
		</p>

		<p>
			Conversely, to unmount a filesystem, we first identify the correct
			partition with <code>lsblk</code>,
			then unmount it with <code>sudo umount</code>.
		</p>

		<p>
			A few pesky details:
			First, device names that appear in <code>/dev</code> or <code>lsblk</code>
			<em>are not</em> guaranteed to be stable across reboots&mdash; The devices are named in the
			order that they are found.
			Second, when mounting a new filesystem, if any files exist at the
			mount point, they will be "hidden" by the files of the new filesystem.
			They are not deleted, and unmounting the new filesystem will "reveal" them again.
		</p>


		<p>
			In practice, most distributions automatically mount
			usb sticks when they are plugged in.
		</p>

</div>
    <div id="regular-files" class="content">
        <h2>Regular Files</h2>

		<p>
			In Unix, a file is a sequence of bytes (Kernighan, 62).
			This definition is sufficiently abstract to allow, for instance, a keyboard
			to appear as a file.
			The kernel facilitates reading and writing of files,
			and otherwise refrains from interjection.
			This approach was quite novel for its time; earlier
			operating systems interposed upon the handling of files, so that
			some files could only be read by some programs, and not by others (Kernighan, 62).
			In my opinion, this begins <a href="https://en.wikipedia.org/wiki/Unix_philosophy">"The Unix Philosophy."</a>
		</p>

        <p>
            Regular files contain data.
			The Linux kernel continues the Unix philosophy by treating text files, programs, movies,
            source code, pdf's, etc., identically;
            any "special treatment," is implemented by user-space processes.
            Approximately 80% of files are regular files (Stevens, 98).
		</p>

		<p>
			We do interject upon reading and writing for the purposes of security and stability:
			Each file has an owner, and belongs to a group.
			Important files are owned by <code>root</code>, the superuser of the system.
			Because the owner of a given file is permitted to do anything to it, we typically wish
			to avoid acting as <code>root</code>, and instead use <code>sudo</code> wherever possible.
		</p>

		<p>
			Each file on the system has nine <em>access permission bits</em>,
			and the owner of the file can change these.
			They are:
			<code>read</code>, <code>write</code> and <code>execute</code> for each,
			<em>owner</em>, <em>group</em>, <em>everyone else</em>.
			These bits and other meta-data are maintained on-disk.
		</p>

		<p>
			Here we have a typical directory listing:
		</p>

		<a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for printable" ></a>

		<p>
			We see that <code>bash</code> is executable by anybody, but can
			only be written to by <code>root</code>.
			File mode bits can be changed with the
			<a href="https://www.man7.org/linux/man-pages/man1/chmod.1.html"><code>chmod(1)</code></a> utility.
		</p>

		<h3>A Short Example</h3>

		<div class="code">
			$ echo "hello world" > newfile <br>
			$ cat newfile <br>
			hello world <br>
			$ chmod -r newfile &emsp;&emsp;&emsp;&emsp; #Remove read permissions on newfile<br>
			$ cat newfile <br>
			cat: newfile: Permission denied <br>
		</div>

		<h3>See Also:</h3>
		<ul>
			<li><a href="https://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions">File Permissions (GNU Coreutils)</a></li>
			<li> <a href="https://www.man7.org/linux/man-pages/man1/chown.1.html"<code>chown(1)</code></a></li>
		</ul>

        </div>

		<div id="directories" class="content">
			<h2>Directories</h2>



			<p>
				A directory is implemented in Linux as a file with two columns:
				Filename and inode number.
				We list the contents of a directory with the usual <code>ls</code> command;
				we can list a file's inode number using <code>ls -i</code>:
			</p>

			<div class="code">
				/home/josh/studies$ ls -i newfile <br>
				2112949 newfile
			</div>

			<p>
				The inode number serves as the reference to the data a given file contains,
				in addition to metadata, such as size.
				Inodes are stored statically, on-disk, in the form
				of an array at the beginning of the disk partition;
				the <em>inode number</em> serves as an index into this array.
			</p>

			<p>
				In addition, the inode serves as a layer of indirection between
				a filename and the file's contents (more on this later).
				The directory tree is the responsibility of the kernel, so that
				user-space applications do not (cannot) interact with directories
				directly.
				Specific system calls exist to
				create directories,
				remove directories,
				and get directory entries.
			</p>

			<p>
				Each process has a <em>current working directory</em>, whose
				value is maintained by the kernel; changing a process's
				current working directory requires the use of a system call.
			</p>

			<h3>Hard Links</h3>
			<p>
				The inode of a file serves as a layer of indirection between a
				file's name and its contents:
				A file (the contents) may have more than one filename referring to it.
				This means that a file can have
				more than one entry in the directory tree.
				Each such name is called a <em>hard link</em>.
			</p>

			<p>
				In particular, each directory has the special entry
				with filename <code>.</code> ("dot"),
				which refers to that directory itself.
				In addition, each directory contains the entry <code>..</code> ("dot dot"),
				which refers to the parent directory (up one level in the hierarchy).
				The root directory's parent directory is the root directory itself.
			</p>

			<h3>Symbolic Links</h3>
			<p>
				Hard links cannot cross filesystem divisions.
			</p>

			<h3>See Also:</h3>
			<ul>
				<li><a href="https://unix.stackexchange.com/questions/20670/why-do-hard-links-exist">Why do hard links exist?</a></li>
			</ul>

		</div>

		<div id="engineer-man" class="content">
			<h2>Engineer Man</h2>
			<iframe class="video" src="https://www.youtube.com/embed/UFIoRLqhFpo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
		</div>

        <div id="references" class="content">
            <h2> References </h2>
            <ol>
				<li> Filesystem Hierarchy Standard Group. <a href="https://www.pathname.com/fhs/pub/fhs-2.3.pdf">The Linux Filesystem Heirarchy Standard</a>.  Retrieved May 29, 2020.</li>
				<li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
				<li> Stevens, W. Richard. <i><a href="http://www.apuebook.com/apue3e.html"> Advanced Programming in the Unix Environment.</a></i> Pearson Eduction, 2013.</li>

			</ol>

        </div>
