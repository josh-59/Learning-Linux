---
layout: default
title: The Linux Filesystem
---
<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#filesystems"> Filesystems </a></li>
        <li><a href="#regular-files"> Regular Files </a></li>
        <li><a href="#dotfiles"> Dotfiles </a></li>
        <li><a href="#references"> References </a></li>
        <li><a href="#credits">Credits and Licenses</a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>The Linux Filesystem</h1>
    <!-- <h4>In the beginning, there was a filesystem.</h4> -->
    <h4>Under Construction!</h4>

    <p>
        Unix began life as a filesystem; on top of this was created the means
        of interacting with it, initially composed of an <code>exec</code>
        function, shell, text editor and assembler (Kernighan 33-34).
        Created by Ken Thompson, this small software suite formed the nexus of
        the time-sharing operating system that would eventually be called
        <em>Unix</em>.
    </p>

    <p>
        This file-first approach to operating system design is found in
        the implementation as well as the history of Unix and its derivatives;
        concurrently, there is a lot to be said about files.
        This paper aims to introduce the notion of a filesystem, and
        describe the structure and uses of the file hierarchy.
    </p>
</div>

<div id="filesystems" class="content">
    <h2> Filesystems </h2>
    <p>
        A filesystem is a systematic method of organizing data on disk.<sup><a href="https://wiki.osdev.org/Filesystem">[1]</a><a href="https://wiki.archlinux.org/index.php/File_systems">[2]</a></sup>
        Conceptually, it is similar to a data structure, in that it defines a convention
        to be followed to store and retrieve data.
        Preparing a drive (address space) for use by a particular filesystem <a href="https://docs.fedoraproject.org/en-US/fedora/f28/install-guide/appendixes/Disk_Partitions/">is known as formatting</a>.
    </p>

    <ul>
        <h3>Some Common Filesystems:</h3>
        <li>
            <p>
                EXT4:
                Introduced in 2008,<sup><a href="https://en.wikipedia.org/wiki/Ext4">[1]</a></sup> EXT4 is the most common filesystem used on Linux
                today.  It is an evolutionary enhancement on EXT3,
                supporting larger filesizes, deeper subdirectory support,
                faster handling of large files, along with many other improvements.<sup><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">[3]</a></sup>
                It is mature, fast, and stable.
            </p>
        </li>

        <li>
            <p>
                ZFS: Introduced in 2005,<sup><a href="https://en.wikipedia.org/wiki/ZFS">[2]</a></sup> ZFS incorporates fancier features that are generally
                out of place on the working-man's Linux Desktop.
                ZFS was developed by Sun Microsystems, and became closed-source with Sun's acquisition by
                Oracle.<sup><a href="https://en.wikipedia.org/wiki/ZFS">[2]</a></sup>
                It is intended for enterprise use, and is
                <a href="https://en.wikipedia.org/wiki/ZFS#Inappropriately_specified_systems">relatively easy to configure improperly.</a>

                Also, it is <a href="https://wiki.archlinux.org/index.php/ZFS">not free.</a>
            </p>
        </li>

        <li>
            <p>
                FAT32: The "File Allcoation Table 32-bit" is a DOS-era filesystem,<sup><a href="https://en.wikipedia.org/wiki/File_Allocation_Table#FAT32">[3]</a></sup>
                and is widely supported, though antiquated.
                In particular, it is not a <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling filesystem</a>,
                so that changes to data are not recorded before being carried out (increasing the likelihood of
                corruption in the event of, say, power outage).
                It is often used to hold the bootloader, since it is virtually guaranteed to be supported by firmware.
            </p>
        </li>
    </ul>
</div>

<div id="directory-structure" class="content">
    <h2> Directory Structure</h2>

    <p>
        On Linux and other Unix-like systems, the directory tree begins at <em>root</em>,
        <code>/</code>, and contains all files on the system.
        This directory structure is defined by the
        <a href="https://www.pathname.com/fhs/pub/fhs-2.3.pdf">Linux Filesystem Heirarchy Standard</a>,
        which is maintained by the Linux Foundation.
    </p>

    <p>
        Within any GNU/Linux distribution, some common themes are found.
        For instance, <code>bin</code> directories are found in several places, such as
        <code>/bin</code> and <code>/sbin</code>, along with <code>/usr/bin</code> and often
        <code>/home/user/bin</code>.
        This system reports no less that 89 directories named "bin."
        Each of these contain executable files (programs), which
        can be ran as commands from the shell.
    </p>

    <p>
        As per the standard, <code>/etc</code> (usually read "<em>et</em>-c") contains host-specific
        system configuration files; as a consequence, you can expect to mess around
        in this directory when configuring the system for the first time
        (or otherwise).
        It contains, for instance, files describing the configuration of the system's package
        manager (if any), printers, and, well, etcetera.
    </p>

    <p>
        Unlike Windows systems, which mount a new, distinct directory tree
        for each storage device on the system (<code>C:\, D:\</code>, etc.),
        Linux and other Unix-like systems mount new devices on the existing
        directory tree, using the "mount" command.
        Although the directory hierarchy has two distinct places to facilitate this,
        <code>/mnt</code> and <code>/media</code>, as super-user, one is free
        to mount a new filesystem just about anywhere.

        So, for instance,
	</p>

        <div class="code">
            $ sudo mount /dev/sda2 /home/josh
        </div>

	<p>
        would mount the second partition of the device "sda" to
        <code>/home/josh</code>; its contents would then be available there.
    </p>

    <p>
        This mounting facility is often used to separate logically distinct
        data, by keeping them on physically different partitions.
        For instance, user data, contained in the <code>/home/</code> directories,
        can be separated from system data by keeping it on a different partition;
        by mounting the partition at <code>/home/</code>, this
        separation is transparent to any user.
    </p>

    <p>
        Pretty spiffy!
    </p>

</div>

</div>
    <div id="regular-files" class="content">
        <h2>Regular Files</h2>

        <p>
            Regular files contain data.
            The contents of a regular file are not, in the general case, the business of the operating system.
            The operating system is tasked only with preserving data in a bit-perfect
            manner.
			That means that the Linux kernel treats text files, binaries, movies,
            source code, pdf's, etc., identically,
            and that any "special treatment," is implemented by user-space processes.
		</p>

		<p>
            Approximately 80% of files are regular files (Stevens, p 98).
			We can verify this ourselves, by dividing the number of regular files,
		</p>

			<div class="code">
				$ sudo find / -type f | wc -l
			</div>
			<p>
				by the number of total files,
			</p>
			<div class="code">
				$ sudo find / | wc -l
			</div>
			<p>
				I arrive at 76%.
			</p>

		<p>
			Each file on the system has nine mode bits:
			<code>read</code>, <code>write</code> and <code>execute</code> for each,
			<em>owner</em>, <em>group</em>, <em>everyone else</em>
			(<a href="https://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions">GNU Coreutils, section 27</a>).
			These are maintained by the filesystem along with other metadata about the file, such as size and location on-disk.
			For instance, the operating system will not even consider trying to execute a file if its
			appropriate executable bit is not set (but will allow you to pass the file as an argument to an executable).
		</p>

		<p>
			Mode bits are viewable with <code>ls -l</code>
		</p>

		<a href="assets/img/ls-long.pdf" target="_blank"><img src="assets/img/ls-long.png" style="width: 100%" title="Click for printable" ></a>

		<p>
			Here we can see that <code>bash</code> is executable by everyone, but only writable by <em>root</em> (click image for printable).
		</p>

		<div class=aside-right>
			<h4>Aside: Shebang</h4>
			Suppose a plaintext file has its executable bit set,
			and one tries to execute the file.
			It's clearly a script, right?
			The first line of such a script is often,
			<code>
				 #! /usr/bin/sh
			 </code>
		</div>

		<p>
			The mode bits can be changed with the <code>chmod</code> utility.
			A common operation is setting the executable bit:
            chmod +x:
            Change the way the operating system handles a file;
            <i>in addition</i> to the above, the operating system can now
            "execute" the file:
            Binary
            #! /usr/bin/XXXXXXX
            Bash's behavior by default

            For instance, the ruby interpreter is a program, existant in my filesystem
            as a binary file compiled from C source code; to execute a ruby program,
            I pass the argument <tt>ruby my_example_program.rb </tt> to bash,
            causing the kernel to launch ruby with the argument file <tt>my_example_program.rb</tt>.
        </div>

        <div id="dotfiles" class="content">
            <h2>Dotfiles</h2>

        </div>

        <div id="references" class="content">
            <h2> References </h2>
            <ol>
				<li> Stevens, W. Richard. <i><a href="http://www.apuebook.com/apue3e.html"> Advanced Programming in the Unix Environment.</a></i> Pearson Eduction, 2013.</li>
            </ol>

        </div>
