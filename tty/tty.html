<!--
TODO
If it's not a translation: Email a copy of your derivative work
(in a format LDP accepts) to the author(s) and maintainer (could be
the same person).  If you don't get a response then email the LDP
(Linux Documentation Project): submit@en.tldp.org.

Incorporate Last Updated thing, perhaps in footer

Translate man-page references to
http://man7.org/linux/man-pages/man7/boot.7.html

READ:
http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Curses.pdf

http://www.samhallas.co.uk/repository/telegraph/teletype_story.pdf

Modern Library:
#include <termios.h>
  See man termios,

https://en.wikipedia.org/wiki/Linux_console

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/Kconfig?id=HEAD
-->

<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8"/>

<html>
<head>
  <link href="../style.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro&display=swap" rel="stylesheet">
  <title>tty: A Practical Introduction</title>
</head>

<div id="nav_bar_1" class="nav">
  <ul>
    <li> <a href="../index.html">Home</a></li>
    <li> <a class="active" href="#about">tty: A Practical Intro-<br>duction</a></li>
  </ul>
</div>

<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#history"> History </a></li>
    <li><a href="#two_way_flow"> Two-Way Flow </a></li>
    <li><a href="#controlling_the_terminal"> Controlling the Terminal </a></li>
    <li><a href="#closing_notes"> Closing Notes </a></li>
    <li><a href="#lgr_video"> An LGR Thing </a></li>
    <li><a href="#references"> References </a></li>
    <li><a href="#credits">Credits and Licenses</a></li>
  </ul>
</div>

<div id="text_terminals" class="content">
  <h1> Text Terminals </h1>
  <h4> Under Construction! </h4>
  <p>
    A text terminal is a computer peripheral similar to a mouse and keyboard combination.
    However, whereas a modern monitor receives a pixel-wise description of output to display
    from the computer several times a second, a text terminal receives a description of
    the characters to display only once, and uses an onboard buffer to store that information.
    Text terminals are an archaic and largely obsolete technology, but were instrumental to the
    development of modern GNU/Linux.
    This paper looks at the technology and its ramifications seen in Linux today.
  </p>
</div>

<div id="history" class="content">
  <h2> History </h2>
  <p>
    The history of Unix is well outside the scope of this discussion.
    However, a few facets are relevant to us.
  </p>

  <div class="aside_right">
    <h4>Aside:</h4>
    <i>Teletype</i> was a trade name of the Teletype Corporation, and was subsequently abbreviated to <i>tty</i>.
    <a href="http://www.pdp8.net/asr33/videos.shtml">The Model 33</a> was among the most popular of these,
    with around 600,000 units sold<sup><a href=#references style="text-decoration: none">[2]</a></sup>.
  </div>

  <p>
    First, computers of the 1960's and 70's were expensive.
    The "Programmed Data Processor-7," which the first inklings of Unix can be traced to<sup><a href=#references style="text-decoration: none">[1]</a></sup>,
    would have cost the equivalent of about $600,000 in 2020, and shipped with 18 kilobytes of memory.
    These computers were bought and maintained by
    organizations, with the idea of developing timesharing (i.e., multiuser) operating systems.
    In fact, it was once envisioned that computing would be offered as a utility,
    piped into homes and businesses like telephone or electricity.
    This vision formed the impetus of Multics, the precursor to Unix<sup><a href=#references style="text-decoration: none">[1]</a></sup>.
  </p>

  <p>
    Second, the technological state of the 1960's included the <a href="https://mysite.du.edu/~jcalvert/tel/teletype.htm"<i>teletypewriter</i></a>,
    a device for sending telegrams.
    These were, essentially, remote-controlled typewriters, and in the 1960's, they were repurposed to
    interface with computers.
    The resulting abstraction formed the basis of the input/output mechanism of early interactive computing.

    Paper-based terminals persisted well into the 1970's, and later electronic typewriters
    <a href="https://www.youtube.com/watch?v=z-u4kUeIqDI">sometimes support "terminal mode,"</a>
    allowing them to interface with computers via serial cable.
  </p>

  <center>
    <a href="http://bitsavers.org/pdf/dataTerminalsAndCommunications/DTC-302_Brochure.pdf">
      <img height=500 src="tty_terminal.jpeg" href="http://bitsavers.org/pdf/dataTerminalsAndCommunications/DTC-302_Brochure.pdf"> </img>
      <br>
    </a>
    DTC-302 HyWriter, released 1976
  </center>

  <p>
    As interactive computing became more popular, hard-copy terminals were phased out in favor of
    screen-based entities.
    The resulting devices, referred to as <i>text terminals,</i> consisted of a monitor and a keyboard;
    the monitor was unlike a modern monitor in that it contained a buffer
    (on the order of a few kilobyte<sup><a href=#references style="text-decoration: none">[3]</a></sup>)
    which maintained the text currently on screen, and in that it contained a character-to-bitmap font table to be referenced
    when drawing each character; that is, it included its own font.
  </p>
  <a class="img_left" title="The original uploader was Frotz at English Wikipedia. / CC BY-SA (http://creativecommons.org/licenses/by-sa/3.0/)" href="https://commons.wikimedia.org/wiki/File:VT78.jpg"><img width="300" alt="VT78" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/de/VT78.jpg/512px-VT78.jpg"></a>

  <p>
    The computer itself was not required to draw each character on-screen; that was the responsibility of
    the terminal.
    Rather, the mainframe was only expected to tell the terminal <i>which</i> characters to draw, once.
    Users would sit at a terminal, connected to a (possibly distant) machine, would type in
    programs, issue commands, enter data, etc.; a serial cable connected this I/O device to the computer,
    and it was termed a <i>terminal,</i> since it was located at the terminal end of this cable.
  </p>
  <a class="img_right" title="Jacek RuÅ¼yczka / CC BY-SA (https://creativecommons.org/licenses/by-sa/3.0)" href="https://commons.wikimedia.org/wiki/File:VT420_with_German_keyboard.jpg"><img width="350" alt="VT420 with German keyboard" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/VT420_with_German_keyboard.jpg/512px-VT420_with_German_keyboard.jpg"></a>

  <p>
    The text terminal <a href="https://www.vt100.net/dec/vt_history">was used for decades</a> as the principle means of interactive computing.
    Today, text terminals are obsolete, but the abstraction persists in both modern Linux and Unix,
    via emulated terminals, virtual terminals, tty device files, and the associated back-end software required to support them.
  </p>

  <p>
    It's worth noting that the idea of mainframe-driven utility computation suggests that the computer's organization
    follows the sctructure of a mathematical tree:
    The "root user" would sit at the root of this tree, exercising super-user priveledges over the machine,
    while end-users would be positioned at the leaves of the tree.
  </p>

  <br>
  <center>
    <a class="img_cntr" title="Methem (Mikko J. Putkonen) / Public domain" href="https://commons.wikimedia.org/wiki/File:Email_terminals_at_Oulu_uni_2008.jpg"><img width=100%; alt="Email terminals at Oulu uni 2008" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ee/Email_terminals_at_Oulu_uni_2008.jpg/1024px-Email_terminals_at_Oulu_uni_2008.jpg"></a>
  </center>
</div>

<div id="two_way_flow" class="content">
  <h2> Two-Way Flow </h2>

  <div class="aside_right" style="width: 30%;">
    <center><b><tt>/dev</tt></b></center>
    /dev/tty&emsp;Controlling Console <br>
    /dev/tty0		Current virtual console <br>
    /dev/tty1		First Virtual Console <br>
    /dev/tty2   Second Virtual Console <br>
    /dev/tty3		Third Virtual Console <br>
    &emsp;&emsp;&emsp;.<br>
    &emsp;&emsp;&emsp;.<br>
    /dev/tty63	63rd Virtual Console <br>
    <br>
    <br>
    /dev/console System Console<br>
    /dev/ptmx/ &emsp;PTY Master
    /dev/pts/ &emsp;&emsp;PTY Slaves<br>
    <br>
    <center>
      Source: <br>
      <i> <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html"> Kernel.org Admininstrator's Guide </a> </i>
    </center>
  </div>

  <p>
    The typical terminal is connected to a computer by a full-duplex communication pipeline.
    In days' past, this was a serial port.
    The Unix environment presents abstractions of these connections as special device files.
    Located in <tt>/dev</tt>, these files are available to each user-space process
    using a terminal for input or output.
    A program can open, read from and write to a tty file, with the operating system
    being responsible for the details.
    By this method, a user-space program has access to nontrivial, if elementary, input and output,
    by the trivial method of file access.
    Moreover, for a Unix system accessed through a terminal, the flow of data
    through the tty files represents the entirety of input and output.
  </p>

  <p>
    Common to all tty devices is the application of a kernel module called
    the <i>terminal line discipline</i>, which serves to interpret
    input and produce a more human-amiable interface.
    This is discussed in more detail in the next section, Controlling the Terminal.
  </p>

  <h3> Virtual Terminals: <br><tt>/dev/tty1</tt> thru <tt>/dev/tty63</tt> </h3>
  <p>
    Virtual terminals are the closest re-imaging of the classical terminal
    interface to be found in modern operating systems.
    They are full-screen terminal displays on the system video monitor,
    and are accessible by pressing the key combination CTRL+ALT+F[1-9].
    You may log in to different virtual terminals simultaneously,
    and thus have a few different sessions with the computer going on at the same time.
    In the example below, 'josh' (me) owns the second virtual terminal
    (in fact, it's because I'm signed in there!).
  </p>

  <div class="code">
    ls -lF /dev/tty[0-9] <br>
    crw--w---- 1 root tty 4, 0 Mar 31 06:29 /dev/tty0 <br>
    crw--w---- 1 root tty 4, 1 Mar 31 05:33 /dev/tty1 <br>
    crw------- 1 josh tty 4, 2 Mar 31 06:28 /dev/tty2 <br>
    crw--w---- 1 root tty 4, 3 Mar 31 05:33 /dev/tty3 <br>
    crw--w---- 1 root tty 4, 4 Mar 31 05:33 /dev/tty4 <br>
    crw--w---- 1 root tty 4, 5 Mar 31 05:33 /dev/tty5 <br>
    crw--w---- 1 root tty 4, 6 Mar 31 05:33 /dev/tty6 <br>
    crw--w---- 1 root tty 4, 7 Mar 31 05:33 /dev/tty7 <br>
    crw--w---- 1 root tty 4, 8 Mar 31 05:33 /dev/tty8 <br>
    crw--w---- 1 root tty 4, 9 Mar 31 05:33 /dev/tty9 <br>
  </div>

  <p>
    Virtual terminals are more than just a throwback to multiuser operating
    system days:  They allow access to the machine
    without a graphical user interface and, in particular, without the associated
    software (namely, without a window server, window manager, and desktop environment).
    In modern desktop GNU/Linux distributions, it is often the case that
    GUI-based systems software is merely
    an additional front-end layer to command-line tools
    (a common example is the
    <a href="https://www.nongnu.org/synaptic/"> Synaptic Package Manager</a>).
    That is, the command-line interface usually offers more and finer control over
    the machine, through less and more robust software;
    virtual terminals are still relevant within the context of server applications.
  </p>

  <p>
    The user of a modern GNU/Linux distribution running a GUI is usually logged into the
    seventh virtual terminal, <tt>/dev/tty7</tt>.
    For completeness' sake, we will briefly explore how it is that the system arrives in this
    state.
    At the end of the kernel's boot sequence, the kernel launches a single
    user-space process with root permissions
    <sup><a href=#references style="text-decoration: none">[4]</a></sup>
    <sup><a href=#references style="text-decoration: none">[5]</a></sup>
    (commonly, <i>systemd</i>).
    This process then launches the local window system, which, in turn, logs in at
    an empty virtual terminal.
    Usually, this process is X Window Server; X usually logs in to tty7,
    and then launches the graphical user interface
    <sup><a href=#references style="text-decoration: none">[6]</a></sup>.
    One can emulate this sequence by logging into a virtual terminal as root and launching
    the system's window server by, on this machine, <tt>startx</tt>.
  </p>

  <p>
    <tt>/dev/tty0</tt> is a somewhat special virtual terminal device files because it is
    a synonym for the current virtual terminal.
    That is, if you are currently looking at the second virtual terminal, <tt>tty2</tt>, then data sent to <tt>tty0</tt>
    is sent to <tt>tty2</tt> (and not any other terminal).
    See <a href="https://unix.stackexchange.com/questions/60641/linux-difference-between-dev-console-dev-tty-and-dev-tty0">
      this unix.stackexchange answer</a> for more information, and a demonstration.
  </p>

  <h3>The Controlling Terminal:<br> /dev/tty </h3>
  <p>
    <tt>/dev/tty</tt> is a handle to the process's current tty device, if it exists
    <sup><a href=#references style="text-decoration: none">[7]</a></sup>.
    It is, effectively, a process-specific file: Any process that is connected to a terminal
    may access its terminal here
    <sup><a href=#references style="text-decoration: none">[8]</a></sup>.
  </p>

  <h4> Demonstration </h4>
  <ol>
    <li> Open up two terminal emulators</li>
    <li> Navigate each to <tt>/dev</tt></li>
    <li> In each, confirm that <tt>tty</tt> exists, is a character device, and has universal write permissions</li>
    <li> In each, confirm that writing to <tt>tty</tt> (e.g. <tt>echo "stuff" > tty</tt>) does not write to the other </li>
  </ol>

  <h3> Pseudoterminals: <br>pts/ </h3>
  <p>
    From
    <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html"> Kernel.org Documentation</a>,
    "Pseudoterminals are used to create login sessions or provide other capabilities
    requiring a TTY line discipline to arbitrary data-generation processes."
    Pseudoterminals have no physical devices connected; rather, they are
    intended to pipe information through the kernel's terminal line discipline
    by connecting two distinct points in the file system,
    a <i>master</i>, <tt>/dev/ptmx</tt>, and a
    <i>slave</i>, a file with an integral filename, found in <tt>/dev/pts</tt>.
  </p>

  <div class="aside_right">
    <h4> Aside </h4>
    <p>
      Historically, there have been
      <a href="https://www.tldp.org/HOWTO/Text-Terminal-HOWTO-2.html">many names for terminal devices.</a>
      This essay develops <i>terminal</i> exclusively, for the sake of
      clarity and relevance in the modern domain.
      The only other synonym in common usage is "console," as in, <i><tt>/dev/tty1</tt>
      through <tt>/dev/tty7</tt> are virtual consoles</i>
      <sup><a href=#references style="text-decoration: none">[9]</a></sup>.
      </p>
    </div>

    <p>
      Formally, a user-space process opens the common "master" side, <tt>/dev/ptmx</tt>,
      as an ordinary file.
      The kernel responds by returning a new file descriptor,
      and also by creating a new <i>slave</i> device file in <tt>/dev/pts</tt>.
      The process can then call <tt>ptsname(int fd)</tt>, passing the file
      descriptor given by opening the master side, whereby the kernel will return
      the pathname to the corresponding slave (terminal) device file.
    </p>

    <p>
      At this point, the process can treat the slave side of the pipe
      as a tty device, and the kernel will modify the stream as
      appropriate.
      The most common use of pseudoterminals is by terminal emulator programs.
      See <a href="https://linux.die.net/man/4/ptmx"> man 4 ptmx </a> and
      <a href="https://linux.die.net/man/3/ptsname"> man 3 ptsname </a>
      for more information.
    </p>

    <p>
      There are a lot of things you can do with pseudoterminals, and studying
      them goes a long way towards understanding the Unix filesystem concept.
      What you're doing is, you're piping a stream of characters through the kernel,
      and requesting that the kernel modify this stream in a way peculiar to
      a kernel module called the "terminal line discipline."
      We'll get into more detail about the terminal line discipline in the
      next section.
    </p>

    <h4> Demonstration </h4>
    <ol>
      <li> Open exactly two terminal emulators</li>
      <li> Navigate one to <tt>/dev/pts</tt></li>
      <li> List the directory contents and note its entries (should be nonempty)</li>
      <li> For each integral entry, write a string to the file, (e.g., <tt>echo hello &gt; 2</tt>) </li>
      </ol>


      <h3> The Commander's Chair: <br><tt>/dev/console</tt> </h3>
      <p>
        This is the superuser's device.
        Kernel error and other messages are sent here
        <sup><a href=#references style="text-decoration: none">[9]</a></sup>, and the device
        is owned entirely by the root user:
      </p>

      <div class="code">
        ls -lF /dev/console<br>
        crw------- 1 root root 5, 1 Mar 31 05:33 /dev/console
      </div>

    </div>

      <div id="controlling_the_terminal" class="content">
        <h2> Controlling the Terminal </h2>



          <p>
            For all text terminals, bytes flow from the keyboard to the computer, and bytes flow from the computer to the screen.
            In particular, bytes do not flow from the keyboard to the terminal's monitor;
            the reflection of typed characters on-screen is a function of the computer itself,
            and not a function of the terminal.
            We can shut off this functionality by the following:
          </p>

          <p>
            From the shell,
            <div class="code">
              stty -echo
            </div>
          </p>

          <p>
            Or, in a Posix-conforming environment,
            <div class="code">
              #import &lt;termios.h&gt;<br>
              <br>
              [...]<br>
              <br>
              // Turn off echo, so typed user input does not show up<br>
              assert( tcgetattr(STDIN_FILENO, &term) >= 0 );<br>
              term.c_lflag &amp;= ~ECHO;<br>
              assert( tcsetattr(STDIN_FILENO, TCSANOW, &term) >= 0 );<br>
            </div>
          </p>

          <p>
            This is useful for writing "interactive" or menu-driven programs;
            in either case, we must remember to turn it back on again.
          </p>

          <p>
            It's worth repeating at this point that the terminal <i>proper</i> only sends a stream of bytes, and
            merely receives a stream of bytes.
            That is, the only method of sending data to the monitor is by the same channel as
            printable characters.
            As a consequence, it is necessary to establish some common standard for communicating to the terminal
            non-printable, or control, characters, such as "newline."
            In the US, printable characters were traditionally mapped via ASCII (with the exception of <a href="https://en.wikipedia.org/wiki/EBCDIC"> some early IBM mainframes</a>).
            The first 32 ASCII characters are control characters, rather than printable;
            they include the famous <i>bell</i> character, and both <i>tab</i> and <i>newline</i> (aka, "linefeed").
            In particular, in order to delete previously written text, one can print the backspace
            character (typically, "<tt>\b</tt>").
            Most of these control characters quickly became antiquated, so that the majority are not widely used.
          </p>

          <p>
            For instance, ASCII alone does not provide provisions for moving the cursor or scrolling.
            As a consequence, ANSI escape sequences were implemented in the terminals.
            These begin with the ASCII "escape" control character (decimal 27)
            and the left-bracket "<tt>[</tt>" printable<sup><a href="#references">[10]</a></sup>, and are entirely ASCII sequences.
            Technically, these sequences are terminal-specific, but they are still viable today because modern emulators <a href="https://unix.stackexchange.com/questions/43945/whats-the-difference-between-various-term-variables">implement a superset</a> of deprecated terminals' escape sequences.
            Within C, to print <tt>Hello World!</tt> in reverse, we could do

            <div class="code">
              #include &lt;stdio.h&gt;<br>
              <br>
              int main() {<br>
                &emsp;&emsp;&emsp;&emsp;printf("\033[7m Hello World! \033[m"); <br>
              }<br>
            </div>
          </p>

          <p>
            So, by merely printing a special sequence through stdout to the terminal, we have
            modified the behavior (state) of the recipient terminal.
            A few notes:
            <ol>
              <li> <tt>033</tt> above is octal format, with decimal equivalent 27. </li>
              <li> This "setting" persists (try omitting the trailing <tt>\033[m</tt> ) </li>
              <li> I'm such a dork </li>
              <li> To send an escape sequence via console, type CTRL+V, then ESC; <br>you should see <tt>^[</tt></li>
              <li> Why can't you just type <tt>^[</tt>?  <a href="http://unixwiz.net/techtips/termios-vmin-vtime.html"> Don't ask.</a> </li>
            </ol>
          </p>

          <p>
            <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php"> There are often hundreds of such escaped sequences</a>,
            including such novelties as "set smooth scroll"; most real terminals can even change fonts.
            Some escape sequences may take parameters such as coordinates;
            the parameters become part of the escape sequence<sup><a href="#references">[11]</a></sup>.
          </p>

          <p>
            Terminal input is a different animal. To explain, we must start at the root.
            The terminal keyboard sends <i>scancodes</i> to the computer<sup><a href="#references">[12]</a></sup>.
            These are received and interpreted by the terminal device driver, yielding <i>keycodes</i>, then, within the same driver, ASCII.
            The settings for this driver can sometimes be accessed via operating-system settings but are typically one-time-only configuration settings.
          </p>

          <p>
            The information is then passed, within the kernel, to the famous "terminal line discipline,"
            purveyor of headaches, which is a kernel module tasked with the majority of computer-side terminal interpretation, and home to the <a href="http://man7.org/linux/man-pages/man3/termios.3.html">termios struct.</a>
            By default it is set to "Cannonical" mode so that, for instance, echo is on and input is buffered line-wise (among many, many other things).
            Getting your hands on a termios struct demands a system call; for more information, see <a href="http://www.apuebook.com/apue3e.html">Advanced Programming in the Unix Environment</a>.
          </p>

          <div class="aside_right">
            <h4> Aside </h4>
            <p>
              The first implemen- tations of Unix were ran without line-discipline, aka "raw mode."<sup><a href="#references">[13]</a></sup>
            </p>
          </div>

          <p>
            The terminal line discipline is positioned between the keyboard's hardware driver and the read/write system call interface provided by the kernel;
            concurrently, it receives all characters coming from the driver (in particular, character combinations such as CTRL+S and CTRL+D).
            It is the terminal line discipline's job to map some of these onto special characters.
            Special characters are control sequences, but in the other direction.
          </p>

          <div class = "aside_left">
            <h4> Aside: X Window System </h4>
            The X Window System serves a role roughly analgous to the terminal line discipline:
            It facilitates the interaction between mouse, keyboard and monitors with application programs,
            though it exists in user-space rather than kernel-space.
            It is <i>server</i> it controls system resources,
            and provides an interface for other programs to interact with<sup><a href="#references">[14]</a></sup>.
          </div>

          <p>
            For instance, the CTRL+S key combination is often mapped to the STOP special character;
            upon receiving the input bound to this special character, the terminal line discipline stops (and stores) all input and output
            to and from the terminal.
            This can make it appear as though the terminal emulator has frozen, but it has not.
            Neither input nor output is discarded; pressing CTRL+Q (START) will send all queued input to the kernel's <tt>read()</tt> system call,
            and continue sending information out to the terminal monitor.
            The terminal then resumes normal operation.
          </p>

          <p>
            This was more useful in times' past, when the terminal was connected via phone line and its speed relatively slow:
            The effect of STOP was to pause scrolling.
            In addition, the bell character was traditionally sounded when output was stopped and the terminal
            line discipline's buffer became full, thereby warning the user that data was being discarded.
            From the command prompt, we can list special characters (and other terminal attributes) by,
          </p>

            <center><tt> stty -a </tt></center>

          <p>
            This lists all bindings to special characters, in addition to other terminal attributes, such as speed.
            There are eleven Posix-defined special characters, and most of them can be remapped through the <tt>termios</tt> struct<sup><a href="#references">[15]</a></sup>.
            In particular, the terminal line discipline is responsible for mapping characters to signals, such as CTRL-D to <tt>EOF</tt>;
            the terminal line discipline is where keyboard signals originate from.
          </p>

          <p>
            The termios struct is often manipulated by text-based programs,
            for instance, to turn off line-buffering and generate an interactive program.
            A common library for facilitating this is <a href="http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/intro.html">NCURSES</a>.
            Its sister libraries <tt>panel</tt>, <tt>menu</tt> and <tt>form</tt> provide an extension to the basic curses library.
          </p>

          <img width=100% src="tty_xmas.gif">

          <center style="font-size: 12pt;">
            Example from ncurses library
          </center>

          <p>
            For another example of nCurses usage, check out AlsaMixer (probably already installed)
          </p>

        </div>

        <div id="closing_notes" class="content">
          <h2> Closing Notes </h2>
          <p>
            Because the purpose of this article is to provide a practical introduction to terminals in general,
            I thought it appropriate to cover some of the key points of terminal use in Linux today.
          </p>

          <p>
            The most novel thing to recognize about terminals is that they exist, from the operating system's
            perspective, as an ordinary file.
            That <i>you read</i> from it is merely coincidental to what the file is connected to&mdash; namely,
            a buffer within a monitor or emulator.
            Likewise, data sent from the keyboard is not treated "specially" either&mdash; it, too,
            appears within the operating system's environment as data from an ordinary file.
          </p>

          <div class="aside_right">
            <h4> Aside </h4>
            <p>
              Desktop environments serve a role analagous to shells, but in GUI-based environments.
              In fact, they are sometimes called <i><a href="https://en.wikipedia.org/wiki/Shell_(computing)#GUI">Graphical Shells</a>.</i>
              My favorite is Cinnamon!  Which one is yours?
            </p>
          </div>

          <h3> Shell </h3>
          <p>
            Typically, when "interacting" with a computer, data from a tty file is read by a particular program called
            a <i>shell</i>.  There are many variants, such as the antiquated <tt>sh</tt>, its modern successor <tt>bash</tt>,
            the disused <tt>csh</tt> and the feature-laden <tt>zsh</tt>.
            Each of these are ordinary programs, and exist within a running operating system as an
            ordinary user-space processes; they have no special attributes or permissions.
            They simply read from a file (which might or might-not be your tty file) and execute commands; the commands they "know" are determined
            <i>by the shell itself</i>, and can be determined by looking at the <tt>PATH</tt> environment
            variable:

            <center><tt>echo $PATH</tt></center>
          </p>



          <p>
            Each shell command exists as an executable binary file in one of the resulting colon-separated directories.
          </p>

          <h3> Emulation </h3>
          <p>
            Terminal emulation is notoriously difficult,
            and is characterized by <i>which</i> terminal device you are emulating.
            The ANSI-standard escape sequences (which are still relevant today)
            were usurped almost immediately by the capabilities of DEC's VT-100 terminal.
            In almost every case, a new model implemented a superset of a previous model's features,
            so that a VT200-series terminal can-do anything a VT100 could-do
            <sup><a href="#references">[16]</a></sup>
            (and the VT100 was ANSI-compatible).
          </p>

          <p>
            Information about the capabilities of supported terminals is stored locally in a database known as <tt>terminfo</tt>
            <sup><a href="#references">[17]</a></sup>.
            Terminal emulators are typically backward-compatable with a VT100 (xterm is backward compatable with the VT220
            <sup><a href="#references">[18]</a></sup>,
            but often support additional capabilities, such as color, and have a distinct entry in the terminfo database.
          </p>

          <h3> Emulators </h3>

          <p>
            Some fun and interesting terminal emulators from around the web (suggestions/recommendations welcome!).
          </p>

          <p>
            <ul>
              <li> <a href="https://invisible-island.net/xterm/xterm.faq.html">xterm</a>&mdash; The standard terminal emulator for X Window System </li>
              <li> <a href="https://st.suckless.org/"> suckless st</a>&mdash; A terminal emulator that Sucks Less </li>
              <li> <a href="https://github.com/alacritty/alacritty "> alacritty</a>&mdash; GPU-accelerated terminal emulator </li>
              <li> <a href="https://github.com/GitSquared/edex-ui#screenshots">edex-ui</a>&mdash; A terminal emulator designed to make you look <i>insanely badass</i> </li>
          <p>
          </div>

          <div id="lgr_video" class="content">
            <h2> An LGR Thing </h2>
            <iframe width=100% height="650" src="https://www.youtube.com/embed/RuZUPpmXfT0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
          </div>

          <div id="references" class="content">
            <h2> References </h2>
            <p>
              <ol style="margin-left: 0">
                <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
                <li> Libes, Sol.  <i>Small Computer Systems Handbook</i>.  Published 1978, by Hayden Book Co. </li>
                <li> Lawyer, David S. <i>Text-Terminal-HOWTO</i> <a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html"> https://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html</a>.  The Linux Documentation Project.  Retrieved April 6, 2020. </li>
                <li> <a href="http://man7.org/linux/man-pages/man7/boot.7.html">man 7 boot</a>. The Linux Man-Pages Project. Written March 11, 2015.</li>
                <li> <a href="http://man7.org/linux/man-pages/man7/bootup.7.html">man 7 bootup</a>. The Linux Man-Pages Project.
                <li> <a href="https://askubuntu.com/questions/27339/what-is-tty7-in-the-commandline">"What is tty7 in the command line?"</a>.  AskUbuntu question, posed by Fusky.</li>
                <li> <a href="http://man7.org/linux/man-pages/man4/tty.4.html">man 4 tty</a>. The Linux Man-Pages Project. Published March 6, 2019.</li>
                <li> <a href="git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/Kconfig?id=HEAD">Kernel Driver Source</a>.  Maintained by Linux Torvalds.</li>
                <li> <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html">The Kernel Administrators Guide; Linux Allocated Devices</a>. </li>
                <li> <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php">ANSI Escape Sequences</a>. ASCII-Table.com.  Retrieved April 6, 2020.</li>
                <li> Lawyer, David S. <a href="http://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html#ss8.3"><i>Text-Terminal-HOWTO, Section 8.3: Escape Sequences and Control Codes</i></a>.</li>
                <li> Brouwer, Andries. <a href="http://www.tldp.org/HOWTO/Keyboard-and-Console-HOWTO-2.html"><i>The Linux Keyboard and Console HOWTO</i></a>. Published October 12, 2002.</li>
                <li> Ritchie, Dennis M.  <a href="https://www.bell-labs.com/usr/dmr/www/hist.pdf"><i>The Evolution of the Unix Time-sharing System*</i></a>.  Bell Laboratories, Murray Hill, New Jersey 07975.</li>
                <li> <a href="https://linux.die.net/man/7/x"> man 7 x </a>.  Written by X.Org Foundation, LLc.  Hosted by die.net hosting.</li>
                <li> Stevens, W. Richard. <i><a href="http://www.apuebook.com/apue3e.html"> Advanced Programming in the Unix Environment.</a></i> Pearson Eduction, 2013.</li>
                <li> Shuford, Richard S. <a href="https://invisible-mirror.net/archives/shuford/terminal/first_principles.html"><i>First Thoughts about Terminal Emulation</i></a>. </li>
                <li> Ben-Halim, Zeyd M., Raymond, Eric S., Dickey, Thomas E. <a href="http://man7.org/linux/man-pages/man5/terminfo.5.html">man 5 terminfo</a>.  The Linux Man-Pages Project. Retrieved April 6, 2020.</li>
                <li> Dickey, Thomas E.  <a href="https://invisible-island.net/xterm/xterm.faq.html#what_is_vt220"><i>"What is a VT220?"</i></a>. Retrieved April 6, 2020.</li>
              </ol>
            </p>
          </div>

          <div id="credits" class="content">
            <h2> Credits and Licensure </h2>
            <p>
              This was written by Josh Timmons, and was inspired by The Linux Documentation Project's
              <a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO-1.html"><i>Text Terminal How-To</i></a>, by David S. Lawyer.
              It is released under the <a href="https://creativecommons.org/licenses/by-nc/4.0/"> Creative Commons Attribution-ShareAlike 4.0 International license </a>.
              Please send any corrections or comments to <a href="mailto:josh.591536@gmail.com"> Josh Timmons</a>.
            </p>


          </div>
          <script
          src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
          integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
          crossorigin="anonymous"></script>
          <script src="../animate-nav-2.js"> </script>
          </html>

              <!-- Thanks for playing! https://www.youtube.com/watch?v=wvUQcnfwUUM -->
