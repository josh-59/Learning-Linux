---
layout: default
title: "The Command Line: A Tutorial Introduction"
last-updated: August, 2020
---

<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#bringing-up-the-command-line"> Bringing Up The Command Line</a></li>
    <li><a href="#shells-and-terminals"> Shells vs. Terminals </a></li>
    <li><a href="#some-shell-features"> Some Shell Features </a></li>
    <li><a href="#editing-text"> Editing Text </a></li>
    <li><a href="#globbing"> Globbing </a></li>
    <li><a href="#missing-semester"> Missing Semester </a></li>
  </ul>
</div>

<!--
    To Do:
    Echo $PATH
    which
    flags and options
        --help

    Elementary utilities:
        mv
        cp
        rm
        Why the short names?
            You would, too:  Alias <code>clear</code> to <code>c</code> or <code>cl</code>

    What you can expect to learn:
        The <code>clear</code> command actually just prints a special string
        to the terminal.
        Hence, you can capture its output with, clear > clrfile
        What happens when you try to view this file's contents with <code>cat</code>?


    ...You know what?  Just mirror Lecture 1 of Missing Semester below
-->

<div id="introduction" class="content">
    <h1>The Command Line:</h1>
    <h4>A Tutorial Introduction</h4>

    <p>
        As a user interface, the command-line is exceptionally powerful:
        Anything that can be done on a Unix-like system can be done through
        the command-line alone.
        This essay is intended to introduce a first-time user to it.
    </p>

    <p>
        Click any picture to zoom.
    </p>
</div>

<div id="bringing-up-the-command-line" class="content">
  <h2> Bringing Up The Command Line </h2>
  <p>
      On any machine, we access the command line through a <em>terminal.</em>
    On a default Mint installation, the terminal is available from the desktop:
  </p>

  <figure >
    <a href="assets/img/mint-terminal-screenshots/terminal-pointed.png"><img src="assets/img/mint-terminal-screenshots/terminal-pointed.png" style="width:100%;"></a>
  </figure>

  <p>
    Clicking on it once brings up the command line:
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/terminal.png"><img src="assets/img/mint-terminal-screenshots/terminal.png" style="width:100%;"></a>
  </figure>

  <p>
    Although there are other ways to access the command-line, in practice they
    are rarely used.
    On the left is the <em>prompt:</em>
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/terminal-prompt.png"><img src="assets/img/mint-terminal-screenshots/terminal-prompt.png" style="width:100%;"></a>
  </figure>

  <p>
    The prompt gives us useful information about the state of the shell.
    It's configurable, but this one is pretty common.
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/terminal-prompt-decorated.png"><img src="assets/img/mint-terminal-screenshots/terminal-prompt-decorated.png" style="width:50%;"></a>
  </figure>

  <p>
    The prompt being displayed tells us that the shell is ready to receive a command.
    So, let's try one:
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/echo.png"><img src="assets/img/mint-terminal-screenshots/echo.png" style="width:100%;"></a>
  </figure>

  <p>
    Here our command was <em>echo</em>.  This command simply prints out the <em>arguments</em>
    that were given to it.
    Our arguments were "Hello," and "World!"
    </p>

    <p>
    Incidentally, I will represent terminal commands by placing them on a separate line, in bold,
    with a leading <code>$</code> representing the prompt, like so:
    </p>

    <div class="code">
        $ echo Hello, World!
    </div>

    <p>
    You might think the <em>echo</em> utility is trivial, but in practice it's
    quite useful.
    It can be used to quickly create files, to display the value of shell variables
    and to debug commands before you use them.
    Oh, and the little outline square is called the "cursor."
    You can move it around with the arrow keys, but let's do something useful:
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/ls.png"><img src="assets/img/mint-terminal-screenshots/ls.png" style="width:100%;"></a>
  </figure>

  <p>
    Here we've used the command <code>ls</code> without arguments.
    This lists the files and directories in the current working directory.
    The current working directory is our location within the filesystem.
    Tilde ("~") represents home, which is (for this user) <code>/home/mint</code>.
    You can change directories with <code>cd</code>.
  </p>

  <p>
    Give it a shot: <code>cd</code> around, <code>ls</code> a bit, <code>exit</code>
    when you're done.
  </p>

</div>

<div id="shells-and-terminals" class="content">
  <h2> Shells vs. Terminals </h2>
  <p>
    A terminal <a href="text-terminals.html">used to be</a> a physical i/o device&mdash;
    a keyboard-plus-monitor setup.
    The only functionality it offered was text i/o; clearly,
    this implies a command line.
    This was the technological climate that Unix was created in.
    As terminals
    got replaced with proper monitors, the functionality
    of the terminal was preserved by terminal emulators, which is
    what we use today.
  </p>

  <p>
    The shell is the program which interprets and executes our commands.
    As depicted so far, it might appear that the shell exists "within" the terminal,
    but that is not the case, and it's a mistake to adopt that sentiment.
    Rather, the shell exists as a separately executing program, and <em>writes</em> to
    the terminal as though it were a file.
    Moreover, the shell gathers your input by <em>reading</em>
    from the terminal as though it were a file.
    This is possible because of the uniquely elegant file interface that
    was created for Unix.
  </p>

  <p>
    You might ask, "Why bother keeping the command-line?"
    The answer is that it's easy to write code that interprets (and prints)
    text, so the command-line represents a great abstraction layer for
    systems-level software.
    For instance, a few more interesting commands:
  </p>

  <ul>
    <li> <code>lscpu</code>&mdash; List CPU information </li>
    <li> <code>lsmem</code>&mdash; List memory information </li>
    <li> <code>df --all --human-readable</code>&mdash; Report file system disk space usage </li>
  </ul>

  <p>
    When the output of these commands is sufficiently stable, programmers
    can depend on them, allowing so-called <em>scripts</em> to be written.
    Taken to its limit, these commands can form
    the "back-end" for graphical programs.
    An example of this is the <a href="https://www.nongnu.org/synaptic/">Synaptic package manager</a>, which is a popular GUI
    frontend for Debian's <code>apt</code> collection of command-line tools.
    </p>

  <p>
    In addition, most programming tools (such as compilers and interpreters)
    often deal in simple text, so that the command line is a natural interface
    to them.
    Finally, with the inclusion of variables, conditionals,
    and loops, shells have become full-fledged programming languages of their own.
    </p>

    <p>
    Let's look at some more powerful constructs within Bash.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://guide.bash.academy/"> The Bash Guide </a></li>
    <li><a href="https://devblogs.microsoft.com/commandline/introducing-windows-terminal/">Introducing Windows Terminal</a> (Commands not guaranteed to be the same)</li>
  </ul>
</div>

<div class="content" id="some-shell-features">
  <h2> Some Shell Features </h2>

  <p>
    Some words are expanded by the shell before being executed.
    For instance,
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      How can you check?
    </p>
  </div>

  <div class="code">
    {1..6}
  </div>

  <p>
    expands to
  </p>

  <div class="code">
    1 2 3 4 5 6
  </div>

  <p>
    This is called <em>shell expansion,</em> and within Bash, becomes quite a
    topic.
    Shell variables are expanded with the <code>$</code> operator, as
    in the string <code>$myvar</code> below; variables are declared and
    given a value by giving their name followed without-space by an equals-sign:
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      How does the shell interpret,
      <br><center><code>$ myvar =12</code>?</center>
    </p>
  </div>

  <div class="code">
    $ myvar=12 <br>
    $ echo myvar <br>
    myvar <br>
    $ echo $myvar <br>
    12
  </div>

  <p>
    It's important to note that the shell deals in <em>strings</em> and <em>commands</em>,
    so that <code>myvar</code> is a string, and when expanded,
    contains the string composed of the letters <em>1</em> and <em>2</em>,
    and not the number twelve.
    We can tell Bash to deal in integers, but let's not bother just now.
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      And how can we assert the value of the variable <em>hello</em>?
    </p>
  </div>

  <p>
    What do you think this does?
  </p>

  <div class="code">
    $ hello='echo Hello, World!'<br>
    $ $hello
  </div>

  <p>
    Alright, scenario:  You're at work, and you haven't been doing anything.
    How can you create a bunch of files to make it <em>look</em> like you've
    been busy, without actually going through the trouble?
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      You can clean up with,
      <br><center><code>$ rm ./1.0*</code></center><br>
    </p>
  </div>

  <div class="code">
    $ mkdir work <br>
    $ cd work <br>
    $ for filename in 1.{01..9}.{01..20..2}; do<br>
    &gt; echo 'somesuch' > $filename <br>
    &gt; done
  </div>

  <p>
    Pretty spiffy, eh?
  </p>
</div>

<div class="content" id="editing-text">
  <h2>Editing Text</h2>
  <p>
    Alright, let's get some real work done.
    There are many terminal-based text editors available, but I recommend
    that you learn <a href="https://en.wikipedia.org/wiki/Vi">Vi</a>.
    It's available everywhere, and also, its controls
    are similar to those of the manual paging utility, which you can expect
    to use often.
    You can launch it with,
  </p>

  <div class="aside-right">
      <h4>Aside:</h4>
      <p>
          <code>Vi</code> has a several variants.
          A popular one is <code><a href="https://www.vim.org/">Vim</a></code>.
          I personally use <code><a href="https://neovim.io/">Neovim</a></code>,
          which is just a modern, extensible variant of Vi.
      </p>
  </div>

  <div class="code">
    $ vi [filename]
  </div>

  <p>
    Like most command-line tools, this one is intended for an experienced user,
    so there's a bit of a learning curve to it.
    It breaks down like this:
  </p>

  <p>
    Vi has <em>modes</em>.
    The default mode is called <em>normal mode,</em> and you can get to
    it from any other mode by pressing the escape key.
    From normal mode, you can exit Vi by typing a colon, followed by the
    letter 'q', like this
  </p>

  <div class="code">
    :q
  </div>

  <p>
    If you have unsaved work, this command will fail, and Vim will warn you.
    To discard your changes and exit anyway, type,
  </p>

  <div class="code">
    :q!
  </div>

  <p>
    You should familiarize yourself with these commands now.
  </p>

  <p>
    Similarly, to write your work to file, enter normal mode and type,
  </p>

  <div class="code">
    :w
  </div>

  <p>
    To save-and-quit,
  </p>

  <div class="code">
    :wq
  </div>

  <p>
    Soon enough, these controls are second-nature.
    How about modifying text?
    Well, we enter <em>insert</em> mode by pressing <em>i</em>
    from normal mode.
    From there, type away (and press escape to return to normal mode).
  </p>

  <figure style="padding-top: 10px;">
    <a href="assets/img/vim-adventures.png"><img src="assets/img/vim-adventures.png" style="width:100%;"></a>
    <figcaption><br><center><b>Vim Adventures</b></center></figcaption>
  </figure>

  <p>
    Now for moving around within text.
    The idea is that the controls are entirely at the home-row, so that
    one can quickly edit text.
    From normal mode, to move right, press <code>l</code> once.  To move left, press <code>h</code>.
    To move up, press <code>k</code>; and to move down, press <code>j</code>.
  </p>

  <p>
    These are best learned through practice, and there are a few good resources.
    One is <a href="https://vim-adventures.com/">(epilepsy warning!) Vim Adventures</a>.
    Another is <em>vimtutor,</em> available through the command line
    by executing,
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Vi distinguishes between upper- and lower-case commands, so make sure
      your caps-lock key is not pressed!
    </p>
  </div>

  <div class="code">
    $ vimtutor
  </div>

  <p>
    Finally, some useful commands:
  </p>

  <ul>
    <li><code>u</code>&mdash; undo</li>
    <li><code>v</code>&mdash; enter visual mode (highlighting; allows copying and pasting)</li>
    <li><code>y</code>&mdash; "yank" (copy)
    <li><code>p</code>&mdash; "put" (paste)
    <li><code>x</code>&mdash; delete</li>
    <li><code>dd</code>&mdash; delete a line</li>
    <li><code>o</code>&mdash; "open" a new line below</li>
    <li><code>O</code>&mdash; "Open" a new line above</li>
    <li><code>I</code>&mdash; "Insert" place cursor at the beginning of the line and enter insert mode</li>
    <li><code>A</code>&mdash; "Append" place cursor at end of line and enter insert mode</li>
    <li><code>a</code>&mdash; "append" insert text after cursor</li>
    <li><code>:help [term]</code>&mdash; Vim's onboard help system; enter colon-q (:q) to return to your document</li>
    <li><code>:q[uit]</code>&mdash; Quit the current window; if this is the last window, quit vim</li>
  </ul>

  <p>
    But, we don't always use a terminal-based text editor.  For an ordinary, stand-alone editor, I personally like
    <a href="https://atom.io">Atom</a> (with the 'minimap' plugin).  I've <a href="https://tkainrad.dev/posts/setting-up-linux-workstation/#text-editing-vscodehttpscodevisualstudiocom">heard good things</a>
    about VSCode, as well.  Also, some people like <a href="https://www.sublimetext.com/">Sublime</a>, but that one isn't free.
  </p>

  <p>
    You might have noticed that Vi and other applications
    "take control" of the terminal.
    How does this happen?
    Well, the secret is that Bash is still running&mdash; it's just waiting
    until the program returns.
    In fact, shells do this for each command executed: It launches and then waits.
    When the command returns, Bash then prints the prompt and asks for the next command.
    With Vi/Vim, it's just a protracted delay.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://stackoverflow.com/questions/14390519/whats-the-difference-between-b-and-b-in-vim"> Difference Between 'b' and 'B' in vim</a> (Vim-Adventures hint)</li>
    <li><a href="https://www.vim.org/docs.php"> Vim Documentation</a></li>
  </ul>
</div>

<div class="content" id="globbing">
  <h2> Globbing </h2>

  <p>
      Shell globbing introduces the fine art of matching strings via metacharacters.
      We'll keep this short, and consider only three such characters&dash;
      two wildcards and a way to describe sets of characters:
  </p>

  <ul style="list-style-type: none;">
      <li>
          <code>*</code>&emsp; Asterisk.  Matches zero-or-more of any character.
      </li>

      <li>
          <code>?</code>&emsp; Question Mark.  Matches zero-or-one of any character.
      </li>

      <li>
          <code>[ ]</code>&emsp; Brackets.  Matches exactly one of any of the characters contained.
      </li>
  </ul>

  <p>
      First, the asterisk, <code>*</code>,
      which matches zero-or-more of any character.
      Second, the question mark, <code>?</code>,
      which matches zero-or-one of any character.
      And finally, brackets <code>[ ]</code> denote a set of character to consider;
      a string must match exactly one character within the brackets.
  </p>

  <p>
    All other characters are treated literally.
    Hence,
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Most shells support <em>tab completion:</em>
      If you've typed enough of a command-name or filename to
      uniquely identify it, you can press "tab," and it will complete it for you.
    <p/>
  </div>

  <div class="code">
    $ echo *
  </div>

  <p>
    lists all files in the current directory, just like <code>ls</code> does;
  </p>

  <div class="code">
    $ ls *.pdf
  </div>

  <p>
    lists all files ending in <code>.pdf</code>, and
  </p>

  <div class="code">
    $ rm *.[gx]z
  </div>

  <p>
    removes all files ending in either <code>.xz</code> or <code>.gz</code>.
  </p>

  <h3> See Also: </h3>
  <ul>
    <li><a href="http://mywiki.wooledge.org/glob"> glob - Greg's Wiki </a></li>
    <li><a href="https://man7.org/linux/man-pages/man7/glob.7.html">glob(7)</a></li>
  </ul>
</div>

<div class="content" id="missing-semester">
    <h2 style="margin-bottom: 2pt;">Missing Semester</h2>
    <h4 style="margin-bottom: 20pt;">Lecture 1</h4>
    <iframe class="video" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
