---
layout: default
title: The Command Line - A Tutorial Introduction
last-updated: July, 2020
---

<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#bringing-up-the-command-line"> Bringing Up The Command Line</a></li>
    <li><a href="#shells-and-terminals"> Shells vs. Terminals </a></li>
    <li><a href="#more-shell-features"> More Shell Features </a></li>
    <li><a href="#editing-files"> Editing Files </a></li>
    <li><a href="#everythings-a-command"> (Almost) Everything is a Command </a></li>
    <li><a href="#bram-moolenaar"> Bram Moolenaar </a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>The Command Line - A Tutorial Introduction</h1>

  <p>
    As a user interface, the command-line is exceptionally powerful:
    Anything that can be done on a Unix-like system can be done through
    the command-line alone.
    This essay is intended to bring the reader "up to speed" on the use of the command line.
    Click on any image to zoom.
  </p>
</div>

<div id="bringing-up-the-command-line" class="content">
  <h2> Bringing Up The Command Line </h2>
  <p>
    We will assume that you are using <a href="https://www.linuxmint.com/">Linux Mint, Cinammon Edition</a>,
    a user-friendly, professional and powerful operating system.
    We access the command line through a <em>terminal.</em>
    On a default installation, the terminal is available from the desktop:
  </p>

  <figure >
    <a href="assets/img/mint-terminal-screenshots/terminal-pointed.png"><img src="assets/img/mint-terminal-screenshots/terminal-pointed.png" style="width:100%;"></a>
  </figure>

  <p>
    Clicking on it once brings up the command line:
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/terminal.png"><img src="assets/img/mint-terminal-screenshots/terminal.png" style="width:100%;"></a>
  </figure>

  <p>
    Although there are other ways to access the command-line, in practice they
    are rarely used.
    On the left is the <em>prompt:</em>
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/terminal-prompt.png"><img src="assets/img/mint-terminal-screenshots/terminal-prompt.png" style="width:100%;"></a>
  </figure>

  <p>
    The prompt gives us useful information about the state of the shell.
    It's configurable, but this one is pretty common.
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/terminal-prompt-decorated.png"><img src="assets/img/mint-terminal-screenshots/terminal-prompt-decorated.png" style="width:50%;"></a>
  </figure>

  <p>
    You'll spend a lot of time configuring the prompt :)
    The prompt being displayed tells us that the shell is ready to receive a command.
    So let's try one:
  </p>

  <figure>
    <a href="assets/img/mint-terminal-screenshots/echo.png"><img src="assets/img/mint-terminal-screenshots/echo.png" style="width:100%;"></a>
  </figure>

  <p>
    Here our command was <em>echo</em>.  This command simply prints out the <em>arguments</em>
    that were given to it.
    Our arguments were "Hello," and "World!"
    You might think the <em>echo</em> utility is trivial, but in practice it's
    quite useful.
    It can be used to quickly create files, to display the value of shell variables
    and to debug commands before you use them.
    Oh, and the little outline square is called the "cursor."
    You can move it around with the arrow keys, but let's do something useful:
  </p>



  <figure>
    <a href="assets/img/mint-terminal-screenshots/ls.png"><img src="assets/img/mint-terminal-screenshots/ls.png" style="width:100%;"></a>
  </figure>

  <p>
    Here we've used the command <code>ls</code> without arguments.
    This lists the files and directories in the current working directory.
    The current working directory is our location within the filesystem.
    Tilde ("~") represents home, which is (for this user) <code>/home/mint</code>.
    You can change directories with <code>cd</code>.
  </p>

  <p>
    Give it a shot: <code>cd</code> around, <code>ls</code> a bit, <code>exit</code>
    when you're done.
  </p>

</div>

<div id="shells-and-terminals" class="content">
  <h2> Shells vs. Terminals </h2>
  <p>
    A terminal <a href="text-terminals.html">used to be</a> a physical i/o device&mdash;
    a keyboard-plus-monitor setup.
    The only functionality they offered was text i/o; clearly,
    this implies a command line.
    This was the technological climate that Unix was created in.
    As terminals
    got replaced with proper monitors and mainframes with personal computers, the functionality
    of the terminal was preserved by terminal emulators, which is
    what we use today.
  </p>

  <p>
    The shell is the program which interprets and executes our commands.
    As depicted so far, it might appear that the shell exists "within" the terminal,
    but that is not the case, and it's a mistake to adopt that sentiment.
    Rather, the shell exists as a separate process, and <em>writes</em> to
    the terminal as though it were a file.
    Moreover, the shell gathers your input by <em>reading</em>
    from the terminal as though it were a file.
    This is possible because of the uniquely elegant file interface that
    was created for Unix.
  </p>

  <p>
    You might ask, "Why bother keeping the command-line?"
    The answer is that it's easy to write code that interprets (and prints)
    text, so the command-line represents a great abstraction layer for
    systems-level software.
    For instance, a few more interesting commands:
  </p>

  <ul>
    <li> lscpu&mdash; List CPU information </li>
    <li> lsmem&mdash; List memory information </li>
    <li> lsblk&mdash; List block devices (hard-drives, USB devices, etc.)</li>
  </ul>

  <p>
    Moreover, most programming tools (such as compilers and interpreters)
    deal in simple text, so that the command line is a natural interface
    to them.
    Finally, the stability of shells and commands means that they have
    become languages of their own; with the inclusion of <em>conditional</em>
    and <em>looping</em> constructs, they have become
    full-fledged programming languages.
    Let's look at some more powerful constructs within shells.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://devblogs.microsoft.com/commandline/introducing-windows-terminal/">Introducing Windows Terminal</a> (Commands not guaranteed to be the same)</li>
  </ul>
</div>

<div class="content" id="more-shell-features">
  <h2> More Shell Features </h2>

  <p>
    Some tokens are expanded by the shell before it executes the line they're in.
    For instance,
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      How can you check?
    </p>
  </div>

  <div class="code">
    {1..6}
  </div>

  <p>
    expands to
  </p>

  <div class="code">
    1 2 3 4 5 6
  </div>

  <p>
    This is called <em>shell expansion,</em> and within Bash, becomes quite a
    topic.
    Shell variables are expanded with the <code>$</code> operator; they are
    declared by giving their name followed without-space by an equals-sign:
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      How does the shell interpret,
      <br><center><code>$ myvar =12</code>?</center>
    </p>
  </div>

  <div class="code">
    $ myvar=12 <br>
    $ echo myvar <br>
    myvar <br>
    $ echo $myvar <br>
    12
  </div>

  <p>
    It's important to note that the shell deals in <em>strings</em> and <em>commands</em>,
    so that <em>12</em> is the string composed of the letters <em>1</em> and <em>2</em>,
    and not the number twelve.
    We can tell Bash to deal in integers, but let's not bother just now.
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      And how can we assert the value of the variable <em>hello</em>?
    </p>
  </div>

  <p>
    What do you think this does?
  </p>

  <div class="code">
    $ hello='echo Hello, World!'<br>
    $ $hello
  </div>

  <p>
    Alright, scenario:  You're at work, and you haven't been doing anything.
    How can you create a bunch of files to make it <em>look</em> like you've
    been busy, without actually going through the trouble of doing much?
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      You can clean up with,
      <br><center><code>$ rm ./1.0*</code></center>
    </p>
  </div>

  <div class="code">
    $ for filename in 1.{01..9}.{01..20..2}; do<br>
    echo 'somesuch' > $filename <br>
    done
  </div>

  <p>
    Pretty spiffy, eh?
  </p>
</div>

<div class="content" id="editing-files">
  <h2>Editing Files</h2>
  <p>
    Alright, let's get some real work done.
    There are many terminal-based text editors available, but I recommend
    that you learn <a href="https://www.vim.org/">vim</a>.  Its controls
    are similar to those of the manual paging utility, which you can expect
    to use often, and because it's available everywhere.
    You can launch it with,
  </p>

  <div class="code">
    $ vim [filename]
  </div>


  <p>
    where <em>filename</em> either exists and is readable, or does not exist.
    Like most command-line tools, this one is intended for an experienced user,
    so there's a bit of a learning curve to it.
    It breaks down like this:
  </p>

  <p>
    Vim has <em>modes</em>.
    The default mode is called <em>normal mode,</em> and you can get to
    it from any other mode by pressing the escape key.
    From normal mode, you can exit vim by typing a colon, followed by the
    letter 'q',
  </p>

  <div class="code">
    :q
  </div>

  <p>
    If you have unsaved work, this command will fail, and vim will warn you.
    To discard your changes and exit anyway, type,
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      I personally use <a href="https://neovim.io/">Neovim</a>,
      which is just a modern, extensible variant of vim.
    </p>
  </div>

  <div class="code">
    :q!
  </div>

  <p>
    You should familiarize yourself with these commands now.
  </p>

  <p>
    Similarly, to write (save) your work to file, enter normal mode and type,
  </p>

  <div class="code">
    :w
  </div>

  <p>
    To save-and-quit, simply,
  </p>

  <div class="code">
    :wq
  </div>

  <p>
    Soon enough, these controls are second-nature.
    How about modifying text?
    Well, we enter <em>insert</em> mode by pressing <em>i</em>
    from normal mode.
    From there, type away (and press escape to return to normal mode).
  </p>

  <p>
    Now for moving around within text.
    The idea is that the controls are entirely at the home-row, so that
    one can quickly edit text (and it is fast when one becomes proficient).
    To move right, press <code>l</code> once.  To move left, press <code>h</code>.
    To move up, press <code>k</code>; and to move down, press <code>j</code>.
  </p>

  <p>
    These are best learned through practice, and there are a few good resources.
    The first one is, <a href="https://vim-adventures.com/">Vim Adventures</a>.
    The second is <em>vimtutor,</em> available through the command line
    itself by executing,
  </p>

  <figure style="padding-top: 10px;">
    <a href="assets/img/vim-adventures.png"><img src="assets/img/vim-adventures.png" style="width:100%;"></a>
    <figcaption><br><center><b>Vim Adventures</b></center></figcaption>
  </figure>

  <div class="code">
    $ vimtutor
  </div>

  <p>
    Finally, a run-down of some useful commands:
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Vim distinguishes between upper- and lower-case commands, so make sure
      your caps-lock key is not depressed.
    </p>
  </div>

  <ul>
    <li><code>u</code>&mdash; undo</li>
    <li><code>v</code>&mdash; enter visual mode (highlighting; allows copying and pasting)</li>
    <li><code>y</code>&mdash; "yank" (copy)
    <li><code>p</code>&mdash; "put" (paste)
    <li><code>x</code>&mdash; delete</li>
    <li><code>dd</code>&mdash; delete a line</li>
    <li><code>o</code>&mdash; "open" a new line below</li>
    <li><code>O</code>&mdash; "Open" a new line above</li>
    <li><code>I</code>&mdash; "Insert" place cursor at the beginning of the line and enter insert mode</li>
    <li><code>A</code>&mdash; "Append" place cursor at end of line and enter insert mode</li>
    <li><code>a</code>&mdash; "append" insert text after cursor</li>
    <li><code>:help [term]</code>&mdash; Vim's onboard help system; enter colon-q (:q) to return to your document</li>
  </ul>

  <p>
    Vi isn't the only text editor out there, and we could delve further into the
    theory of Vi itself, but this is good for now.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://www.vim.org/docs.php"> Vim Documentation</a></li>
  </ul>

</div>

<div class="content" id="everythings-a-command">
  <h2>(Almost) Everything is a Command </h2>

  <p>
    In the shell, most things are commands&mdash; even the for loop above is a
    command.
  </p>

  </div>

<div class="content" id="bram-moolenaar">
  <h2>Bram Moolenaar</h2>
  <iframe class="video" src="https://www.youtube.com/embed/p6K4iIMlouI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
