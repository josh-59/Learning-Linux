---
layout: default
title: Processes
last-updated: November, 2020
---

<!--
  TODO
  Current working directory (among process attributes)
        -> Change with system call
  Open file descriptors.
  Memory layout

  Terminating Processes:
        -> Signals
        -> kill
        -> killall

        Possibly:
            EOF and EOF character

  A Similar article:
  https://www.brianstorti.com/an_introduction_to_unix_processes/
-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#actors"> Actors </a></li>
        <li><a href="#proccess-creation"> Process Creation and System Startup </a></li>
        <li><a href="#process-attributes"> Process Attributes </a></li>
        <li><a href="#standard-file-descriptors">Standard File Descriptors </a></li>
        <li><a href="#what-is"> Yeah But What Is It? </a></li>
        <li><a href="#dr-fraser"> Dr. Brian Fraser </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Processes</h1>
    <div class="quote-text">
        "Theory and practice sometimes clash.  <br>
        And when that happens, theory loses.
        Every single time.
    </div>
    <div class="quote-ref">
        &mdash;<a href="https://lwn.net/Articles/326505/">Linus Torvalds</a>
    </div>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Recall that <a href="files-and-filesystems.html#regular-files">a file</a> is a sequence of bytes.
        </p>
    </div>

    <p>
        A process is an instance of an executing program.<sup><a href="#references">[1]</a></sup><sup><a href="#references">[2]</a></sup>
        A <em>program</em> (also known as an "executable file")
        contains the information required to
        construct a process.<sup><a href="#references">[1]</a></sup>
        The process is, after the file, the most important
        abstraction of operating systems.
    </p>

</div>

<div class="content" id="actors">

    <h2> Actors </h2>

    <p>
        Think of processes as the actors of the operating system.
        Left to its own devices, the kernel does nothing:
        All Unix-like operating systems depend upon processes to direct the kernel,
        and through the kernel, processes direct the machine.
        The result is a clear demarcation between
        <em>what</em> to do (dictated by processes), and <em>how</em> to do
        it (dictated by the kernel).
    </p>



    <p>
        The kernel:
    </p>

    <ol>
        <li>
            Facilitates new process creation
        </li>
        <li>
            Allocates hardware resources to each process
        </li>
        <li>
            Maintains information about processes
        </li>
        <li>
            Facilitates change of their attributes
        </li>
    </ol>

    <p>
        There are processes for every function on the system.
        There's one for the network manager,
        another for the desktop environment,
        another acting as a printer spooler, etc..
        Without a process, the kernel is unreachable, and the system is static.
    </p>

    <p>
        Under the Unix philosophy, each process has a narrowly defined role,
        which it is expected to do well.  It might copy a file, list the
        contents of a directory, or interpret and execute commands from the user.
        It is intended that these small programs work together to
        accomplish any given task, thereby easing programming and maintenance,
        and increasing the modularity of the resulting whole.
    </p>

    <h3> Runlevels</h3>

    <p>
        Historically, collections of running processes were
        called <a href="http://www.linfo.org/runlevel_def.html">runlevels</a>;
        these runlevels were managed by the initialization ("init") process.
        Different runlevels offered different services, and therefore
        were intended to be used for different situations.
        For instance, <a href="http://www.linfo.org/single_user_mode.html">single-user mode</a> (runlevel 1)
        was analogous to <em>safe boot,</em> and runlevel 0
        told <em>init</em> to kill all processes and shut down the system.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://www.man7.org/linux/man-pages/man7/daemon.7.html"> daemon(7)</a> (Background Process)</li>
        <li><a href="https://www.brianstorti.com/an_introduction_to_unix_processes/"> An introduction to UNIX processes</a> (An article similar to this one)</li>
    </ul>
</div>

<div class="content" id="proccess-creation">
    <h2> Process Creation and System Startup</h2>

    <p>
        At the end of the boot sequence, the kernel launches a single program,
        <code>/sbin/init</code>.<sup><a href="http://tldp.org/LDP/intro-linux/intro-linux.pdf">[3]</a></sup>
        While init schemes <a href="https://arxiv.org/abs/0706.2748">have evolved</a> over the years,
        their purpose has not changed:  It is a process with root-level permissions that acts as a
        trustee among processes.
        Init's central responsibility is to bring up
        userspace.<sup><a href="http://0pointer.de/blog/projects/systemd.html">[4]</a></sup>
        After the execution of <code>/sbin/init</code> by the kernel, 
        process creation is delegated to processes themselves.
    </p>

    <div class="aside-left">
        <h4>Aside:</h4>
        <p>
            You can check your <em>init</em> program with <br> <center><code>$ ps --pid 1</code></center><br>
            <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> is very common today.
        </p>
    </div>

    <p>
        From within a process, creating a new process begins with
        the <em><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">fork()</a></em> system call.
        This instructs the kernel to make a copy of the current process&mdash;
        an exact copy is produced, save one difference: Each of the two
        processes receives a different return value from <em>fork().</em>
    </p>

    <p>
        The new process is called the <em>child</em> process, and the
        old process is called the <em>parent</em> process.
        Both parent and child begin execution exactly after the call to <em>fork()</em>.
        The parent process usually goes back to what it was doing; 
        the child process goes on to call <em><a href="https://www.man7.org/linux/man-pages/man2/execve.2.html">execve(pathname, argv, envp)</a>.</em>
        This instructs the kernel to replace the current
        process with a new one by loading the executable file located at <em>pathname;</em>
        therein, execution begins at <em>main()</em>.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://unix.stackexchange.com/questions/158872/does-systemd-still-know-about-runlevels">
                Does systemd still know about runlevels?</a> - Unix &amp; Linux Stack Exchange</li>
    </ul>

</div>

<div class="content" id="process-attributes">
    <h2> Process Attributes </h2>
    <p>
        Upon birth, each process is given its own process id (PID) number by the kernel.
        This is guaranteed to be unique to the process, remains constant throughout
        the process's life, and serves as the kernel's handle
        to the process.
        Pragmatically speaking, process ID's begin at
        <code>1</code> (with <em>init</em>) and count upwards until
        <code>/proc/sys/kernel/pid_max - 1</code>.<sup><a href="kerrisk, p.115">[6]</a></sup>
        After that, the kernel begins searching at <code>300</code> for the next free PID.<sup><a href="kerrisk, p.115">[6]</a></sup>
        That is, PID's are not guaranteed to be monotonically increasing.
    </p>

    <p>
        For each process on the system, the kernel 
        maintains a great deal of information, including:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            For detailed information about processes in the Linux environment, see
            <a href="https://www.man7.org/tlpi/"> The Linux Programming Interface</a>.
        </p>
    </div>


    <ul>
        <li>Location of executable file</li>
        <ul>
            <li>Location of next instruction </li>
        </ul>
        <li>Files currently open by the process</li>
        <ul>
            <li>Access Mode (read, write, read and write)</li>
            <li>Location wihin file</li>
        </ul>
        <li>Current working directory</li>
        <li>Owner, group</li>
        <li>Environment variables</li>
    </ul>

    <p>
        Most of this information is available for perusal in the 
        <code>/proc/</code> directory, which contains one subdirectory
        for each process on the system.  
        For now, we'll consider just one of these, in order to give
        some idea of how the kernel behaves, and how one interacts with it.
    </p>

    <h3>File Descriptors</h3>
    <p>
        Each open file that a process has is assigned a number
        by the kernel (specifically, a small integer).
        This number is called a <em>file descriptor</em>.
        These integers are used by the process whenever the process
        requests an operation from a file. 
        In the following call to 
        <code><a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></code>,
        the program is instructing
        the kernel to read from the file associated with
        the number <em>3</em>.
    </p>

    <div class="code">
        num_bytes_read = read(3, buff, buff_size);
    </div>

    <p>
        This instructs the kernel to read at-most <code>buff_size</code>
        bytes from the file associated with the number <code>3</code>, 
        and to store the data into <code>buff</code>.
        If all goes well, the system call will return with a nonnegative value;
        if the kernel encountered an error, it will return with a 
        negative value.
        In either case, this <em>return value</em> will be assigned to 
        <code>num_bytes_read</code>.
    </p>










    <h3> See Also: </h3>
    <ul>
        <li><code><a href="https://man7.org/linux/man-pages/man5/proc.5.html"> proc(5)</a></code></li>
    </ul>
</div>

<div class="content" id="standard-file-descriptors">
    <h2> Standard File Descriptors </h2>
    
</div>

<div class="content" id="what-is">
  <h2>Yeah But What Is It?</h2>
  <p>
    One of the major ideas of processes is that each process is isolated
    from both the kernel and from other processes.
    This is done for a few reasons.
    First, we want to ensure that no process is capable of jeopardizing the
    stability of the system.
    Second, we want to ensure that no process can affect any other process
    in an unpredictable manner.
    We do this by running each process in a "sandboxed" environment, composed
    of restricted access to the machine's CPU, and a virtualized memory address
    space.
  </p>

  <h3> Limited Direct Execution </h3>

  <p>
    Modern CPU architectures support two
    distinct modes of operation.
    <em>Kernel mode,</em> sometimes called "supervisor mode," is the unrestricted mode.
    Here, all CPU instructions are available, so that code running in this mode
    has complete access to the machine.
    <em>User mode</em> is a proper subset of kernel mode; all processes run in user mode.
    If a process, running in user mode, attempts to execute a restricted instruction,
    its execution is halted, and control is given to the kernel.
    At that point, it is up to the operating system to determine what to do
    (usually, terminate the offending process).
  </p>

  <p>
    This technique is known as <em>limited direct execution.</em><sup><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf">[3]</a></sup>
    It is <em>limited</em> in the sense that each process has access to
    only a restricted subset of the CPU's instructions.
    It is <em>direct</em> in the sense that each process runs directly on hardware.
    It makes safe and efficient use of available hardware.
  </p>

  <p>
    For instance, no process can access a hard-drive directly.
    The proper avenue for a process to access such a device is through the kernel,
    via system calls.
    Through limited direct execution, this is
    <em>the only</em> way that a process can access it.
    This ensures that the kernel remains in charge of the machine's state.
  </p>

  <h3> Virtual Memory </h3>

  <p>
    Modern operating systems provide each process with its own memory in the
    form of a distinct <em>address space.</em>
    An address space is a collection of memory addresses; on all modern architectures,
    memory (RAM) is byte-addressable, so that each address refers to exactly one byte.
    Addresses themselves are simply numbers, usually expressed in hexadecimal.
  </p>

  <div class="img-right" style="background: #f1f1f1;">
<a style="outline: solid black 2px; " title="Traced by User:Stannered, original by en:User:Dysprosia / BSD (http://opensource.org/licenses/bsd-license.php)" href="https://commons.wikimedia.org/wiki/File:Virtual_address_space_and_physical_address_space_relationship.svg"><img width="512" alt="Virtual address space and physical address space relationship" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Virtual_address_space_and_physical_address_space_relationship.svg/512px-Virtual_address_space_and_physical_address_space_relationship.svg.png"></a>
  </div>

  <p>
    Some archaic operating systems (such as the
    <a href="https://en.wikipedia.org/wiki/Exec_(Amiga)">Amiga</a>)
    allowed processes direct access to
    the system's main memory; processes effectively shared the same address space.
    This posed significant issues for system stability and security&mdash;
    namely, one process could read and/or manipulate the memory of another.
  </p>

  <p>
  <em>Modern operating systems provide each process with a distinct
      address space.</em>
    The result has been a profound improvement in system stability.
    The addresses that any process uses are relative to that process alone;
    they are called "virtual" because they exist, effectively, for that process alone.
    These virtual addresses are mapped onto physical addresses by
    the CPU, without the process ever being aware of it.
    This scheme is referred to colloquially as "virtual memory."
  </p>

  <p>
    The virtual memory abstraction requires support from both the kernel
    and CPU.
    For each process, the kernel maintains an address translation table, which maps
    virtual addresses onto physical ones.
    This is loaded onto the CPU's
    <a href="https://en.wikipedia.org/wiki/Memory_management_unit">Memory Management Unit</a>
    whenever the process runs,
    and the MMU carries out address translation automatically whenever in user mode.
  </p>

  <p>
    Crucially, not every virtual address needs to be mapped to a physical address.
    Rather, when a process references a virtual address that is not mapped,
    the MMU instructs the CPU to interrupt execution of the process; the CPU
    defers control to the kernel.
    If the memory address should be mapped, the kernel loads that data into memory,
    modifies the translation table and returns control to the process.
    If the memory should not be mapped (i.e., it is an undefined address), the
    kernel aborts execution of the program.
  </p>

  <p>
    Through the mechanism of virtual memory, each process is presented with
    the illusion that it has the entirety of the machine's memory to
    itself.
    Other processes are implicitly protected from memory tampering:
    Their memory simply does not exist within the context of the
    currently running process, and therefore cannot be read from, nor written to.
    As with limited direct execution, virtual memory facilitates
    the safe and efficient use of a machine resource.
  </p>

  <h3> See Also: </h3>
  <ul>
    <li><a href="http://www.csapp.cs.cmu.edu/"> Computer Systems: A Programmer's Perspective, 3<sup>rd</sup> Ed.</a>, Chapter 9: Virtual Memory (Not free)</li>
    <li><a href="https://www.makeuseof.com/tag/virtual-memory-low-heres-fix/"> Is Your Virtual Memory Too Low?  Here's How to Fix It!</a> (WRONG!)</li>
  </ul>
</div>

<div class="content" id="dr-fraser">
    <h2 style="margin-bottom: 2pt;"> Dr. Brian Fraser: </h2>
    <h4 style="margin-bottom: 18pt;"> Fork and Exec Linux Programming </h4>
    <iframe class="video" src="https://www.youtube-nocookie.com/embed/l64ySYHmMmY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li>
        Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.
    </li>
    <li>
        Bryant, R. E., & O'Hallaron, D. R. (2016).  Processes. In <em>Computer Systems: A Programmer's Perspective</em> (3rd ed., p. 732).  Upper Saddle River, New Jersey: Pearson.
    </li>
    <li>
        Garrels, M. (2008). <em>Introduction to Linux: A Hands on Guide.</em>
    </li>
    <li>
        Royon, Y., &amp; Frenot, S. (2007). A Survey of Unix Init Schemes (Doctoral dissertation, Inria Rhone-Alpes) (p. 0-39). Mountbonnot Saint Ismier: Unite de recherche Inra Rhone-Alpes.
    </li>
    <li>
        Poettering, L. (2010, April 30). Rethinking PID 1. Retrieved September 01, 2020, from <a href="http://0pointer.de/blog/projects/systemd.html">http://0pointer.de/blog/projects/systemd.html</a>
    </li>

  </ol>

</div>
-
-

