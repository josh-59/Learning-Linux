---
layout: default
title: Processes
last-updated: March, 2021
---

<!--

    One subsection per major attribute?

    A simple shell:

            printf("%s", prompt);
            getline(input);

TODO
    Include: OSTEP "Address Spaces":
        https://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf

        Writing signal handlers is <a href="http://lazarenko.me/signal-handler/">not easy</a>,
        especially in multi-threaded environments.

    IPC: ??????
        Primitives:
            Signals - Software interupts: Interupt the normal flow of
                execution in a program (Kerrisk, p388)
            Sockets - Shuffle data
            Shared Memory - Don't do it!
            FIFO Pipes - More later

        <div class="aside-right">
            <h4>Aside</h4>
            <p>
                D-Bus is an excellent example of what a process
                is capable of, but
                has been effectively depricated by <code>kdbus</code>,
                which is easier to use, more efficient, and more secure, among
                other things.
            </p>
        </div>

        D-Bus
            Provide a high-level IPC interface, based principally around
                Object-Oriented methodologies (methods, attributes, etc),
                but which runs as a process.
            Also, a "point-to-point communications library", libdbus

            System daemon!
                Inefficient!
            Method Call Transactions: Call a method from another process and
                get a response

        mirror.linuux.org.au/pub/linux.conf.au/2014/Friday/104-D-Bus_in_the_kernel_-_Lennart_Poettering.mp4

        See Also:
            https://magcius.github.io/xplain/article/x-basics.html




        Introduce programs, rather than programming.
        The Linux kernel actually supports four executable file formats:
        a.out, ELF, interpretter scripts and



    <h3 id="standard-file-descriptors">Standard File Descriptors</h3>
    <p>
        Over the years, file descriptors <em>0, 1,</em> and <em>2</em>
        have become somewhat special:
        They are guaranteed to be open and available for use at program startup.
        They are:
    </p>

     <ul style="margin-left: 5%; list-style-type: none;">
        <li><code>STDIN</code> is located at file descriptor 0; open for reading</li>
        <li><code>STDOUT</code> is located at file descriptor 1; open for writing</li>
        <li><code>STDERR</code> is located at file descriptor 2; open for writing</li>
    </ul>

    <p>
        These are referred to as the <em>Standard File Descriptors.</em>
    </p>

    <h3> Runlevels</h3>

    <p>
        Collections of running programs are traditionally
        called <a href="http://www.linfo.org/runlevel_def.html">runlevels</a>,
        and are managed by the initialization ("init") process.
        Different runlevels offered different services, and
        were therefore intended to be used in different situations.
        For instance,
        <a href="http://www.linfo.org/single_user_mode.html">single-user mode</a>
        (runlevel 1) was analogous to <em>safe boot,</em>
        runlevel 5 corresponded to multi-user/GUI mode,
        and runlevel 0 told <em>init</em> to kill all processes and shut down the
        system.<sup><a href="http://www.linfo.org/runlevel_def.html">[3]</a></sup>
    </p>


-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#actors"> Actors </a></li>
        <li><a href="#process-creation"> Process Creation and System Startup </a></li>
        <li><a href="#process-attributes"> Process Attributes </a></li>
        <li><a href="#file-descriptors"> File Descriptors </a></li>
        <li><a href="#exec">Executing a Different Program</a></li>
        <li><a href="#termination">Process Termination</a></li>
        <li><a href="#closing-remarks"> Closing Remarks: Concurrency</a></li>
        <li><a href="#dr-fraser"> Dr. Brian Fraser </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Processes</h1>

    <div class="quote-text">
        "Understanding is the key to success with Linux."
    </div>
    <div class="quote-ref">
        <a href="https://www.tldp.org/LDP/sag/html/intro.html">Linux System Administrator's Guide</a>
    </div>



    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Recall that <a href="files-and-filesystems.html#regular-files">a file</a> is a sequence of bytes.
        </p>
    </div>

    <p>
        A process is an instance of an executing program.<sup><a href="#references">[1]</a></sup><sup><a href="#references">[2]</a></sup>
        A <em>program</em> (also known as an "executable file")
        is a file containing the information required to
        construct a process.<sup><a href="#references">[1]</a></sup>
        The process is, after the file, the most important
        abstraction of operating systems.
    </p>

</div>

<div class="content" id="actors">

    <h2> Actors </h2>

    <p>
        In Unix and its derivatives, processes are the actors of the system:
        Left to its own devices, the kernel does nothing.
        All Unix-like operating systems depend upon processes to direct the kernel,
        and through the kernel, processes direct the machine.
        The result is a low-level demarcation between
        <em>what</em> to do (dictated by processes), and
        <em>how</em> to do it (dictated by the kernel).
    </p>

    <p>
        There is a process for every function on the system.
        There's one for the network manager,
        another for the desktop environment,
        another acting as a printer spooler,
        another acting as a web browser, etc..
    </p>

    <p>
        Each process has a narrowly defined role,
        which it is expected to do well.
        It might copy a file, list the
        contents of a directory, provide audio services,
        or intepret and execute commands.
        These many small programs are used together to accomplish
        a given task, thereby increasing the modularity of the whole,
        and simplifying programming and maintenance.
    </p>

    <p>
        The kernel is responsible for:
    </p>

    <ol>
        <li>
            Facilitating new process creation
        </li>
        <li>
            Allocating hardware resources to processes
        </li>
        <li>
            Maintaining information about processes
        </li>
        <li>
            Preserving each process's privacy
        </li>
    </ol>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://www.man7.org/linux/man-pages/man7/daemon.7.html"> daemon(7)</a> (Background Process)</li>
    </ul>
</div>

<div class="content" id="process-creation">
    <h2 style="margin-bottom: 0;"> Process Creation</h2>
    <h4>and System Startup</h4>

    <p>
        At the end of the boot sequence, the kernel launches a single program,
        <code>/sbin/init</code>,<sup><a href="https://en.wikipedia.org/wiki/Init">[3]</a></sup>
        and in so doing creates the system's first process.
        While init schemes
        <a href="https://arxiv.org/abs/0706.2748">have evolved</a>
        over the years, its purpose has not changed:
        It is a process with root-level permissions that acts as a
        manager of the system and trustee among processes.
    </p>

    <div class="aside-left">
        <h4>Aside:</h4>
        <p>
            You can check your <em>init</em> program with
        </p>

        <div class="code">
            $ ps --pid 1
        </div>

        <p>
            <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> is very common today.
        </p>
    </div>

    <p>
        <code>init</code>'s first responsibility is to bring up userspace.
        It does this by launching a sequence of programs, most of which
        are daemons, some of which the user interacts with directly.
        After this, it operates in the background, managing services,
        restarting them if they falter, and logging events for administrative
        purposes.
        Its final responsibility is to shut the system down cleanly.
    </p>

    <p>
        After execution of <code>init</code> begins, process creation is delegated
        to processes themselves, and is carried out through the
        <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html"><code>fork(2)</code></a> system call.
    </p>

    <p>
        A call to <em>fork()</em> instructs the kernel to duplicate the current process,
        and the two resulting processes are very nearly identical.<sup><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">[4]</a></sup>
        Of note, they continue executing the same program at the same spot,
        have the same open files, and have duplicate memory spaces.
        The newly created process is referred to as the <em>child</em> process,
        the original is called the <em>parent,</em> and we say
        that the child process <em>inherits</em> its parent's attributes.
    </p>

    <p>
        Of the few ways that parent and child do differ, one is important to us
        now:
        They each recieve a different return value from <em>fork()</em>.
        This allows them to act differently within the same program:
    </p>


    <pre>
        pid_t rv = fork();      // One process executes this line
        if(rv == 0) {           // Two processes execute this line
            // I am child

        } else if (rv &gt; 0) {
            // I am parent

        }
    </pre>

    <p>
        Their executions thereby diverge, and each is free to act independantly.
    </p>

</div>

<div class="content" id="process-attributes">
    <h2> Process Attributes </h2>
    <p>
        Upon birth, each process is given its own <code>PID</code> number by the kernel.
        This is guaranteed to be unique to the process, and remains constant
        throughout the process's life. It serves as a system-wide handle
        to the process.
    </p>

    <p>
        Associated with each PID are the following attributes:
    </p>

    <ul>
        <li>Name and location of executable file</li>
        <ul>
            <li>Location of next instruction within</li>
        </ul>
        <li>Files currently open</li>
        <ul>
            <li>Their access modes (read, write)</li>
            <li>Location wihin file</li>
        </ul>
        <li>Current working directory</li>
        <li>User ID, Group Id</li>
        <li>Environment variables</li>
    </ul>

    <p>
        All of these attributes are inherited from the process's parent,
        and most of this information is available for perusal in the
        <code>/proc/</code> directory.
        In addition, the kernel offers <a href="https://man7.org/linux/man-pages/man2/intro.2.html">system calls</a>
        to allow a process to change its attributes.
    </p>

    <p>
        In order to give some idea of how
        processes interact with the kernel,
        we will consider one of them: Files currently open.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href=""><code>credentials(7)</code></a></li>
    </ul>
</div>

<div id="file-descriptors" class="content">
    <h2> File Descriptors</h2>
    <p>
        Each file that a process has open is assigned a number
        by the kernel (specifically, a small positive integer).
        This number is called a <em>file descriptor</em>,
        and is returned by the kernel in response to a request to open a file.
        The process, thereafter, uses this integer to refer to that
        file whenever it wishes to act on it.
    </p>

    <p>
        In the following line, a process is opening the file
        <em>rubber_ducky</em> for reading, then
        storing the kernel's response as <em>fd</em>:
    </p>

    <pre>
        int fd = open("./rubber_ducky", O_RDONLY);
    </pre>

    <p>
        If this call failed (which it would if <code>./rubber_ducky</code> did not
        exist), then <code>fd</code> would be assigned -1, an invalid file
        descriptor.
        We can therefore check with:
    </p>

    <pre>
        if (fd &lt; 0) {
                perror("open");
                exit(1);
        }
    </pre>

    <p>
        and then continue as though <em>open</em> had succeeded.
    </p>

    <p>
        In the following call to
        <code><a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></code>,
    </p>

    <pre>
        int num_bytes_read = read(fd, buff, buff_size);
    </pre>

    <p>
        the kernel will read at-most <code>buff_size</code>
        bytes from file <code>fd</code>,
        and copy the data into the process's memory space,
        here denoted by the variable <code>buff</code>.
        If all goes well, the system call will return with a nonnegative value;
        if the kernel encountered an error, it will return with a
        negative value.
        In either case, this value will be assigned to <code>num_bytes_read</code>.
    </p>

    <p>
        <a href="https://man7.org/linux/man-pages/man2/write.2.html"><code>write(2)</code></a>
        is handled analogously, as is closing a file.
        Every system call has an entry in Section 2 of the manual.
    </p>

    <h3>A Bit More</h3>

    <p>
        Ken Thompson's <em>UNIX</em> kernel facilitated reading and writing of
        files, but otherwise refrained from interjecting upon their use.
        This approach was new for its time: Earlier
        operating systems interposed upon the handling of files, so that
        some files could only be read by some programs, and not by others.<sup><a href=#references>[A]</a></sup>
    </p>
</div>

<div class="content" id="exec">
    <h2>Executing a Different Program</h2>
    <p>
        Launching a different program reduces to changing the program being
        executed by the current process.
        To do that,
    </p>

    <ol>
        <li>
            The designated executable file must be changed
        </li>
        <li>
            Execution must begin at the beginning
        </li>
        <li>
            The memory space of the process must be cleared
        </li>
    </ol>

    <p>
        This is what the <a href="https://www.man7.org/linux/man-pages/man2/execve.2.html"><code>execve(2)</code></a> system call does:
    </p>

    <pre>
        pid_t rv = fork();
        if( rv == 0 ) {
            // I am child
            char *args[] = {"ls", "-l", NULL};
            execv("/bin/ls", args);

        } else if ( rv &gt; 0 ) {
            // I am parent
            continue;
        }
    </pre>

    <p>
        This sequence is traditionally called <em>fork and exec,</em>
        and results in one process (the parent) launching another program
        (its child).
        Note that there is no need to adjust other process attributes, and indeed,
        they are preserved across <em>exec.</em>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://man7.org/linux/man-pages/man1/pstree.1.html"><code>pstree(1)</code></a></li>
    </ul>
</div>

<div class="content" id="termination">
    <h2> Process Termination </h2>
    <p>
        A process may terminate for a few reasons:
    </p>

    <ul class="big-list">
        <li>
            Return from <em>main()</em>
            <p>
                This is the usual and preferred route to terminate a process:
                The program finishes its job, and explicitly requests to return.
            </p>
        </li>

        <li>
            It is told to terminate

            <p>
                This is a form of abnormal process termination.
                It is carried out through <em>signals,</em> a primitive
                form of interprocess communication.
                Command-line tools for terminating processes are <code><a href="https://www.man7.org/linux/man-pages/man1/kill.1.html">kill(1)</a></code>,
                which refers to processes by their PID, and
                <code><a href="https://www.man7.org/linux/man-pages/man1/killall.1.html">killall(1)</a></code>,
                which kills processes by program name.
            </p>
        </li>

        <li>
            It does something wrong
            <p>
                Almost always, this happens when the offending process tries
                to read or write a memory location not assigned to it,
                a condition known in Linux as <em>segmentation fault</em>.
                The kernel steps in, halts program execution and immediately
                terminates the process.
            </p>

        </li>
    </ul>
</div>

<div class="content" id="closing-remarks">
    <h2 style="margin-bottom: 0;">Closing Remarks:</h2>
    <h4>Concurrency</h4>
    <p>
        With more than 50 years of use, the process is a well-studied
        abstraction.
        Indeed, it is supported at the hardware level, in addition to
        the software level.
        A deep study of it, while worthwhile, is outside the
        scope of this work.
        Rather, we will conclude this discussion by describing how a computer
        runs more than one process at a time&mdash; That is, how programs
        are executed <em>concurrently.</em>
    </p>

    <p>
        The fundamental insight is that <em>a program's instructions are oblivious to
        time.</em>
        That is, a program's only assumption about its execution
        is that each instruction follow the previous one.
        It is therefore possible to halt its execution
        and save its state; and later, to reintroduce its state, and continue
        execution, without violating this assumption.
        When carried out correctly, the program is oblivious to any such
        interruptions.
    <p>

    <p>
        The operating system's kernel, working in conjunction with hardware,
        is responsible for presenting each process with 
        <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">the illusion</a> 
        that it ran without interruption, and "concurrency" is achieved by 
        interweaving process execution with respect to time:
    </p>

    <p>
        (Depiction)
    </p>

  <h3> See Also: </h3>

    <ul>
        <li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">Operating Systems: Three Easy Pieces</a> Chapter 4: Processes</li>
        <li><a href="http://www.man7.org/tlpi/index.html">The Linux Programming Interface</a> (Not Free)</li>
        <li><a href="http://www.csapp.cs.cmu.edu/"> Computer Systems: A Programmer's Perspective, 3<sup>rd</sup> Ed.</a>, Chapter 9: Virtual Memory (Not free)</li>
        <li><a href="https://www.man7.org/linux/man-pages/man1/top.1.html"><code>top(1)</code></a></li>
        <li><a href="./assets/check.c">check.c</a> - Double-check of the above snippets</li>
    </ul>
</div>

<div class="content" id="dr-fraser">
    <h2 style="margin-bottom: 2pt;"> Dr. Brian Fraser: </h2>
    <h4 style="margin-bottom: 18pt;"> Fork and Exec Linux Programming </h4>
    <iframe class="video" src="https://www.youtube-nocookie.com/embed/l64ySYHmMmY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li>
        Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.
    </li>
    <li>
        Bryant, R. E., & O'Hallaron, D. R. (2016).  Processes. In <em>Computer Systems: A Programmer's Perspective</em> (3rd ed., p. 732).  Upper Saddle River, New Jersey: Pearson.
    </li>
    <li>
        init - Wikipedia (3 Match 2021). Retrieved March 30, 2021, from <a href="https://en.wikipedia.org/wiki/Init">https://en.wikipedia.org/wiki/Init</a>
    </li>

    <li>
        Kerrisk, M. (2020, December 21). Fork(2) - Linux manual page. Retrieved February 09, 2021, from <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">https://www.man7.org/linux/man-pages/man2/fork.2.html</a>
    </li>

  </ol>
</div>
