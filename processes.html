---
layout: default
title: Processes
last-updated: April, 2021
---

<!--

<div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>

    <p>
        The directory tree is a persistent data structure of the machine.  
        It is globally shared by most processes on the system, but there
        exists ways to reduce its exposure to particular processes.
    </p>

    <p>
        The earliest dialects of the C programming language were especially
        simple, mapping high-level statements to assembly, to be interpretted
        by an already-existant assembler.  
        At the highest level, the language expresses a model of the system's memory;
        the most notable component of which is its instructions.
    </p>

    <p>
        These instructions are stored in memory, then executed;
        in the process, they manipulate other regions of memory; through
        system calls, they manipulate the directory tree.
    </p>

    <p>
        6th edition UNIX was written in C, and was commented on by Lions.
    </p>

    <p>
        My favorite line (so far):
    </p>

    <pre>
    // ...
    // Hand-craft 0th process
    // ... 
    </pre>
</div>


TODO
    Include: OSTEP "Address Spaces":
        https://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf

        Actors: See Also: Examples?
        mirror.linuux.org.au/pub/linux.conf.au/2014/Friday/104-D-Bus_in_the_kernel_-_Lennart_Poettering.mp4

    <h3> Runlevels</h3>

    <p>
        Collections of running programs were traditionally
        called <a href="http://www.linfo.org/runlevel_def.html">runlevels</a>,
        and are managed by the initialization ("init") process.
        Different runlevels offered different services, and
        were therefore intended to be used in different situations.
        For instance,
        <a href="http://www.linfo.org/single_user_mode.html">single-user mode</a>
        (runlevel 1) was analogous to <em>safe boot,</em>
        runlevel 5 corresponded to multi-user/GUI mode,
        and runlevel 0 told <em>init</em> to kill all processes and shut down the
        system.<sup><a href="http://www.linfo.org/runlevel_def.html">[3]</a></sup>
    </p>

-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#actors"> Actors </a></li>
        <li><a href="#process-creation"> Process Creation and System Startup </a></li>
        <li><a href="#process-attributes"> Process Attributes </a></li>
        <li><a href="#file-descriptors"> File Descriptors </a></li>
        <li><a href="#exec">Executing a Different Program</a></li>
        <li><a href="#termination">Process Termination</a></li>
        <li><a href="#closing-remarks"> Closing Remarks: Concurrency</a></li>
        <li><a href="#dr-fraser"> Dr. Brian Fraser </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Processes</h1>

    <div class="quote-text">
        "Understanding is the key to success with Linux."
    </div>
    <div class="quote-ref">
        <a href="https://www.tldp.org/LDP/sag/html/intro.html">Linux System Administrator's Guide</a>
    </div>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Recall that <a href="files-and-filesystems.html#regular-files">a file</a> is a sequence of bytes.
        </p>
    </div>

    <p>
        A process is an instance of an executing program.<sup><a href="#references">[1]</a></sup><sup><a href="#references">[2]</a></sup>
        A <em>program</em> (also known as an "executable file")
        is a file containing the information required to
        construct a process.<sup><a href="#references">[1]</a></sup>
        The process is, after the file, the most important
        abstraction of operating systems.
    </p>
</div>

<div class="content" id="actors">
    <h2> Actors </h2>

    <p>
        In UNIX and its derivatives, processes are the actors of the system:
        Left to its own devices, the kernel does nothing.
        All UNIX-like operating systems depend upon processes to direct the kernel,
        and through the kernel, processes direct the machine.
        The result is a low-level demarcation between
        <em>what</em> to do (dictated by processes), and
        <em>how</em> to do it (dictated by the kernel).
    </p>

    <p>
        There is a process for every function on the system.
        There's one for the network manager,
        another for the desktop environment,
        another acting as a printer spooler,
        another acting as a web browser, etc..
    </p>

    <p>
        Each process has a narrowly defined role,
        which it is expected to do well.
        It might copy a file, list the
        contents of a directory, provide audio services,
        or intepret and execute commands.
        These many small programs are used together to accomplish
        a given task, thereby increasing the modularity of the whole,
        and simplifying programming and maintenance.
    </p>

    <p>
        The kernel is responsible for:
    </p>

    <ol>
        <li>
            Facilitating new process creation
        </li>
        <li>
            Allocating hardware resources to processes
        </li>
        <li>
            Maintaining information about processes
        </li>
        <li>
            Preserving each process's privacy
        </li>
    </ol>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://magcius.github.io/xplain/article/x-basics.html">Explanations - X-window System Basics</a></li>
        <li><a href="https://www.man7.org/linux/man-pages/man7/daemon.7.html"><code>daemon(7)</code></a> - Writing and packaging system daemons (Background Process)</li>
    </ul>
</div>

<div class="content" id="process-creation">
    <h2 style="margin-bottom: 0;"> Process Creation</h2>
    <h4>and System Startup</h4>

    <p>
        At the end of its boot sequence, the kernel launches a single program,
        <code>/sbin/init</code>,<sup><a href="https://en.wikipedia.org/wiki/Init">[3]</a></sup>
        and in so doing creates the system's first process.
        While init schemes
        <a href="https://arxiv.org/abs/0706.2748">have evolved</a>
        over the years, its purpose has not changed:
        It is a process with root-level permissions that acts as a
        manager of the system and trustee among processes.
    </p>

    <div class="aside-left">
        <h4>Aside:</h4>
        <p>
            You can check your <em>init</em> program with
        </p>

        <div class="code">
            $ ps --pid 1
        </div>

        <p>
            <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> is very common today.
        </p>
    </div>

    <p>
        <code>init</code>'s first responsibility is to bring up userspace.
        It does this by launching a sequence of programs, most of which
        are daemons, some of which the user interacts with directly.
        After this, it operates in the background, managing services,
        restarting them if they falter, and logging events for administrative
        purposes.
        Its final responsibility is to shut the system down cleanly.
    </p>

    <p>
        After execution of <code>init</code> begins, process creation is delegated
        to processes themselves, and is carried out through the
        <em><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">fork()</a></em> system call.
    </p>

    <p>
        A call to <em>fork()</em> instructs the kernel to duplicate the current process,
        and the two resulting processes are very nearly identical.<sup><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">[4]</a></sup>
        Of note, they continue executing the same program at the same spot,
        have the same open files, and have duplicate memory spaces.
        The newly created process is referred to as the <em>child</em> process,
        the original is called the <em>parent,</em> and we say
        that the child process <em>inherits</em> its parent's attributes.
    </p>

    <p>
        Of the few ways that parent and child do differ, one is important to us
        now:
        They each recieve a different return value from <em>fork()</em>.
        This allows them to act differently within the same program:
    </p>


    <pre>
        pid_t rv = fork();      // One process executes this line
        if(rv == 0) {           // Two processes execute this line
            // I am child

        } else if (rv &gt; 0) {
            // I am parent

        }
    </pre>

    <p>
        Their executions thereby diverge, and each is free to act independantly.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">fork(2)</code></a> - Create a child process</li>
    </ul>

</div>


<div class="content" id="process-attributes">
    <h2> Process Attributes </h2>
    <p>
        Upon birth, each process is given its own PID number by the kernel.
        This is guaranteed to be unique to the process, and remains constant
        throughout the process's life. It serves as a system-wide handle
        to the process.
    </p>

    <p>
        Associated with each PID are the following attributes:
    </p>

    <ul>
        <li>Name and location of executable file</li>
        <ul>
            <li>Location of next instruction within</li>
        </ul>
        <li>Files currently open</li>
        <ul>
            <li>Their access modes (read, write)</li>
            <li>Location wihin file</li>
        </ul>
        <li>Current working directory</li>
        <li>User ID, Group Id</li>
        <li>Environment variables</li>
    </ul>

    <p>
        All of these attributes are inherited from the process's parent,
        and most of this information is available for perusal in the
        <code>/proc/<i>PID</i></code> directory.
        In addition, the kernel offers <a href="https://man7.org/linux/man-pages/man2/intro.2.html">system calls</a>
        to allow a process to change its attributes.
    </p>

    <p>
        In order to give some idea of how
        processes interact with the kernel,
        we will consider one of them: Files currently open.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://man7.org/linux/man-pages/man7/credentials.7.html"><code>credentials(7)</code></a> - Process identifiers</li>
        <li><code><a href="https://man7.org/linux/man-pages/man2/intro.2.html">intro(2)</a></code> - Introduction to system calls</li>
    </ul>
</div>

<div id="file-descriptors" class="content">
    <h2> File Descriptors</h2>
    <p>
        Each file that a process has open is associated with a number
        (specifically, a nonnegative integer).
        This number is called a <em>file descriptor</em>,
        and is returned by the kernel in response to a request to open a file.
        The process, thereafter, uses it to refer to the 
        file when it wishes to act on it.
    </p>

    <p>
        In the following line, a process is instructing the kernel to
        open the file <em>rubber_ducky</em> for reading, and
        storing the kernel's response in the variable <em>fd</em>:
    </p>

    <pre>
        int fd = open("./rubber_ducky", O_RDONLY);
    </pre>

    <p>
        If this call failed (which it would if <code>./rubber_ducky</code> did not
        exist, for example), then <em>fd</em> would be assigned -1, an invalid file
        descriptor.
        We can therefore check with:
    </p>

    <pre>
        if (fd &lt; 0) {
                perror("open");     // Print error message
                exit(1);            // terminate process 
        }
    </pre>

    <p>
        and then continue as though <em>open()</em> had succeeded.
    </p>

    <p>
        In the following line, the kernel is directed to read at-most 
        <em>buff_size</em>
        bytes from file <em>fd</em>,
        and to place the data into the memory space denoted by <em>buff</em>.
    </p>

    <pre>
        int num_bytes_read = read(fd, buff, buff_size);
    </pre>

    <p>
        If all goes well, the system call will return with a nonnegative value,
        the number of bytes read;
        if the kernel encountered an error, it will return with a
        negative value.
        In either case, this value will be assigned to <em>num_bytes_read</em>,
        which may be checked similarly to <em>open().</em>
    </p>

    <p>
        <em>write()</em> is handled analogously, as is closing a file.
        Every system call has an entry in Section 2 of the manual.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><code><a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></code> - Read from a file descriptor</li>
        <li><a href="http://www.linfo.org/unix_philosophy.html">UNIX Philosophy Description</a> by The Linux Information Project (LINFO)</li>
    </ul>
</div>

<div class="content" id="exec">
    <h2>Executing a Different Program</h2>

    <p>
        Since new process creation is already handled through the <em>fork()</em>
        system call, 
        launching another program requires only introducing a system call
        to change the program currently being executed.
        This is what the <em>exec</em> system call does: 
    </p>

    <pre>
        pid_t rv = fork();
        if( rv == 0 ) {
            // I am child
            char *args[] = {"ls", "-l", NULL};
            execv("/bin/ls", args); 
                    // Execution of this program terminates here
                    // and continues at main() of /bin/ls

        } else if ( rv &gt; 0 ) {
            continue;
                    // Execution of parent process is unchanged
        }
    </pre>

    <p>
        This sequence is traditionally called <em>fork and exec.</em>
        and results in one process launching another program.
        Note that there is no need to adjust other process attributes, and indeed,
        they are preserved across <em>exec.</em>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://man7.org/linux/man-pages/man1/pstree.1.html"><code>pstree(1)</code></a> - Display a tree of processes</li>
        <li><code><a href="https://www.man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a></code> - Execute a program</li>
    </ul>
</div>

<div class="content" id="termination">
    <h2> Process Termination </h2>
    <p>
        A process may terminate for a few reasons:
    </p>

    <ul class="big-list">
        <li>
            Explicitly terminates its own execution
            <p>
                This is the usual and preferred route to terminate a process:
                The program finishes its job or identifies an error, 
                and explicitly terminates itself.
                This may be done by either calling <em>exit()</em>, or by
                returning from <em>main().</em>
            </p>
        </li>

        <li>
            It is told to terminate

            <p>
                A process may be told to terminate by another process through
                a <em>signal,</em> a primitive form of interprocess communication.
                This is abnormal process termination.
            </p>

            <p>
                Signals are brutal business; for process termination, the preferred 
                one is <code>SIGINT</code>, which affords the program 
                the oportunity to shut its process down cleanly.(Kerrisk, p389)
                At the command line, it is created and sent to the foreground
                process with CTRL+C.
            </p>

            <p>
                Command-line tools for sending signals to arbitrary 
                processes are <code><a href="https://www.man7.org/linux/man-pages/man1/kill.1.html">kill</a></code>,
                which refers to processes by PID, and
                <code><a href="https://www.man7.org/linux/man-pages/man1/killall.1.html">killall</a></code>,
                which refers to processes by program name.
            </p>
        </li>

        <li>
            It does something wrong
            <p>
                Almost always, this happens when the process tries
                to read or write a memory location not assigned to it,
                a condition known in Linux as <em>segmentation fault</em>.
                The kernel steps in, halts program execution and immediately
                terminates the process.
                Again, abnormal program termination.
            </p>

        </li>
    </ul>
</div>

<div class="content" id="closing-remarks">
    <h2 style="margin-bottom: 0;">Closing Remarks:</h2>
    <h4>Concurrency</h4>
    <p>
        With more than 50 years of use, the process is a well-studied
        abstraction.
        It is supported at both the hardware level and the software level.
        We will conclude this introduction of them by describing how a computer
        runs more than one process at a time&mdash; That is, how programs
        are executed <em>concurrently.</em>
    </p>

    <p>
        The fundamental insight is that, <em>A program's instructions are oblivious to
        time.</em>
        That is, a program's only assumption about its own execution
        is that each instruction follows the previous one, if any.
        Since this assumption does not depend upon time, it is possible to 
        stop its execution and save its state; and later, to reintroduce its 
        state and continue execution, while preserving the sequence of instructions.
        When carried out correctly, the program is oblivious to any such
        interruptions.
    <p>

    <p>
        The operating system's kernel, working in conjunction with hardware,
        is responsible for presenting each process with 
        <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">the illusion</a> 
        that it ran without interruption, and "concurrency" is achieved by 
        interweaving process execution with respect to time:
    </p>

    <p>
        (Depiction)
    </p>

  <h3> See Also: </h3>

    <ul>
        <li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">Operating Systems: Three Easy Pieces</a> Chapter 4: Processes</li>
        <li><a href="http://www.man7.org/tlpi/index.html">The Linux Programming Interface</a> by Michael Kerrisk (Not Free)</li>
        <li><a href="http://www.csapp.cs.cmu.edu/"> Computer Systems: A Programmer's Perspective, 3<sup>rd</sup> Ed.</a>, Chapter 9: Virtual Memory (Not free)</li>
        <li><a href="https://www.man7.org/linux/man-pages/man1/top.1.html"><code>top(1)</code></a> - Display Linux processes</li>
        <li><a href="./assets/check.c">check.c</a> - Double-check of the above snippets</li>
    </ul>
</div>

<div class="content" id="dr-fraser">
    <h2 style="margin-bottom: 2pt;"> Dr. Brian Fraser: </h2>
    <h4 style="margin-bottom: 18pt;"> Fork and Exec Linux Programming </h4>
    <iframe class="video" src="https://www.youtube-nocookie.com/embed/l64ySYHmMmY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li>
        Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.
    </li>
    <li>
        Bryant, R. E., & O'Hallaron, D. R. (2016).  Processes. In <em>Computer Systems: A Programmer's Perspective</em> (3rd ed., p. 732).  Upper Saddle River, New Jersey: Pearson.
    </li>
    <li>
        init - Wikipedia (3 Match 2021). Retrieved March 30, 2021, from <a href="https://en.wikipedia.org/wiki/Init">https://en.wikipedia.org/wiki/Init</a>
    </li>

    <li>
        Kerrisk, M. (2020, December 21). Fork(2) - Linux manual page. Retrieved February 09, 2021, from <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">https://www.man7.org/linux/man-pages/man2/fork.2.html</a>
    </li>

  </ol>
</div>
