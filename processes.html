---
layout: default
credits: default
title: Processes
last-updated: June, 2020
---

<!-- To Do: Citation needed in "regular files" -> heirarchical filestructure taken from Multics-->
<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#actors"> Actors </a></li>
    <li><a href="#sandbox"> Sandbox </a></li>
    <li><a href="#fork-and-exec"> Fork and Exec </a></li>
    <li><a href="#references"> References </a></li>
    <li><a href="#credits">Credits and Licenses</a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>Processes</h1>
  <h4>Under Construction!</h4>

  <p>
    A process is a running program.<sup><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">[1]</a></sup>
    A <em>program</em> is a file containing a range of information that describes how to
    construct a process at run time.<sup><a href="#references">[2]</a></sup>
    Modern operating systems, including GNU/Linux, are multiprocess operating systems, supporting
    multiple processes concurrently.
  </p>
</div>

<div class="content" id="actors">
  <h2> Actors </h2>
  <p>
    There are processes for every function on the system.
    There's one for the network manager,
    another for the desktop environment,
    another acting as a printer spooler, etc..
    On GNU/Linux operating systems, all aspects of processes
    are the responsibility of the the kernel;
    the only exception to this is that we explicitly tell the kernel which programs
    to launch.
    In this way, the kernel supports the use of the machine,
    without making stipulations on its use.
  </p>

  <p>
    The kernel:
  </p>

  <ol>
    <li> Facilitates new process creation </li>
    <li> Allocates hardware resources to each process </li>
    <li> Facilitates communication between processes </li>
    <li> Maintains metadata about processes </li>
  </ol>

  <p>
    Processes are the actors of the system.
    Under the Unix philosophy, each process has a narrowly defined role,
    which it is expected to do well.  It might copy a file, list the
    contents of a directory, or interpret and execute commands that the user inputs.
  </p>

  <p>
    We wish to run multiple processes simultaneously,
    so that <em>Bash</em> remains running while <em>ls</em> is executing.
    This is known as a multitasking or multiprogramming operating system, and all modern operating
    systems are multitasking.
    This is an unfortunate term, but <em>multiprocessor</em> is reserved to
    refer to a machine having, or an operating system supporting, multiple
    CPU's.<sup><a href="https://en.wikipedia.org/wiki/Multiprocessing">[3]</a></sup>
  </p>

  <p>
    We pause our discussion to give definitions of the words <em>dynamic</em> and <em>static.</em>
    An action occurs dynamically with respect to a process if it occurs during process
    execution.
    For instance, the kernel creates files <em>dynamically.</em>
    Similarly, an element of the process environment is dynamic if it can change
    during process execution.
    For example, the contents of a file may be dynamic, and the contents of a
    process's data structure are certainly dynamic.
    The obverse of dynamic is <em>static:</em>
    For any given process, an element of the programming environment is static with respect to the process if it is invariant
    throughout program execution.
    For instance, the CPU architecture of a machine is static with respect to each process.
  </p>

</div>

<div class="content" id="sandbox">
  <h2>Sandbox</h2>
  <p>
    Processes run on the machine in a "sandboxed" environment, such that each
    process is incapable of jeopardizing the stability of the machine,
    and cannot affect any other process in an unpredictable manner.
    This environment is composed of an allotment of memory, and restricted access to the machine's CPU(s).
  </p>

  <p>
    Memory is allotted to a process by the kernel, upon initialization of the process and
    often during process execution (i.e., dynamically).
    It is known as <em>virtual memory.</em>

    and the set of all
    A full explanation of virtual memory is quite involved, and outside the scope of this paper.
    For a formal development, see <em>Computer Systems: A Programmer's Perspective</em>,
    but be cautioned that this is not an easy subject.
  </p>

  <p>
    Each process runs its instructions directly on the CPU(s), by a technique
    known as <em>limited direct execution.</em><sup><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf">[3]</a></sup>
    It is <em>limited</em> in the sense that each process has access to
    only a restricted subset of the CPU's instructions.
    Notably, a process cannot access hardware beyond the CPU and memory directly,
    and it also cannot assume the identity of another process.
  </p>


  <h3>See Also</h3>
  <ul>
    <li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf"<em>Operating Systems, Three Easy Pieces: Address Spaces</em></a></li>
  </ul>

  </div>

<div class="content" id="fork-and-exec">
  <h2> Fork / Exec </h2>

  <p>
    Like all interactions with the kernel, instructing the kernel to generate a new
    process takes place through the system call interface.

    "Because programs are independent of the underlying hardware, it is easy
    to move them between UNIX systems running on different hardware if the programs
    do not make assumptions about the underlying hardware." (Bach, 5) [The Design of the Unix Operating System]
    User-space programs are what operating systems are all about.
    These are sometimes called "user-land processes," and it is expected that
    any user-space program can


  <p>
    The Unix kernel executes exactly one program, <em>init</em>.

        The Linux kernel facilitates process creation, supports existing processes,
        and launches exactly one, but otherwise pays no attention to processes;
        there's a very clear division of responsibilities, here:
        The kernel will exist with zero processes.
        It would, however, be impossible to interact with, and hence, useless.


</div>



<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li> Arpaci-Dusseau, Remzi H., Arpaci-Dusseau, Andrea C..  <em>Operating Systems: Three Easy Pieces.</em> Arpaci-Dusseau Books. Published August, 2018 (Version 1.00)</li>
    <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
  </ol>

</div>
