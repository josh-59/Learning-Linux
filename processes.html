---
layout: default
credits: default
title: Processes
last-updated: July, 2020
---

<!--
  TODO
  Current working directory -> Change with system call
      -> Absolute and relative pathnames -> kernel feature?
  File Access Permissions
  Memory layout
  Environment variables

<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#actors"> Actors </a></li>
    <li><a href="#proccess-creation"> Process Creation </a></li>
    <li><a href="#sandbox"> Sandbox </a></li>
    <li><a href="#process-attributes"> Process Attributes </a></li>

    <li><a href="#references"> References </a></li>
    <li><a href="#credits">Credits and Licenses</a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>Processes</h1>
  <h4>Under Construction!</h4>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Recall that <a href="files-and-filesystems.html#regular-files">a file</a> is a sequence of bytes.
    </p>
  </div>

  <p>
  A process is an instance of an executing program.<sup><a href="#references">[1]</a></sup><sup><a href="#references">[2]</a></sup>
    A <em>program</em> (also known as an "executable file")
    contains the information required to
    construct a process.<sup><a href="#references">[1]</a></sup>
    The  process is, after the <em>file,</em> the most important
    abstraction of operating systems.
  </p>

  </div>

  <div class="content" id="actors">

  <h2> Actors </h2>

  <p>
    Conceptually, processes are the actors of the system.
    Left to its own devices, the kernel does nothing;
    all Unix-like operating systems depend upon processes to direct the kernel,
    and through the kernel, processes direct the machine.
    The result is a clear demarcation between
    <em>what</em> to do (dictated by processes), and <em>how</em> to do
    it (dictated by the kernel).
  </p>

  <p>
    There are processes for every function on the system.
    There's one for the network manager,
    another for the desktop environment,
    another acting as a printer spooler, etc..
    The simplest feasible Unix-like operating system would boot with a single
    process, a shell program such as Bash.
    Without a process, the kernel is unreachable, and the system is static.
  </p>

  <p>
    The Linux Kernel:
  </p>

  <ol>
    <li>
      Facilitates new process creation
      <ul><li>Processes can direct the kernel to create a new process, through the
        <em>fork</em> and <em>exec</em> system calls</li></ul>
    </li>
    <li>
      Allocates hardware resources to each process
      <ul><li>Gives them a chance to run, by giving them time on the CPU and some memory</li></ul>
    </li>
    <li> Maintains information about processes, and assigns attributes to them
      <ul><li>This includes a unique PID and file access authority</li></ul>
    </li>
  </ol>

  <p>
    Under the Unix philosophy, each process has a narrowly defined role,
    which it is expected to do well.  It might copy a file, list the
    contents of a directory, or interpret and execute commands from the user.
    Together, these disparate parts field the running operating system known
    as <em>GNU/Linux.</em>
  </p>

  <h3> See Also: </h3>
  <ul>
    <li> <a href="https://man7.org/linux/man-pages/man1/top.1.html">top(1)</a> </li>
  </ul>
</div>

<div class="content" id="proccess-creation">
  <h2> Process Creation </h2>

  <p>
    At the end of the boot sequence, the kernel launches a single program,
    <code>/sbin/init</code>.<sup><a href="http://tldp.org/LDP/intro-linux/intro-linux.pdf">[2] CH4</a></sup>
    This program is responsible for
    spawning all other processes.<sup><a href="https://arxiv.org/abs/0706.2748">[3]</a></sup>
    While init schemes <a href="https://arxiv.org/abs/0706.2748">have evolved</a> over the years,
    its purpose has not changed.  It is a process with root-level permissions that acts as a
    trustee among processes; its central responsibility is to bring up
    userspace.<sup><a href="http://0pointer.de/blog/projects/systemd.html">[5]</a></sup>
  </p>

  <div class="aside-left">
    <h4>Aside:</h4>
    <p>
      You can check your <em>init</em> program with <br> <center><code>$ ps --pid 1</code></center><br>
      <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> is very common today.
    </p>
  </div>

  <p>
    Creating a new process begins with the <em><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">fork()</a></em> system call.
    This instructs the kernel to make a copy of the current process&mdash;
    an exact copy is produced, save one difference: Each of the two
    processes receives a distinct return value from <em>fork().</em>
    The new process is called the <em>child</em> process; the
    old process is called the <em>parent</em> process.
  </p>

  <p>
    The parent process usually goes on about its business, be it managing other
    user-space processes, as in the case of <em>init,</em> or querying the user
    for a new line of input, as in the case of a shell.
    The child goes on to call <em><a href="https://www.man7.org/linux/man-pages/man2/execve.2.html">execve(pathname, argv, envp)</a>.</em>
    This system call instructs the kernel to replace the current
    process with a brand-new one, by loading the executable file located at <em>pathname.</em>
  </p>

  <p>
    Upon birth, each process is given its own process id (PID) number by the kernel.
    This is guaranteed to be unique to the process, serves as the kernel's handle
    to the process, and remains constant throughout the process's life.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://www.man7.org/tlpi/"> The Linux Programming Interface</a> Chapter 24: Process Creation </li>
  </ul>
</div>

<div class="content" id="sandbox">
  <h2>Sandbox</h2>
  <p>
    One of the major ideas of modern computing is that each process is isolated
    from both the kernel and from other processes.
    This is done for a few reasons.
    First, we want to ensure that no process is capable of jeopardizing the
    stability of the system.
    Second, we want to ensure that no process can affect any other process
    in an unpredictable manner.
    We do this by running each process in a "sandboxed" environment, composed
    of restricted access to the machine's CPU, and a virtualized memory address
    space.
  </p>

  <h3> Limited Direct Execution </h3>

  <p>
    Modern CPU architectures support two
    distinct modes of operation.
    <em>Kernel mode,</em> sometimes called "supervisor mode," is the unrestricted mode.
    Here, all CPU instructions are available, so that code running in this mode
    has complete access to the machine.
    <em>User mode</em> is a proper subset of kernel mode; all processes run in user mode.
    If a process, running in user mode, attempts to execute a restricted instruction,
    its execution is halted, and control is given to the kernel.
    At that point, it is up to the operating system to determine what to do
    (usually, terminate the offending process).
  </p>

  <p>
    This technique is known as <em>limited direct execution.</em><sup><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf">[3]</a></sup>
    It is <em>limited</em> in the sense that each process has access to
    only a restricted subset of the CPU's instructions.
    It is <em>direct</em> in the sense that each process runs directly on hardware.
    It makes safe and efficient use of available hardware.
  </p>

  <p>
    For instance, no process can access a hard-drive directly.
    The proper avenue for a process to access such a device is through the kernel,
    via system calls.
    Through limited direct execution, this is
    <em>the only</em> way that a process can access it.
    This ensures that the kernel remains in charge of the machine's state.
  </p>

  <h3> Virtual Memory </h3>

  <p>
    Modern operating systems provide each process with its own memory in the
    form of a distinct <em>address space.</em>
    An address space is a collection of memory addresses; on all modern architectures,
    memory (RAM) is byte-addressable, so that each address refers to exactly one byte.
    Addresses themselves are simply numbers.
  </p>

  <div class="img-right" style="background: #f1f1f1;">
<a style="outline: solid black 2px; " title="Traced by User:Stannered, original by en:User:Dysprosia / BSD (http://opensource.org/licenses/bsd-license.php)" href="https://commons.wikimedia.org/wiki/File:Virtual_address_space_and_physical_address_space_relationship.svg"><img width="512" alt="Virtual address space and physical address space relationship" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Virtual_address_space_and_physical_address_space_relationship.svg/512px-Virtual_address_space_and_physical_address_space_relationship.svg.png"></a>
  </div>

  <p>
    Archaic operating systems allowed processes direct access to
    the system's main memory; they effectively shared the same address space.
    This posed significant issues for system stability and security&mdash;
    namely, one process could read and/or manipulate the memory of another.
  </p>

  <p>
  <em>Modern operating systems provide each process with a distinct
      address space.</em>
    The result has been a profound improvement in system stability.
    The addresses that the process uses are called "virtual"
    because they exist for that process alone.
    These virtual addresses are mapped onto physical addresses by
    the CPU, without the process ever being aware of it.
    This is referred to colloquially as "virtual memory."
  </p>

  <p>
    The virtual memory abstraction requires support from both the kernel
    and CPU.
    For each process, the kernel maintains an address translation table, which maps
    virtual addresses onto physical ones.
    This is loaded onto the <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>
    whenever the process runs,
    and the MMU carries out address translation automatically whenever in user mode.
  </p>

  <p>
    Crucially, not every virtual address needs to be mapped to a physical address&mdash;
    it only needs to <em>appear</em> so when the process accesses it.
    If a process references a virtual address that is not mapped,
    the CPU interrupts execution of the process and defers control to the kernel.
    If the memory address should be mapped, the kernel loads that data into memory,
    modifies the translation table and returns control to the process.
    If the memory should not be mapped (i.e., it is an undefined address), the
    kernel aborts execution of the program.
  </p>

  <p>
    Through the mechanism of virtual memory, each process is presented with
    the illusion that it has the entirity of the machine's memory to
    itself.
    Other processes are intrinsically protected from memory tampering:
    Their memory simply does not exist within the context of the
    currently running process, and therefore cannot be read from, nor written to,
    by it.
    As with limited direct execution, virtual memory facilitates
    the safe and efficient use of a machine resource.
  </p>

  <h3> See Also: </h3>
  <ul>
    <li><a href="https://www.makeuseof.com/tag/virtual-memory-low-heres-fix/"> Is Your Virtual Memory Too Low?  Here's How to Fix It!</a> (WRONG!)</li>
    <li><a href="http://www.csapp.cs.cmu.edu/"> Computer Systems: A Programmer's Perspective, 3<sup>rd</sup> Ed.</a>, Chapter 9: Virtual Memory (Not free)</li>
  </ul>
</div>

<div class="content" id="process-attributes">
    <h2> Process Attributes </h2>
    <p>
        Each process on the system has
    </p>


    		    Current working directory:
    				<p>
    					Each process has a <em>current working directory</em>, a place in
              the directory tree.
    				</p>


    <h3> See Also: </h3>
    <ul>
      <li><a href="https://man7.org/linux/man-pages/man5/proc.5.html"> proc(5)</a></li>
    </ul>
</div>

<div id="closing-remarks" class="content">
    <h2> Closing Remarks </h2>
  <p>
    We pause our discussion to give definitions of the words <em>dynamic</em> and <em>static.</em>
    An action occurs dynamically with respect to a process if it occurs during process
    execution.
    For instance, the kernel creates files <em>dynamically.</em>
    Similarly, an element of the process environment is dynamic if it can change
    during process execution.
    The obverse of dynamic is <em>static:</em>
    For any given process, an element of the programming environment is static with respect to the process if it is invariant
    throughout program execution.
    For instance, the CPU architecture of a machine is static.
    Note that the contents of a file may be dynamic, or they may be static.
  </p>

  <h3> See Also: </h3>
  <ul>
    <li>< a href="https://www.man7.org/linux/man-pages/man7/daemon.7.html"> daemon(7) </a></li>q
  </ul>
</div>


<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
    <li>
        Bryant, R. E., & O'Hallaron, D. R. (2016).  Processes. In <em>Computer Systems: A Programmer's Perspective</em> (3rd ed., p. 732).  Upper Saddle River, New Jersey: Pearson. </li>
  </ol>

</div>
