---
layout: default
title: Processes
last-updated: November, 2020
---

<!--
TODO
    Sandbox:
        Remove references to "MMU"
    
    Process tree:
        Child processes cannot change parent processes' attributes
        I dunno, "develop"

    Process attributes:
        File Descriptors:
            Open a new file, not "read"
            "The file is now available for writing."

    Process Termination:
        When a process terminates, its PID is freed for reuse, 

        Signals to kill processes:
            From least to greatest:
            SIGINT: Interrupt
                Default behavior is to terminate, but can be caught and
                handled by programs, and is sometimes used for other purposes.
                For instance, <code>bash</code> catches this signal and does
                not terminate; rather, it passes the signal along to the foreground
                process (if it exists), and then jumps back to its main loop.
                
            SIGTERM: Terminate
                Standard behavior is to terminate; affords programs the
                opportunity to handle their own termination, and thereby
                exit gracefully

            SIGKILL: Sure Kill
                Terminates process immediately.  Cannot be caught nor handled.
                Kerrisk calls <code>SIGKILL</code> the "silver bullet" of process
                termination (page 553)
                and recommends sending SIGTERM instead

        Signal-terminal of processes: "Abnormal process termination"

    IPC:    (as conclusion?)
        Primitives:
            Signals - Software interupts: Interupt the normal flow of
                execution in a program (Kerrisk, p388)
            Sockets - Shuffle data
            Shared Memory - Don't do it!
            FIFO Pipes - More later

        <div class="aside-right">
            <h4>Aside</h4>
            <p>
                D-Bus is an excellent example of what a process 
                is capable of, but 
                has been effectively depricated by <code>kdbus</code>,
                which is easier to use, more efficient, and more secure, among
                other things.
            </p>
        </div>

        D-Bus
            Provide a high-level IPC interface, based principally around
                Object-Oriented methodologies (methods, attributes, etc),
                but which runs as a process.
            Also, a "point-to-point communications library", libdbus

            System daemon!
                Inefficient!
            Method Call Transactions: Call a method from another process and
                get a response

        mirror.linuux.org.au/pub/linux.conf.au/2014/Friday/104-D-Bus_in_the_kernel_-_Lennart_Poettering.mp4

        See Also:
            https://magcius.github.io/xplain/article/x-basics.html


        Closing Remarks:
            Tools to introspect processes: top, /proc, etc

            Introduce programs, rather than programming. 
            The Linux kernel actually supports four executable file formats:
            a.out, ELF, interpretter scripts and 

-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#actors"> Actors </a></li>
        <li><a href="#process-creation"> Process Creation and System Startup </a></li>
        <li><a href="#process-attributes"> Process Attributes </a></li>
        <li><a href="#file-descriptors"> File Descriptors </a></li>
        <li><a href="#exec">Executing a Different Program</a></li>
        <li><a href="#termination">Process Termination</a></li>
        <li><a href="#sandbox"> Sandbox </a></li>
        <li><a href="#dr-fraser"> Dr. Brian Fraser </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Processes</h1>
    <div class="quote-text">
        "Theory and practice sometimes clash.  <br>
        And when that happens, theory loses.
        Every single time.
    </div>
    <div class="quote-ref">
        &mdash;<a href="https://lwn.net/Articles/326505/">Linus Torvalds</a>
    </div>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Recall that <a href="files-and-filesystems.html#regular-files">a file</a> is a sequence of bytes.
        </p>
    </div>

    <p>
        A process is an instance of an executing program.<sup><a href="#references">[1]</a></sup><sup><a href="#references">[2]</a></sup>
        A <em>program</em> (also known as an "executable file")
        contains the information required to
        construct a process.<sup><a href="#references">[1]</a></sup>
        The process is, after the file, the most important
        abstraction of operating systems.
    </p>

</div>

<div class="content" id="actors">

    <h2> Actors </h2>

    <p>
        In Unix and its derivatives, processes are the actors of the system:
        Left to its own devices, the kernel does nothing.
        This is a defining feature of the Unix architecture&mdash;
        All Unix-like operating systems depend upon processes to direct the kernel,
        and through the kernel, processes direct the machine.
        The result is a clear demarcation between
        what to do (dictated by processes), and how to do
        it (dictated by the kernel).
    </p>

    <p>
        The kernel is responsible for:
    </p>

    <ol>
        <li>
            Facilitating new process creation
        </li>
        <li>
            Allocating hardware resources to each process
        </li>
        <li>
            Maintaining information about processes
        </li>
        <li>
            Facilitating change of their attributes
        </li>
    </ol>

    <p>
        There are processes for every function on the system.
        There's one for the network manager,
        another for the desktop environment,
        another acting as a printer spooler, 
        Firefox runs as a process, etc..
    </p>

    <p>
        Under the Unix philosophy, each process has a narrowly defined role,
        which it is expected to do well.  It might copy a file, list the
        contents of a directory, provide audio services, or browse the internet.
        It is intended that these programs work together to
        accomplish any given task, thereby 
        increasing the modularity of the whole, and,
        consequently, easing programming and maintenance.
    </p>

    <h3> Runlevels</h3>

    <p>
        Historically, collections of running processes were
        called <a href="http://www.linfo.org/runlevel_def.html">runlevels</a>,
        and were managed by the initialization ("init") process.
        Different runlevels offered different services, and therefore
        were intended to be used in different situations.
        For instance, <a href="http://www.linfo.org/single_user_mode.html">single-user mode</a> (runlevel 1)
        was analogous to <em>safe boot,</em> 
        runlevel 5 corresponded to multi-user/GUI mode,
        and runlevel 0 told <em>init</em> to kill all processes and shut down the 
        system.<sup><a href="http://www.linfo.org/runlevel_def.html">[3]</a></sup>
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://www.man7.org/linux/man-pages/man7/daemon.7.html"> daemon(7)</a> (Background Process)</li>
        <li><a href="https://www.brianstorti.com/an_introduction_to_unix_processes/"> An introduction to UNIX processes</a> (An article similar to this one)</li>
    </ul>
</div>

<div class="content" id="process-creation">
    <h2 style="margin-bottom: 0;"> Process Creation</h2>
    <h4>and System Startup</h4>

    <p>
        At the end of the boot sequence, the kernel launches a single program,
        <code>/sbin/init</code>,<sup><a href="http://tldp.org/LDP/intro-linux/intro-linux.pdf">[4]</a></sup>
        and in so doing creates the system's first process.
        After <code>/sbin/init</code> begins execution, 
        process creation is delegated to processes themselves.
        While init schemes 
        <a href="https://arxiv.org/abs/0706.2748">have evolved</a> 
        over the years, its purpose has not changed:  
        It is a process with root-level permissions that acts as a 
        manager of the system and trustee among processes.
    </p>

    <div class="aside-left">
        <h4>Aside:</h4>
        <p>
            You can check your <em>init</em> program with
        </p>

        <code>
            $ ps --pid 1
        </code>

        <p>
            <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> is very common today.
        </p>
    </div>

    <p>
        <code>init</code>'s first responsibility is to bring up userspace. 
        It does this by launching a sequence of programs, most of which
        act as services, some of which the user interacts with directly.
        After this, it operates in the background, managing these services,
        restarting them if they falter, and logging events for administrative
        purposes.
        Its final responsibility is to shut the system down cleanly. 
    </p>

    <p>
        From within a process, creating a new process is restricted to the 
        <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html"><code>fork(2)</code></a> system call. 
        This instructs the kernel to duplicate the current process; 
        the two resulting processes are nearly identical.<sup><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">[4]</a></sup>
        Of note, they have duplicate memory spaces, and
        continue executing the same program at the same spot.
        The newly created process is referred to as the <em>child</em> process, 
        the calling process is referred to as the <em>parent,</em> and we say 
        that the child process <em>inherits</em> its parent's attributes.
    </p>

    <p>
        Of the ways that parent and child differ, one is important to us 
        now:
        They each recieve a different return value from <em>fork()</em>.
        This allows them to act differently within the same program:
    </p>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            Any process may call <em>fork()</em>.
        </p>
    </div>

        <pre>
        pid_t rv = fork();
        if(rv == 0) {
            // I am child.

        } else if (rv &gt; 0) {
            // I am parent

        }
        </pre>
    
    <p>
        Their executions thereby diverge, and each is free to act independantly.
    </p>

    <p>
        Finally, note that each process, less <code>init</code>, has a 
        unique parent process. 
        As such, the collection of processes on the system forms a tree,
        with <code>init</code> at root.
        This is viewable with the <a href="https://man7.org/linux/man-pages/man1/pstree.1.html"><code>pstree(1)</code></a> command.
    </p>


  </div>

<div class="content" id="process-attributes">
    <h2> Process Attributes </h2>
    <p>
        Upon birth, each process is given its own process id (<code>PID</code>) number by the 
        kernel.
        This is guaranteed to be unique to the process, and remains constant 
        throughout the process's life; it serves as the system's handle
        to the process.
    </p>

    <p>
        For each process on the system, the kernel 
        maintains a great deal of information, including:
    </p>

    
    <ul>
        <li>Name and location of executable file</li>
        <ul>
            <li>Location of next instruction within</li>
        </ul>
        <li>Files currently open by the process</li>
        <ul>
            <li>Their access modes (read, write)</li>
            <li>Location wihin file</li>
        </ul>
        <li>Current working directory</li>
        <li>Owner, group</li>
        <li>Environment variables</li>
    </ul>

    <p>
        With the exception of <code>PID</code>, all attributes are inherited from 
        the process's parent.
        Most of this information is available for perusal in the 
        <code>/proc/</code> directory.
        Finally, the kernel offers <a href="https://man7.org/linux/man-pages/man2/intro.2.html">system calls</a> 
        to allow a process to change these attributes.
    </p>

    <p>
        In order to give some idea of how 
        processes interact with the kernel,
        we will consider one of them: Files currently open.
    </p>
</div>

<div id="file-descriptors" class="content">
    <h2> File Descriptors</h2>
    <p>
        Each file that a process has open is assigned a number
        by the kernel (specifically, a small integer).
        This number is called a <em>file descriptor</em>, 
        and is returned by the kernel in response to a request to open a file.
        The process, thereafter, uses this integer to refer to that 
        file whenever it wishes to operate on it.
    </p>

    <p>
        In the following line, a process is opening the file 
        <em>rubber_ducky</em> for reading, then
        storing the kernel's response as <em>fd</em>:
    </p>

    <pre>
        int fd = open("./rubber_ducky", O_RDONLY);
    </pre>

    <p>
        If this call failed (which it would if <code>rubber_ducky</code> did not
        exist), then <code>fd</code> would be assigned -1, an invalid file
        descriptor.
        If the call succeeded, <code>fd</code> will be nonnegative.
        We can therefore check with:
    </p>

    <pre>
        if (fd &lt; 0) {
                perror("open"); 
                exit(1);
        }
    </pre>

    <p>
        and then continue as though <em>open</em> had succeeded.
    </p>

    <p>
        Thereafter, the process uses <code>fd</code> whenever it wishes 
        to refer to <em>rubber_ducky</em>, 
        as in the following call to 
        <code><a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></code>:
    </p>

    <pre>
        int num_bytes_read = read(fd, buff, buff_size);
    </pre>

    <p>
        The kernel will read at-most <code>buff_size</code>
        bytes, and store the data into the buffer <code>buff</code>.
        If all goes well, the system call will return with a nonnegative value;
        if the kernel encountered an error, it will return with a 
        negative value.
        In either case, this value will be assigned to 
        <code>num_bytes_read</code>.
    </p>

    <p>
        <a href="https://man7.org/linux/man-pages/man2/write.2.html"><code>Write(2)</code></a> 
        is handled analogously; every system call has a well-defined and 
        stable interface, and an entry in the man pages.
    </p>

    <h3 id="standard-file-descriptors">Standard File Descriptors</h3>
    <p>
        File descriptors <em>0, 1,</em> and <em>2</em> are somewhat special:
        By both long-standing convention and the POSIX standard, 
        they are guaranteed to be open and available for use at program startup.
        They are:
    </p>

     <ul style="margin-left: 5%; list-style-type: none;">
        <li><code>STDIN</code> is located at file descriptor 0; open for reading</li>
        <li><code>STDOUT</code> is located at file descriptor 1; open for writing</li>
        <li><code>STDERR</code> is located at file descriptor 2; open for writing</li>
    </ul>

    <p>
        They are referred to as the <em>Standard File Descriptors,</em>
        and at the command line, they are the primary source of input and output.
    </p>

</div>


<div class="content" id="exec">
    <h2>Executing a Different Program</h2>
    <p>
        The <code>fork(2)</code> system call creates a new process, but
        since this new process has a memory space duplicated from its parent, 
        it continues executing the same program.
        In order to launch a different program, it is necessary to replace this
        memory image with one obtained from a file.
        This is what the <a href="https://www.man7.org/linux/man-pages/man2/execve.2.html"><code>exec(2)</code></a> family of system calls do.
    </p>

    <p>
        To launch a new program, then, is a two-step process: 
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Any process may call <em>exec()</em>.
        </p>
    </div>

    <pre>
        pid_t rv = fork();
        if( rv == 0 ) {
            // I am child
            char *args[] = {"ls", "-l", NULL};
            execvp(args[0], args);

        } else if ( rv &gt; 0 ) {
            // I am parent
            printf("%s", PROMPT);
            getline(input);
            return 0;

        }
    </pre>

    <p>
        This sequence is traditionally called <em>fork and exec,</em>
        and results in one process (the parent) launching another program
        (its child).
        It was present in Ken Thompson's original implementation of Unix at Bell 
        Laboratories, and for reasons I hope to bear out, is ideal for 
        programs at the command-line.
    </p>

</div>

<div class="content" id="termination">
    <h2> Process Termination </h2>
    <p>
        A process may terminate for a few reasons:
    </p>

    <ul class="big-list">
        <li> 
            Return from <em>main()</em> 
            <p>
                This is the usual and preferred route to terminate a process:
                It finishes its job, and explicitly requests to return.
            </p>

            <p>
                When this occurs on the command line, the process's return value (and it must offer one) is available 
                for inspection.  
                By convention, a return value of zero indicates success, while nonzero return
                values indicate error or fault.
            </p>
        </li>
        <li>
            It is told to terminate
            <p>
                A process may be told to terminate by any other process with
                the same owner.
                A process owned by root (that is, a process with superuser priveledges) 
                can instruct any process to terminate.
            </p>

            <p>
                Command-line tools for terminating processes are <code><a href="https://www.man7.org/linux/man-pages/man1/kill.1.html">kill(1)</a></code>,
                which refers to processes by their PID numbers, and
                <code><a href="https://www.man7.org/linux/man-pages/man1/killall.1.html">killall(1)</a></code>,
                which kills processes by name.
            </p>
        </li> 
        <li>
            It does something wrong
            <p>
                Almost always, this happens when the offending process tries to read or write
                a memory location not assigned to it, a condition known in Linux
                as <em>segmentation fault</em>.
            </p>

            <p>
                Note that when this occurs, it is not the case that the process is 
                trying to read or write some other process's memory.
                Rather, every process is given its own virtual memory address space (see below);
                the kernel kills it because the memory in question is not associated
                with the process in any meaningful way.
            </p>
        </li>
    </ul>

</div>



<div class="content" id="sandbox">
    <h2>Sandbox</h2>
    <p>
        What is a process, though?
        All this talk about memory bears out an important aspect of computers:
        All the CPU can do is modify memory, and programming, in a nontrivial
        sense, boils down to using the CPU to modify memory safely and 
        effectively.
    </p>

    <p>
        How can an operating system define <em>safely?</em>
        Well, within a program, it cannot, since the program's doings are
        its own business.
        Rather, modern operating systems create a sandboxed environment within
        which to execute programs.
    </p>

    <p>
        This environment is composed of restricted access to the CPU,
        and a distinct memory space.
        Simply put, a process can neither modify another process's memory,
        nor can it modify system memory, because <em>that memory does not
        exist within the context of the process.</em>
    </p>

    <p>
        The program is thus isolated, and can do anything it likes, within
        its own environment.
        Let's take these one at a time.
    </p>


    <h3> Limited Direct Execution </h3>

    <p>
        Modern CPU architectures support two
        distinct modes of operation.
        <em>Kernel mode,</em> sometimes called "supervisor mode," is the unrestricted mode.
        Here, all CPU instructions are available, and all memory is available, 
        so that code running in this mode has complete access to the machine.
    </p>

    <p>
        <em>User mode</em> is a proper subset of kernel mode; code running 
        in user mode does not have access to all instructions.  
        All processes run in user mode, and 
        if a process, running in user mode, attempts to execute a restricted 
        instruction, its execution is halted, and control is given to the kernel.
        At that point, it is up to the operating system to determine what to do
        (usually, terminate the offending process).
    </p>

    <p>
        This technique is known as <em>limited direct execution.</em><sup><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf">[3]</a></sup>
        It is <em>limited</em> in the sense that each process has access to
        only a restricted subset of the CPU's instructions, and 
        it is <em>direct</em> in the sense that each process runs directly on 
        hardware.
        It is intended to make safe and efficient use of available hardware.
    </p>

    
  <h3> Virtual Memory </h3>

  <p>
    Modern operating systems provide each process with its own memory in the
    form of a distinct <em>address space.</em>
    An address space is a collection of memory addresses; on all modern architectures,
    memory is byte-addressable, so that each address refers to exactly one byte.
    Addresses themselves are simply numbers, usually expressed in hexadecimal.
  </p>

  <div class="img-right" style="background: #f1f1f1;">
<a style="outline: solid black 2px; " title="Traced by User:Stannered, original by en:User:Dysprosia / BSD (http://opensource.org/licenses/bsd-license.php)" href="https://commons.wikimedia.org/wiki/File:Virtual_address_space_and_physical_address_space_relationship.svg"><img width="512" alt="Virtual address space and physical address space relationship" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Virtual_address_space_and_physical_address_space_relationship.svg/512px-Virtual_address_space_and_physical_address_space_relationship.svg.png"></a>
  </div>

  <p>
    Some archaic operating systems (such as the
    <a href="https://en.wikipedia.org/wiki/Exec_(Amiga)">Amiga</a>)
    allowed processes direct access to
    the system's main memory; processes effectively shared the same address space.
    This poses significant issues for system stability and security&mdash;
    namely, one process could read and/or manipulate the memory of another.
  </p>

    <p>
        <em>Modern operating systems provide each process with a distinct
        address space.</em>
        The addresses that any process uses are implicitly restricted to that 
        process alone.
        The result has been a profound improvement in system stability.
    </p>

  <p>
    The virtual memory abstraction requires support from both the kernel
    and CPU:
    For each process, the kernel maintains an address translation table, which maps
    virtual addresses onto physical ones.
    This is loaded onto the CPU's
    <a href="https://en.wikipedia.org/wiki/Memory_management_unit">Memory Management Unit</a>
    whenever the process runs,
    and the MMU carries out address translation automatically whenever in user mode.
  </p>

  <p>
    Crucially, not every virtual address needs to be mapped to a physical address.
    Rather, when a process references a virtual address that is not mapped,
    the MMU instructs the CPU to interrupt execution of the process; the CPU
    defers control to the kernel.
    If the memory address should be mapped, the kernel loads that data into memory,
    modifies the translation table and returns control to the process.
    If the memory should not be mapped (i.e., it is an undefined address), the
    kernel aborts execution of the program.
  </p>

  <p>
    Through the mechanism of virtual memory, each process is presented with
    the illusion that it has the entirety of the machine's memory to
    itself.
    Other processes are implicitly protected from memory tampering:
    Their memory simply does not exist within the context of the
    currently running process, and therefore cannot be read from, nor written to.
    As with limited direct execution, virtual memory is intended to 
    facilitate the safe and efficient use of a machine resource.
  </p>

    <h3>Putting it all together:</h3>

    <p>
        For processes, access to the CPU is also restricted in a temporal sense: 
        Each process is allotted some time to run, and when its time is up,
        the kernel interrupts execution, saves the state of the process (precisely),
        and loads a different process to run.
        That one runs for a bit, and then it too is interupted, and a new
        process allowed to run for a while.
        This is known as a <em>context switch,</em> and is the root
        of multiprocessing 
    </p>



  <h3> See Also: </h3>
  <ul>
    <li><a href="http://www.csapp.cs.cmu.edu/"> Computer Systems: A Programmer's Perspective, 3<sup>rd</sup> Ed.</a>, Chapter 9: Virtual Memory (Not free)</li>
    <li><a href="https://www.makeuseof.com/tag/virtual-memory-low-heres-fix/"> Is Your Virtual Memory Too Low?  Here's How to Fix It!</a> (WRONG!)</li>
  </ul>
</div>

<div class="content" id="dr-fraser">
    <h2 style="margin-bottom: 2pt;"> Dr. Brian Fraser: </h2>
    <h4 style="margin-bottom: 18pt;"> Fork and Exec Linux Programming </h4>
    <iframe class="video" src="https://www.youtube-nocookie.com/embed/l64ySYHmMmY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li>
        Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.
    </li>
    <li>
        Bryant, R. E., & O'Hallaron, D. R. (2016).  Processes. In <em>Computer Systems: A Programmer's Perspective</em> (3rd ed., p. 732).  Upper Saddle River, New Jersey: Pearson.
    </li>
    <li>
        Runlevel Definition. (2007, September 6). Retrieved February 09, 2021, from <a href="http://www.linfo.org/runlevel_def.html">http://www.linfo.org/runlevel_def.html</a>

    </li>
    <li>
        Kerrisk, M. (2020, December 21). Fork(2) - Linux manual page. Retrieved February 09, 2021, from <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">https://www.man7.org/linux/man-pages/man2/fork.2.html</a>
    </li>
    <li>
        Garrels, M. (2008). <em>Introduction to Linux: A Hands on Guide.</em>
    </li>
    <li>
        Royon, Y., &amp; Frenot, S. (2007). A Survey of Unix Init Schemes (Doctoral dissertation, Inria Rhone-Alpes) (p. 0-39). Mountbonnot Saint Ismier: Unite de recherche Inra Rhone-Alpes.
    </li>
    <li>
        Poettering, L. (2010, April 30). Rethinking PID 1. Retrieved September 01, 2020, from <a href="http://0pointer.de/blog/projects/systemd.html">http://0pointer.de/blog/projects/systemd.html</a>
    </li>

  </ol>

</div>
-
-

