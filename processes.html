---
layout: default
credits: default
title: Processes
last-updated: June, 2020
---

<!-- To Do: Citation needed in "regular files" -> heirarchical filestructure taken from Multics-->
<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#actors"> Actors </a></li>
    <li><a href="#proccess-creation"> Process Creation </a></li>
    <li><a href="#sandbox"> Sandbox </a></li>
    <li><a href="#references"> References </a></li>
    <li><a href="#credits">Credits and Licenses</a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>Processes</h1>
  <h4>Under Construction!</h4>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      Recall that <a href="files-and-filesystems.html#regular-files">a file</a> is a sequence of bytes.
    </p>
  </div>

  <p>
    A process is an instance of an executing program.<sup><a href="#references">[1]</a></sup>
    A <em>program</em> (also known as an "executable file")
    contains a range of information that describes how to
    construct a process at run time.<sup><a href="#references">[1]</a></sup>
    The  process is, after the <em>file,</em> the most important
    abstraction of operating systems.
  </p>
</div>

<div class="content" id="actors">
  <h2> Actors </h2>

  <p>
    Conceptually, processes are the actors of the system.
    Left to its own devices, the kernel does nothing;
    all GNU/Linux operating systems depend upon processes to direct the kernel,
    and through the kernel, processes direct the machine.
    The result is a clear delineation between
    <em>what</em> to do (dictated by processes), and <em>how</em> to do
    it (dictated by the kernel).
  </p>

  <p>
    There are processes for every function on the system.
    There's one for the network manager,
    another for the desktop environment,
    another acting as a printer spooler, etc..
    The simplest feasible Unix-like operating system would boot with a single
    process, a shell program such as Bash.
    Without a process, the kernel is unreachable, and the system is static.
  </p>

  <p>
    On GNU/Linux operating systems, the kernel:
  </p>

  <ol>
    <li>
      Facilitates new process creation
      <ul><li>Processes can direct the kernel to create a new process, through the
        <em>fork</em> and <em>exec</em> system calls</li></ul>
    </li>
    <li>
      Allocates hardware resources to each process
      <ul><li>Gives them a chance to run, by giving them time on the CPU and some memory (parts of this are automatic)</li></ul>
    </li>
    <li>
      Facilitates communication between processes
      <ul><li>"Inter-Process Communication"</li></ul></li>
    <li> Maintains information about processes, and assigns attributes to them
    </li>
  </ol>

  <p>
    Under the Unix philosophy, each process has a narrowly defined role,
    which it is expected to do well.  It might copy a file, list the
    contents of a directory, or interpret and execute commands from the user.
    Together, these disparate parts field the running operating system known
    as <em>GNU/Linux.</em>
  </p>
</div>

<div class="content" id="proccess-creation">
  <h2> Process Creation </h2>

  <p>
    At the end of the boot sequence, the kernel launches a single program,
    <code>/sbin/init</code>.<sup><a href="http://tldp.org/LDP/intro-linux/intro-linux.pdf">[2] CH4</a></sup>
    This program is responsible for
    spawning all other processes.<sup><a href="https://arxiv.org/abs/0706.2748">[3]</a></sup>
  </p>

  <div class="aside-left">
    <h4>Aside:</h4>
    <p>
      You can check your <em>init</em> program with <br> <center><code>$ ps --pid 1</code></center><br>
      systemd is very common today.
    </p>
  </div>

  <p>
    While init schemes <a href="https://arxiv.org/abs/0706.2748">have evolved</a> over the years,
    their purpose has not changed.  It is a process with root-level permissions that acts as a
    trustee among processes; its central responsibility is to bring up
    userspace.<sup><a href="http://0pointer.de/blog/projects/systemd.html">[5]</a></sup>
  </p>

  <p>
    Creating a new process begins with the <em><a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">fork()</a></em> system call.
    This instructs the kernel to make a copy of the current process&mdash;
    an exact copy is produced, save one difference: Each of the two
    processes receives a distinct return value from <em>fork().</em>
    The new process is called the <em>child</em> process; the
    old process is called the <em>parent</em> process.
  </p>

  <p>
    The parent process usually goes on about its business, be it managing other
    user-space processes in the case of <em>init,</em> or querying the user
    for a new line of input, in the case of a shell.
    The child goes on to call <em><a href="https://www.man7.org/linux/man-pages/man2/execve.2.html">execve(pathname, argv, envp)</a>.</em>
    This system call instructs the kernel to replace the current
    process with a brand-new one, by loading the executable file located at <em>pathname.</em>
  </p>

  <h3>See Also:</h3>
  <ul>
    <li><a href="https://www.freedesktop.org/wiki/Software/systemd/"> systemd - freedesktop.org</a></li>
    <li><a href="http://0pointer.de/blog/projects/the-biggest-myths.html"> Myths of systemd </a></li>
    <li><a href="https://www.man7.org/tlpi/"> The Linux Programming Interface</a> Chapters 24-28 </li>
  </ul>

</div>

<div class="content" id="sandbox">
  <h2>Sandbox</h2>
  <p>
    Each process on a Unix-like operating system is distinct in several ways.

  <p>
    For each process on the system, we wish to guarantee a few things.
    We want to ensure that the process is incapable of jeopardizing the stability of the
    machine, so that it cannot (inadvertently or not) crash the system.
    We also want to ensure that each process cannot affect any other process in
    an unpredictable manner.
    In effect, we wish to treat user-space programs as <em>untrusted</em> software,
    for the benefit of the system as a whole.
  </p>

  <p>
    The way we do this is by running each process in a
    "sandboxed" environment, composed of an allotment of memory,
    and restricted access to the machine's CPU(s).
    Modern CPU architectures support this abstraction by fielding two
    distinct modes of operation.
    <em>Kernel mode</em> is the unrestricted mode; here, all
    CPU instructions are available.
    <em>User mode</em> is a proper subset of that instruction set;
    all processes run in user mode.
    If a process, running in user mode, attempts to execute a restricted instruction,
    its execution is aborted, and control is
    given to the kernel.
    At that point, it is up to the operating system to determine what to do
    (usually, terminate the offending process).
  </p>

  <p>
    This technique is
    known as <em>limited direct execution.</em><sup><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf">[3]</a></sup>
    It is <em>limited</em> in the sense that each process has access to
    only a restricted subset of the CPU's instructions.
    It is <em>direct</em> in the sense that each process runs directly on hardware.
    It makes safe and efficient use of available hardware.
  </p>

  <p>
    A similar story unfolds in the case of process memory, but is slightly more
    complicated because we wish to give each process the illusion that it has
    the same memory space.
    Physical memory is allotted to each process by the kernel.  With the exception
    of read-only sections of memory (such as the program's instructions), each
    process is allotted distinct physical memory.
    This physical memory is mapped onto <em>virtual memory</em> by
    a translating table.
    The process sees and references virtual memory; the CPU translates
    these virtual addresses to physical addresses;
    the kernel is responsible for maintaining the translating tables and physical memory.
  </p>

  <p>
    If a process attempts to access an invalid (i.e., unassigned) memory address,
    execution of the process is aborted, and control is given to the kernel.
  </p>

  <p>
    The above are quite dramatic simplifications of
    low-level operating systems concepts.
    There are two good reasons for including them.
    First, it's important to recognize that each process is distinct;
    this explains how they are distinct.
    Second, a high-level overview will only make a thorough investigation
    easier.
  </p>

  <h3>See Also</h3>
  <ul>
    <li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/"><em>Operating Systems: Three Easy Pieces</em></a> (Free book)</li>
  </ul>

  </div>



<div id="closing-remarks" class="content">
  <p>
    We pause our discussion to give definitions of the words <em>dynamic</em> and <em>static.</em>
    An action occurs dynamically with respect to a process if it occurs during process
    execution.
    For instance, the kernel creates files <em>dynamically.</em>
    Similarly, an element of the process environment is dynamic if it can change
    during process execution.
    The obverse of dynamic is <em>static:</em>
    For any given process, an element of the programming environment is static with respect to the process if it is invariant
    throughout program execution.
    For instance, the CPU architecture of a machine is static.
    As a final word, note that the contents of a file may be dynamic, or they may be static.
  </p>
</div>



<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li> Arpaci-Dusseau, Remzi H., Arpaci-Dusseau, Andrea C..  <em>Operating Systems: Three Easy Pieces.</em> Arpaci-Dusseau Books. Published August, 2018 (Version 1.00)</li>
    <li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
  </ol>

</div>
