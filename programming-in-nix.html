---
layout: default
title: "Going Further: Programming in *nix"
last-updated: July, 2020
---

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#c"> C </a></li>
        <li><a href="#rust"> Rust </a></li>
        <li><a href="#c-plus-plus"> C++ </a></li>
        <li><a href="#general-cs"> General Computer Science </a></li>
        <li><a href="#closing-remarks"> Closing Remarks </a></li>
        <li><a href="#brian-cantrill"> Brian Cantrill </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
	<h1>Going Further: Programming in *nix</h1>
  <div class="quote-text">
  "Theory and practice sometimes clash. <br>
  And when that happens, theory loses.
  Every single time."
  </div>
  <div class="quote-ref">
    &mdash;<a href="https://lwn.net/Articles/326505/">Linus Torvalds</a>
  </div>

</div>

<div id="c" class="content">
  <h2> C </h2>
  <p>
    C is the <em>lingua franca</em> of
    programming.<sup><a href="https://wiki.osdev.org/Required_Knowledge">[1]</a><a href="#references">[2]</a></sup>
    As such, it would be a mistake to put any other language first.
    For instance, the executable binary file format <em>ELF</em> is defined in C.
    Bash, Zsh, as well as the reference Python interpreter, are written in C.
    Also, the Linux kernel is written in C, and as such, the language
    is the "native tongue" of each system call.
    For example, when querying the kernel about a file through the system
    call <em>stat,</em>
    <a href="https://www.man7.org/linux/man-pages/man2/stat.2.html">a C struct is returned</a>.
  </p>

  <p>
    "C is not a large language," say Brian Kerninghan and Dennis Ritchie<sup><a href="#references">[3]</a></sup>,
    but it is difficult to master.
    It is often called "portable assembly" because it closely
    mirrors the abstractions of the machine itself.
    A central feature of the language, and the principal reason for its
    difficulty, is that C expects the programmer to manually (explicitly)
    address memory, through variables called <em>pointers.</em>
    Moreover, memory is often allocated and deallocated manually (explicitly)
    by the programmer.
    With this combination, there are many possible avenues of failure, including
    syntax errors, dangling pointers, double-free'ing, memory leaks,
    going past the end of an allocated memory segment, and
    the glorious segmentation fault.
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      In Linux, a C compiler is almost always preinstalled.
      Check with <br><center>$ gcc --version</center><br>
    </p>
  </div>

  <p>
    The C Programming Language shows its age in a few ways.
    First, its command-line interface is not unified.
    There is a preprocessor, separate from the compiler; there is also a linker and an assembler.
    While <code>gcc</code> executes each of these for you in a single step,
    it is not as slick an interface as Mozilla Rust's <em>cargo</em> utility,
    which, in addition to the above, also handles packaging and make-ing.
  </p>

  <p>
    Another way that C shows its age is, well, its memory management.
    Each language since has, to my mind, first decreed their own philosophy regarding memory&mdash;
    i.e., "This is how <em>we're</em> going to handle memory."
    Each new philosophy carries its own set of problems.
    Garbage collection is too slow and unpredictable for systems programming,
    and Rust's "zero-cost abstractions" require a nontrivial understanding of
    the language's idea of ownership.
  </p>

  <h3> See Also: </h3>
  <ul>
      <li><a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">The C Programming Language</a> (2<sup>nd</sup> Edition)</li>
      <li><a href="https://www.linuxlinks.com/wp-content/uploads/2019/07/An_Introduction_to_GCC-Brian_Gough.pdf"> An Introduction to GCC </a></li>
  </ul>
</div>

<div id="rust" class="content">
  <h2> Rust </h2>
  <p>
    Rust is the next systems programming language, and the place to be, so-to-speak.
    I think that most, if not all, GNU/Linux code will be rewritten in Rust, but
    that this is going to occur incrementally.
    Just check out some of these projects:
  </p>

  <ul>
    <li><a href="https://github.com/sharkdp/bat">bat</a>&mdash; A drop-in replacement
      for <em>cat</em> that does syntax highlighting and paging (when connected
      to an interactive terminal) </li>
    <li><a href="https://github.com/ClementTsang/bottom">bottom</a>&mdash;
      A replacement for <em>top</em></li>
    <li><a href="https://github.com/alacritty/alacritty">Alacritty</a>&mdash;
      A cross-platform, GPU-accelerated terminal emulator</li>
    <li><a href="https://github.com/rust-unofficial/awesome-rust#audio-and-music">Awesome Rust</a>&mdash;
      A big-ass list of such projects
  </ul>

  <p>
    Rust's command-line utility, <a href="https://doc.rust-lang.org/cargo/">cargo</a>,
    is super-modern, and also incorporates a package manager.
    Libraries available there are unique among systems-programming-language
    libraries because their users are <em>guaranteed</em> (through the rust compiler)
    that software available on it is memory-safe.
  </p>

  <p>
    Rust is not an easy language to learn, but facilitates safe memory usage
    and safe concurrent programming.
  </p>

  <h3>See Also:</h3>
  <ul>
    <li> <a href="https://rustup.rs/"> rustup.rs - The Rust Toolchain Installer </a></li>
  </ul>
</div>

<div id="c-plus-plus" class="content">
  <h2> C++ </h2>
  <p>
    Stay away from C++.
    Originally, this language was called <em>C with Classes,</em> and this name
    reflects an attempt to augment the C language by arbitrarily introducing
    object-oriented programming (via classes).
    The result is a very large, very complicated language.
  </p>

  <p>
    There are two issues with using such a language.
    First, because C is fully supported within C++,
    and C is a complete language, C++ is redundantly complete.
    Anywhere you might use C++, you can instead use C.
    Second, in practice, the tendency is to use only a portion of the full
    language, meaning that handy features go unused, simply because they are
    not known.
  </p>

  <p>
    Moreover, owing to its C heritage, it is <em>unsafe</em> in the sense that
    it, like C, makes no guarantees about the use of memory.
    Consequently, it is easy to build bugs and security vulnerabilities;
    this problem is exacerbated by the complexity of the language.
    Curiously, experienced programmers who switch from C++ to Rust
    liken it to getting out of a bad relationship<sup><a href="https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/">[4]</a><a href="https://youtu.be/HgtRAbE1nBM">[5]</a></sup>
  </p>

  <h3> See Also: </h3>
  <ul>
    <li><a href="http://yosefk.com/c++fqa/index.html"> C++ Frequently Questioned Answers</a> (Critique of C++)</li>
    <li><a href="http://harmful.cat-v.org/software/c++/linus"> Linus Torvalds on C++ </a></li>
    <li><a href="https://en.wikiquote.org/wiki/Ken_Thompson#%22Coders_At_Work%22,_2009"> Ken Thompson on C++</a></li>
    <li><a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition"> EnterpriseQualityCoding</a></li>
  </ul>
</div>

<div class="content" id="general-cs">
    <h2> General Computer Science </h2>
    <p>
      It's worthwhile to draw an outline of computer science, in general.
      A classical undergraduate CS curriculum centers around a few courses:
    </p>

    <ul class="big-list">
      <li>
        <p><strong>Programming Languages</strong>&mdash; Initial courses in Java and C++ are pretty
        typical, but neither language has any business in the open-source ecosystem.
        Advanced studies in programming languages become abstract, discussing and developing
        language theory rather than practice.
        This can be useful in language development and compiler design, for instance.
        </p>

        <p>
          This subject was (effectively) founded by
          Christopher Strachey, in his 38-page <a href="https://github.com/papers-we-love/papers-we-love/blob/master/languages-theory/fundamental-concepts-in-programming-languages.pdf">
          Fundamental Concepts of Programming Languages</a>.
        </p>
      </li>
      <li style="padding-top: 0;">
        <p>
          <strong>Operating Systems</strong>&mdash; A very large topic, it again
          discusses operating systems in the abstract.  A good, if lighthearted,
          development is given by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau in
          their free <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/"> Operating Systems: Three Easy Pieces</a>.
        </p>
      </li>
      <li style="padding-top: 0;">
        <p><strong>Discrete Mathematics</strong>&mdash; At the end of abstraction, there
          is always math, it seems.  Discrete mathematics is not a difficult subject,
          on par with a first semester in calculus.  It will introduce enough
          logic to give informal proofs, and cover advanced counting techniques, among other things.
          Given the inherently discrete nature of the bit, this
          subject founds all of computer
          science.
          The canonical text for computer scientists is
          <a href="https://en.wikipedia.org/wiki/Concrete_Mathematics">Concrete Mathematics</a>,
          but I prefer <a href="http://discrete.openmathbooks.org/dmoi3.html"> Discrete Mathematics - An Open Introduction</a>
        </p>
      </li>
      <li style="padding-top: 0;">
        <p><strong>Data Structures</strong>&mdash;
          After learning a programming language or two,
          data structures are the next most important thing to learn in becoming a developer;
          some understanding of discrete math is a required.
          The typical methodology in writing a program is to
          <em>first select the most appropriate data structure,</em>
          then build the rest of the program around it.
        </p>

        <p>
          <a href="https://opendatastructures.org/"> Open Data Structures </a> is a great book on the subject, the best that I
          personally have found.
          Advanced studies delve further into mathematics, usually focusing on analysis of algorithms.
          The canonical text of that subject is <a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to Algorithms</a>.
        </p>
      </li>
      <li style="padding-top: 0; padding-bottom: 10px;">
        <p><strong>Computer Architecture</strong>&mdash; Ah, computer architecture.  I loved studying this subject,
          but honestly wonder how useful it is.  It looks into the abstractions presented by
          hardware itself, such as signed and unsigned numbers, and instruction set architectures.
          A good development of this
          material is highly mathematical, and correspondingly not-easy.
          I liked <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer's Perspective</a>.
      </li>
    </ul>
</div>

<div class="content" id="closing-remarks">
  <h2>Closing Remarks</h2>
  <p>
    Thanks for reading!
    I'd like to say <em>"Thanks"</em> to a few people.
    While I never met them, they each are heroes of mine:
  </p>

  <ul>
    <li> <a href="https://www.youtube.com/channel/UCrUL8K81R4VBzm-KOYwrcxQ">Engineer Man</a>&mdash; Who got me started with Linux and programming</li>
    <li> Brian Kernigham&mdash; Whose book, <a href="https://www.cs.princeton.edu/~bwk/memoir.html"><em>Unix: A History and Memoir</em></a>,
      grounded the study in concrete history </li>
    <li> Ken Thompson&mdash; And all the other geniuses of Bell Labs who
      laid the foundation of <em>Unix</em></li>
    <li> Linus Torvalds and all kernel developers&mdash; Who made Linux!</li>
  </ul>

  <p>
    Thanks!
  </p>
</div>

<div class="content" id="brian-cantrill">
  <h2>Brian Cantrill: Rust and Other Interesting Things</h2>
  <iframe class="video" src="https://www.youtube.com/embed/2wZ1pCpJUIM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<!--
<div class="content" id="kernel-dev">
  <h2> Kerenel Development </h2>
  <div class="quote-text">
  "So, you want to learn how to become a Linux kernel developer?"
  </div>
  <div class="quote-ref">
    <a href="https://www.kernel.org/doc/html/latest/process/howto.html#introduction">The Linux Kernel Documentation</a>
  </div>


<li><a href="https://www.kernel.org/doc/html/v4.10/process/coding-style.html"> Linux Kernel Coding Style</a> (Written by Linux Torvalds) </li>
</div>

Linux kernel coding style (Linux Torvalds)
https://www.kernel.org/doc/html/v4.10/process/coding-style.html

      HOWTO do Linux kernel development (Official)
      https://www.kernel.org/doc/html/latest/process/howto.html#documentation
<li><a href="https://www.kernel.org/doc/html/latest/process/index.html"> Working with the kernel development community - The Linux Kernel documentation</a> </li>
  -->

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from https://wiki.osdev.org/Required_Knowledge</li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
    </ol>
</div>
