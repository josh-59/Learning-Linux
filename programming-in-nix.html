---
layout: default
title: "Programming in Linux"
last-updated: December, 2020
---


<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#development-environment">Development Environment</a></li>
        <li><a href="#programming-languages">Programming Languagues</a></li>
        <li><a href="#outline-of-cs">Outline of Computer Science</a></li>
        <li><a href="#game-development">Game Development</a></li>
        <li><a href="#application-development">Application Development</a></li>
        <li><a href="#kernel-development">Kernel Development</a></li>
        <li><a href="#closing-remarks">Closing Remarks</a></li>
        <li><a href="#briand-cantrill">Brian Cantrill</a></li>
   </ul>
</div>

<div id="introduction" class="content">
    <h1>Appendix: Programming in Linux</h1>

    <p>
        - Came to the right place!
    </p>
</div>

<div id="development-environment" class="content">
    <h2> Development Environment </h2>

        - C compiler
        - Text editor
        - Build system
            - autoconf + make
        - Git
        - Python 

    <p>
        Setting up your development environment is the first, and hardest,
        step in learning to program.  
    </p>
</div>

<div id="programming-languages" class="content">
    <h2> Programming Languages </h2>

    <p>
        There are a gazillion programming languages.
        Below is an opinionated, redacted and reductive 
        list of the most relevant today, and their respective domains.
    </p>

    <ul>
        <li>
            JavaScript&mdash; Web, general-purpose
        </li>
        <li>
            Python&mdash; General-purpose
        </li>
        <li>
            Shell&mdash; UNIX automation
        </li>
        <li>
            C&mdash; "Lingua franca of computing," 
        </li>
        <li>
            <a href="https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation/">Rust</a>&mdash; Spiritual successor to C++
        </li>
        <li>
            Kotlin&mdash; Android development
        </li>
    </ul>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.hackerrank.com/">HackerRank</a></li>
        <li><a href="https://emkc.org/">Engineer Man Knowledge Center</a></li>
    </ul>
</div>

<div class="content" id="general-cs">
    <h2> General Computer Science </h2>
    <p>
        Computer science is a large field, 
        too large for any one person to totally comprehend.
        Therefore, it's worthwhile to draw an outline of computer science, 
        as the field exists today. 
    </p>

    <p>
        A classical undergraduate CS curriculum centers around a few courses:
    </p>

    <ul class="big-list">
        <li>
            <p>
                <strong>Programming Languages</strong>&mdash; Initial courses in 
                Java and C++ are pretty typical, but neither language has any 
                business in the open-source ecosystem.
                Advanced studies in programming languages become abstract, 
                discussing and developing language theory rather than practice.
                This can be useful in language development and compiler design, 
                for instance.
            </p>
        </li>
        <li style="padding-top: 0;">
            <p><strong>Data Structures</strong>&mdash;
                After learning a programming language or two,
                data structures are the next thing to learn in becoming 
                a developer.
                Some understanding of discrete math is a required.
                To illustrate, the typical methodology in writing a program is to
                <em>first select the most appropriate data structure,</em>
                then build the rest of the program around it.
            </p>

            <p>
                <a href="https://opendatastructures.org/"> Open Data Structures </a> is a great book on the subject, the best that I
                personally have found.
                Advanced studies delve further into mathematics, usually focusing on analysis of algorithms.
                The canonical text of algorithms is <a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to Algorithms</a>.
            </p>
        </li>

        <li style="padding-top: 0;">
            <p>
                <strong>Operating Systems</strong>&mdash; A very large topic, it
                discusses operating systems in the abstract.  
                A good, if lighthearted, development is given by 
                Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau in
                their free <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/"> Operating Systems: Three Easy Pieces</a>.
            </p>
        </li>

        <li style="padding-top: 0; padding-bottom: 10px;">
            <p>
                <strong>Computer Architecture</strong>&mdash; 
                My favorite subject in all of computer science.  
                It looks into the abstractions presented by
                hardware itself, such as signed and unsigned numbers, 
                instruction set architectures, and multi-level caches.
                A good development of this
                material is highly mathematical: 
                <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer's Perspective</a>.
            </p>
        </li>

        <li style="padding-top: 0;">
            <p><strong>Discrete Mathematics</strong>&mdash; 
                At the end of abstraction, there is always math, it seems.
                Discrete mathematics is not a difficult subject,
                on par with a first semester in calculus.  
                It will introduce enough logic to give informal proofs, 
                cover graphs and advanced counting techniques, among other things.
                Given the inherently discrete nature of the bit, this
                subject founds all of computer science.
                The canonical text for computer scientists is
                <a href="https://en.wikipedia.org/wiki/Concrete_Mathematics">Concrete Mathematics</a>,
                but I prefer <a href="http://discrete.openmathbooks.org/dmoi3.html"> Discrete Mathematics - An Open Introduction</a>
            </p>
        </li>
    </ul>
</div>

<div class="content" id="game-development">
    <h2>Game Development</h2>

    <p>
        <a href="">Piston</a>.
    </p>

    <p>
        In the author's opinion, this development model is intrinsic to
        open-source software.  
        Moreover, while it is well-suited to developing stable,
        mature software over long periods of time, 
        it is poorly suited to a significant use-case: Game development.
    </p>

    <p>
        By nature, games are at the forefront of technology.
        Further, they are developed all at once, and are released only once.  
        As a consequence, their development is both time-critical and
        non-reiterative.  
        Both of these characterstics are at odds with the <em>train schedule</em>
        approach.
    </p>

    <p>
        If a solution to this situation exists, then it rests in developing 
        open-source programming tools, and collections of free assets,
        which significantly reduce the time
        required to yield a playable game&mdash; e.g.
        <a href="https://godotengine.org">Godot Game Engine</a>.
    </p>


    <h3>See Also:</h3>
    <ul>
        <li><a href="https://opensource.guide/"> Open Source Guide</a></li>
        <li><a href="https://blog.rust-lang.org/2014/10/30/Stability.html"> Stability as a Deliverable | Rust Blog</a></li>
        <li><a href="http://thinking-in-code.blogspot.com/2010/07/train-model-of-software-development.html"> Thinking in Code: Train Model of Software Development</a></li>
    </ul>
</div>

<div class="content" id="application-development">
    <h2>Application Development</h2>

</div>

<div class="content" id="kernel-development">
    <h2>Kernel Development</h2>

    <p>
        Some collected resources:
    </p>

    <ul>
        <li>
            <a href="http://www.kroah.com/lkn/">The Linux Kernel in a Nutshell</a>&mdash; Written by Greg Kroah-Hartman, this
            walks the reader through building and installing a Linux kernel from source, a requisite step in becoming a kernel developer.
        </li>
        <li>
            Kernel Newbies
        </li>
        <li>
            <a href="https://lkw.readthedocs.io/en/latest/index.html">Linux Kernel Workbook</a>
        </li>
        <li>
            <a href="https://www.kernel.org/doc/html/latest/kbuild/makefiles.html">Linux Kernel Makefiles</a>
        </li>
        <li>
            <a href="https://www.kernel.org/doc/html/latest/process/index.html"> Working with the Kernel Development Community</a>&mdash;
            How to get your changes merged.
        </li>
        <li>
            <a href="https://sourcedigger.io/">SourceDigger.io</a>&mdash; An online symbol browser for the Linux kernel
            and other C projects.
        </li>
    </ul>

    <p>
        Contributing code is, in a sense, the last thing of all.
    </p>
</div>

<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from <a href="https://wiki.osdev.org/Required_Knowledge">https://wiki.osdev.org/Required_Knowledge</a></li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
        <li>Turon, A., &amp; Matsakis, N. (2014, October 30).  Stability as a Deliverable:  Rust Blog.  Retrieved August 18, 2020, from
            <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">https://blog.rust-lang.org/2014/10/30/Stability.html</a></li>
        <li> The Firefox release process. (n.d.). Retrieved August 18, 2020, from <a href="https://wiki.mozilla.org/Release_Management/Release_Process">https://wiki.mozilla.org/Release_Management/Release_Process</a></li>
    </ol>
</div>
