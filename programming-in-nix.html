---
layout: default
title: "Going Further: Programming in *nix"
last-updated: August, 2020
---


<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#getting-started"> Getting Started </a></li>
        <li><a href="#c"> C </a></li>
        <li><a href="#rust"> Rust </a></li>
        <li><a href="#c-plus-plus"> C++ </a></li>
        <li><a href="#general-cs"> General Computer Science </a></li>
        <li><a href="#train-schedules"> Train Schedules </a></li>
        <li><a href="#closing-remarks"> Closing Remarks </a></li>
        <li><a href="#bryan-cantrill"> Bryan Cantrill </a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Going Further: Programming in *nix</h1>
    <div class="quote-text">
        "Theory and practice sometimes clash. <br>
        And when that happens, theory loses.
        Every single time."
    </div>
    <div class="quote-ref">
        &mdash;<a href="https://lwn.net/Articles/326505/">Linus Torvalds</a>
    </div>

    <p>
        An operating system serves as an intermediary between the programmer and the machine;
        it allows one "to drive" the machine, much like a steering wheel allows one to drive a car.
        For its openness and its adherence to the Unix way, there is not a
        better programming environment than Linux.
    </p>
</div>

<div id="getting-started" class="content">
    <h2> Getting Started</h2>

    <p>
        The only way to learn programming is to do it.
        There are several languages that are well-suited to the novice,
        including Python, Ruby and JavaScript.
        These are each object-oriented languages, and none of them are
        "toy" languages.
    </p>

    <p>
        For instance, the Linux Mint update manager, <a href="https://github.com/linuxmint/mintupgrade/blob/master/usr/bin/mintupgrade">Mint Upgrade</a>,
        is written in Python.
        This is an excellent use-case for the language:
        Because it isn't ran very often, it doesn't need to maximize performance.
        In addition, readability of the code is, in this case, very important.
        It could easily be the case that someone other than its original
        author needs to come in and orient themselves quickly.
        In fact, <a href="https://github.com/linuxmint">according to GitHub</a>,
        most of the Linux Mint development team's work is in Python.
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            If you're not sure which of these language to choose, go with
            Python&ndash;
            It even <a href="https://docs.python.org/3/library/stdtypes.html?highlight=set#set-types-set-frozenset">
                has sets</a>!
        </p>
    </div>

    <p>
        Another piece of software that I use a lot is <a href="https://jekyllrb.com/">Jekyll</a>, a
        static site-builder, which is written in Ruby.
        It lets you build websites according to custom templates, and also allows
        you to serve them to yourself locally.
        For what I do, it's very easy to use; it's also the default site-generator
        of Github:  I don't actually upload webpages; rather, I upload files
        describing <em>how the website should to be built according to Jekyll,</em>
        and the Github backend takes care of the rest.
        Admittedly, this might not be the best use-case for Ruby, with
        <a href="https://gohugo.io/">Hugo</a> coming into maturity and its
        being written in a proper systems programming language.
    </p>

    <p>
        And, of course, JavaScript, being the standard scripting language of the web, is used everywhere.
        It <a href="https://youtu.be/mVCbeOYeDww">has been claimed (Youtube video)</a> that
        JavaScript is the inevitable future of programming,
        that everything from toasters to automobiles will be programmed through JavaScript.
        This is owed to its migration from the web, first to the <a href="https://nodejs.org/en/">NodeJS</a> runtime environment,
        which lets you access systems API's from within the language,
        and then on to the <a href="https://www.electronjs.org/">Electron</a> application framework,
        which lets you create desktop applications that are identical across platforms, with the language.
        If you've ever used the <a href="https://atom.io/">Atom</a> text editor, then you've experienced <em>Electron.</em>
    </p>

    <p>
        Outside of reading and writing code,
        several sources exist to aid the newcomer into the wonderful world of programming.
        Books offer in-depth explanations and theoretical background.
        Videos offer lecture-style, if curated, material.
        Open classes cover more ground systematically.
        The best aides, though, are websites that present programming problems,
        and let the student solve them.
        Two of these are listed below.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.hackerrank.com/">HackerRank</a></li>
        <li><a href="https://emkc.org/">Engineer Man Knowledge Center</a></li>
    </ul>
</div>

<div id="c" class="content">
    <h2> C </h2>
    <p>
        C has been called the <em>lingua franca</em> of
        programming,<sup><a href="https://wiki.osdev.org/Required_Knowledge">[1]</a><a href="#references">[2]</a></sup>
        and for good reason.
        Consider some of the projects carried out in C:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            In Linux, a C compiler is almost always preinstalled.
            Check with <br><center><code>$ gcc --version</code></center>
        </p>
    </div>

    <ul>

        <li>
            <a href="https://elinux.org/Executable_and_Linkable_Format_(ELF)">ELF</a>&mdash; The format of the executable binary file in Linux
        </li>

        <li>
            EXT, EXT2, EXT3, EXT4
        </li>

        <li>
            The Linux Kernel
        </li>

        <li>
            Bash, Zsh
        </li>

        <li>
            <a href="https://en.wikipedia.org/wiki/CPython">CPython</a>&mdash; The reference Python interpreter
        </li>
    </ul>

    <p>
        "C is not a large language," say Brian Kerninghan and Dennis Ritchie,<sup><a href="#references">[3]</a></sup>
        but it is difficult to master.
        A central feature of the language, and the principal reason for its
        difficulty, is that C expects the programmer to manually (explicitly)
        address memory, through variables called <em>pointers.</em>
        Moreover, memory is often allocated and deallocated manually (explicitly)
        by the programmer.
        With this combination, there are many possible avenues of failure, including
        dangling pointers, double-free-ing, memory leaks, and running off the end of an array.
    </p>

    <p>
        These, in turn can lead to security vulnerabilities, bugs and crashes.
        For instance, even something as elementary as
        <a href="https://www.man7.org/linux/man-pages/man3/strcpy.3.html">copying a string</a>,
        if left unchecked, introduces the possibility of attack and exploitation.
        Because the compiler does not warn you of these possibilities, it
        is very difficult to write "correct" C.
        Moreover, as Brian Cantrill points out, even when one can write correct C,
        it is difficult to compose the work of multiple developers into a single
        whole (see video below).
    </p>

    <p>
        Nonetheless, C is a great language, and is here to stay; it just shows its
        age a bit.
        C is often called "portable assembly" because it closely
        mirrors the abstractions of the machine itself.
        It has been the standard systems programming language for fifty years.
    </p>

    <h3> See Also: </h3>
    <ul>
        <li><a href="http://s3-us-west-2.amazonaws.com/belllabs-microsite-dritchie/cbook/index.html">The C Programming Language</a> (2<sup>nd</sup> Edition)</li>
        <li><a href="https://www.linuxlinks.com/wp-content/uploads/2019/07/An_Introduction_to_GCC-Brian_Gough.pdf"> An Introduction to GCC </a></li>
    </ul>
</div>

<div id="rust" class="content">
    <h2> Rust </h2>

    <p>
        Rust is the up-and-coming systems programming language, and in my opinion,
        the bee's knees.
        Rust, like C, is a compiled systems-programming language.
        However, it mitigates C's memory management risks by introducing a rigorous type
        system and new ownership rules.
        Together, these allow the Rust compiler to guarantee (prove) the aforementioned
        "correctness" of code.
    </p>

    <p>
        In addition to guarding against many errors, bugs and exploits, this also
        increases the composability of code.
        Of the source code present and available in Rust's package-management repository (<a href="https://crates.io/">crates.io</a>),
        you, the developer, are guaranteed that the code you choose is memory- and
        concurrency-safe (or you will be warned).
    </p>

    <p>
        The cherry on top is Rust's command-line utility, <a href="https://doc.rust-lang.org/cargo/">cargo</a>.
        It is super-modern, super-friendly, <em>and</em> serves as the language's package manager.
        Just check out some of these projects:
    </p>

    <ul>
        <li><a href="https://github.com/sharkdp/bat">bat</a>&mdash; A drop-in replacement
            for <em>cat</em> that does syntax highlighting and paging (when connected
            to an interactive terminal)
        </li>
        <li><a href="https://github.com/alacritty/alacritty">Alacritty</a>&mdash;
            A cross-platform, GPU-accelerated terminal emulator
        </li>
        <li><a href="https://github.com/rust-unofficial/awesome-rust#audio-and-music">Awesome Rust</a>&mdash;
            A big-ass list of such projects
        </li>
    </ul>


    <p>
        Rust is not an easy language to learn, though, so expect to do some studying.
        As with C and C++, it helps to understand
        where and how data is stored on the machine at runtime.
        (This contrasts greatly with interpreted languages like Python or Ruby.)
    </p>

    <p>
        Of the resources available to learn Rust, I found these helpful:
    </p>

    <ul>
        <li><a href="https://www.oreilly.com/library/view/programming-rust/9781491927274/">Programming Rust</a>&mdash;
            Informative and entertaining, this book is written by two experienced
            C++ developers.  Great book.  Not free; second edition expected in 2021.
        </li>
        <li><a href="https://github.com/rust-lang/rustlings">Rustlings</a>&mdash;
            A command-line game that teaches you Rust expressions. You open a text editor
            in a second window, and edit the files so that they compile.
        </li>
        <li><a href="https://github.com/josh-59/cargo-watch">cargo-watch</a>&mdash;
            A simple command-line utility that keeps a Cargo package compiled in real-time.
            Inspired by <em>Rustlings</em>
        </li>
    </ul>

    <img style='width: 90%;' src="assets/img/100rust.png">

    <h3>See Also:</h3>
    <ul>
        <li> <a href="https://rustup.rs/"> Rustup - The Rust Toolchain Installer </a></li>
    </ul>
</div>

<div id="c-plus-plus" class="content">
    <h2> C++ </h2>
    <p>
        I'm just gonna say it: Stay away from C++.
        Originally, this language was called <em>C with Classes,</em> and this name
        reflects an attempt to augment the C language by arbitrarily introducing
        object-oriented programming (via classes).
        The result is a very large, very complicated language.
    </p>

    <p>
        There are two issues with using such a language.
        First, because C is fully supported within C++,
        and C is a complete language, C++ is redundantly complete.
        Anywhere you might use C++, you can instead use C.
        Second, in practice, the tendency is to use only a portion of the full
        language, meaning that handy features go unused, simply because they are
        not known.
    </p>

    <p>
        Moreover, owing to its C heritage, it is <em>unsafe</em> in the sense that
        it, like C, makes no guarantees about the use of memory.
        Consequently, it is easy to build bugs and security vulnerabilities;
        this problem is exacerbated by the complexity of the language.
        Curiously, experienced programmers who have switched from C++ to Rust have
        likened it to getting out of a bad relationship<sup><a href="https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/">[4]</a><a href="https://youtu.be/HgtRAbE1nBM">[5]</a></sup>
    </p>

    <p>
        But hey&mdash; if you want to write C++, don't let me stop you!
        There's plenty of good software written in it:
    </p>

    <ul>
        <li>
            <a href="https://en.wikipedia.org/wiki/KDE_Plasma_5">KDE's Plasma</a>&mdash; Linux's premier desktop environment
        </li>

        <li>
            <a href="https://en.wikipedia.org/wiki/Qt_(software)">QT</a>&mdash; a GUI Backend
        </li>

        <li>
            <a href="https://en.wikipedia.org/wiki/Unreal_Engine">Unreal Engine</a>
        </li>
    </ul>

    <h3> See Also: </h3>
    <ul>
        <li><a href="https://lwn.net/Articles/249460/"> Linus Torvalds on C++ </a></li>
        <li><a href="https://en.wikiquote.org/wiki/Ken_Thompson#%22Coders_At_Work%22,_2009"> Ken Thompson on C++</a></li>
    </ul>
</div>

<div class="content" id="general-cs">
    <h2> General Computer Science </h2>
    <p>
        It's worthwhile to draw an outline of computer science, in general.
        A classical undergraduate CS curriculum centers around a few courses:
    </p>

    <ul class="big-list">
        <li>
            <p>
                <strong>Programming Languages</strong>&mdash; Initial courses in Java and C++ are pretty
                typical, but neither language has any business in the open-source ecosystem.
                Advanced studies in programming languages become abstract, discussing and developing
                language theory rather than practice.
                This can be useful in language development and compiler design, for instance.
            </p>

            <p>
                This subject was (effectively) founded by
                Christopher Strachey, in his 38-page
                <a href="https://github.com/papers-we-love/papers-we-love/blob/master/languages-theory/fundamental-concepts-in-programming-languages.pdf">
                    Fundamental Concepts of Programming Languages.
                </a>
            </p>
        </li>
        <li style="padding-top: 0;">
            <p>
                <strong>Operating Systems</strong>&mdash; A very large topic, it again
                discusses operating systems in the abstract.  A good, if lighthearted,
                development is given by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau in
                their free <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/"> Operating Systems: Three Easy Pieces</a>.
            </p>
        </li>
        <li style="padding-top: 0;">
            <p><strong>Discrete Mathematics</strong>&mdash; At the end of abstraction, there
                is always math, it seems.  Discrete mathematics is not a difficult subject,
                on par with a first semester in calculus.  It will introduce enough
                logic to give informal proofs, cover graphs and advanced counting techniques, among other things.
                Given the inherently discrete nature of the bit, this
                subject founds all of computer science.
                The canonical text for computer scientists is
                <a href="https://en.wikipedia.org/wiki/Concrete_Mathematics">Concrete Mathematics</a>,
                but I prefer <a href="http://discrete.openmathbooks.org/dmoi3.html"> Discrete Mathematics - An Open Introduction</a>
            </p>
        </li>
        <li style="padding-top: 0;">
            <p><strong>Data Structures</strong>&mdash;
                After learning a programming language or two,
                data structures are the next thing to learn in becoming a developer&mdash;
                some understanding of discrete math is a required.
                To illustrate, the typical methodology in writing a program is to
                <em>first select the most appropriate data structure,</em>
                then build the rest of the program around it.
            </p>

            <p>
                <a href="https://opendatastructures.org/"> Open Data Structures </a> is a great book on the subject, the best that I
                personally have found.
                Advanced studies delve further into mathematics, usually focusing on analysis of algorithms.
                The canonical text of algorithms is <a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to Algorithms</a>.
            </p>
        </li>
        <li style="padding-top: 0; padding-bottom: 10px;">
            <p>
                <strong>Computer Architecture</strong>&mdash; Ah, computer architecture.  I loved studying this subject,
                but honestly wonder how useful it is.  It looks into the abstractions presented by
                hardware itself, such as signed and unsigned numbers, and instruction set architectures.
                A good development of this
                material is highly mathematical, and correspondingly not-easy.
                I liked <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer's Perspective</a>.
            </p>
        </li>
    </ul>
</div>

<div class="content" id="train-schedules">
    <h2 style="margin-bottom: 2pt;"> Train Schedules </h2>
    <h4>How Open Source Works</h4>

    <p>
        Software development is fundamentally reiterative:
        You build something, publish it, improve it, then re-release it.
        "Train scheduling" formalizes this by placing the cycle on a schedule.
        This approach is widely used to provide
        "stability without stagnation."<sup><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">[6]</a></sup>
        We will use Firefox as a case study, but note that, for instance,
        the Linux kernel development uses a similar approach.
    </p>


    <figure>
        <img src="assets/img/train-schedules.png" style="width: 100%;">
    </figure>

    <p>
        A new Firefox version is scheduled for release every four weeks.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[7]</a></sup>
        That is, each version spends four weeks in the <em>Mature</em> category,
        being the officially-supported, current version of Firefox.
        When here, no new features are implemented&mdash; rather, only security patches, bug-fixes, etc.
        are implemented and pushed to the user.
        After its four weeks in the spotlight, it is discarded, for the next version is ready.
    </p>

    <p>
        Before it becomes mature, each version of Firefox has been released as a <a href="https://www.mozilla.org/en-US/firefox/80.0beta/releasenotes/">beta</a>,
        corresponding to the <em>Initial Release</em> above.
        When a release enters the <em>Beta</em> stage, only patches aimed at improving
        stability are accepted.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[6]</a></sup>
        Finally, there is the <a href="https://www.mozilla.org/en-US/firefox/80.0a1/releasenotes/">Nightly</a> build,
        which contains the latest (and most untested) features.
    </p>

    <p>
        Here we see that <em>Firefox 80</em> will be released as <em>Firefox 81</em>
        enters Beta and <em>Firefox 82</em> enters Nightly:
    </p>

    <figure>
        <a href="https://wiki.mozilla.org/Release_Management/Calendar">
            <img src="assets/img/firefox-train-schedule.png" style="width: 90%; padding-bottom: 10pt;">
        </a>
        <figcaption><center><b><a href="https://wiki.mozilla.org/Release_Management/Calendar">Firefox Release Schedule</a></b></center></figcaption>
    </figure>

    <p>
        As a rule, only opt for pre-release versions of software
        if you are willing to submit bug-reports.
    </p>

    <p>
        In addition to the mainline releases, Mozilla also supports two others:
        <a href="https://www.mozilla.org/en-US/firefox/developer/">Developer Edition</a>,
        which incorporates tools useful for building web pages;
        and, <a href="https://www.mozilla.org/en-US/firefox/enterprise/">Extended Support Release</a>,
        which is upgraded every 42 weeks, and intended for deployment in
        enterprise settings.
        These also, I believe, follow a train schedule.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://opensource.guide/"> Open Source Guide</a></li>
        <li><a href="https://blog.rust-lang.org/2014/10/30/Stability.html"> Stability as a Deliverable | Rust Blog</a></li>
        <li><a href="http://thinking-in-code.blogspot.com/2010/07/train-model-of-software-development.html"> Thinking in Code: Train Model of Software Development</a></li>
    </ul>

</div>

<!--

<div class="content" id="kernel-development">
    <h2>Kernel Development</h2>

    <p>
        Again, I'm not a kernel developer.
        But, here are some collected resources:
    </p>

    <ul>
        <li>
            <a href="https://www.kernel.org/doc/html/latest/process/index.html"> Working with the Kernel Development Community</a>&mdash;
            How to get your changes merged.
        </li>
        <li>
            <a href="http://www.kroah.com/lkn/">The Linux Kernel in a Nutshell</a>&mdash; Written by Greg Kroah-Hartman, this
            walks the reader through building and installing a Linux kernel from source, a requisite step in becoming a kernel developer.
        </li>
        <li>
            <a href="https://sourcedigger.io/">SourceDigger.io</a>&mdash; An online symbol browser for the Linux kernel
            and other C projects.
        </li>
    </ul>
</div>

-->

<div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>
    <p>
        Thanks for reading!
        I'd like to say <em>"Thanks"</em> to a few other people, as well.
        While I never met them, they each are heroes of mine:
    </p>

    <ul>
        <li>
            <a href="https://www.youtube.com/channel/UCrUL8K81R4VBzm-KOYwrcxQ">Engineer Man</a>&mdash;
            Who got me started with Linux and programming
        </li>
        <li>
            Brian Kernigham&mdash;
            Whose book, <a href="https://www.cs.princeton.edu/~bwk/memoir.html"><em>Unix: A History and Memoir</em></a>,
            grounded this study in concrete history
        </li>

        <li>
            Ken Thompson&mdash; And all the other geniuses of Bell Labs who
            laid the foundation of <em>Unix</em>
        </li>

        <li>
            Linus Torvalds and all kernel developers&mdash; Who made Linux!
        </li>

    </ul>

    <p>
        Thanks!
    </p>
</div>

<div class="content" id="bryan-cantrill">
    <h2>Bryan Cantrill: Rust and Other Interesting Things</h2>
    <iframe class="video" src="https://www.youtube.com/embed/2wZ1pCpJUIM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from <a href="https://wiki.osdev.org/Required_Knowledge">https://wiki.osdev.org/Required_Knowledge</a></li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
        <li>Turon, A., &amp; Matsakis, N. (2014, October 30).  Stability as a Deliverable:  Rust Blog.  Retrieved August 18, 2020, from
            <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">https://blog.rust-lang.org/2014/10/30/Stability.html</a></li>
        <li> The Firefox release process. (n.d.). Retrieved August 18, 2020, from <a href="https://wiki.mozilla.org/Release_Management/Release_Process">https://wiki.mozilla.org/Release_Management/Release_Process</a></li>
    </ol>
</div>
