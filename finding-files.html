---
layout: default
title: Finding Files
---

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#basename"> Pathnames and Basenames </a></li>
        <li><a href="#locate"> Locate </a></li>
        <li><a href="#find"> Find </a></li>
        <li><a href="#grep"> Grep </a></li>
        <li><a href="#engineer-man"> Engineer Man </a></li>
        <li><a href="#references"> References </a></li>
        <li><a href="#credits">Credits and Licenses</a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>A Primer on Finding Files</h1>
    <h4>An Example-Driven Expose</h4>

    <p>
        Finding files is a very common operation in Linux, and the tools
        available are very powerful, but not new-user friendly.
        We will cover GNU's <code>locate</code>, <code>find</code>, and <code>grep</code>
        utilities.
    </p>

</div>

<div id="basename" class="content">
    <h2> Pathnames and Basenames</h2>
    <p>
        To start, we must make a clear distinction between a file's
        <em>pathname</em> and a file's <em>basename</em>, because
        our search tools will often make a distinction between these two:
    </p>

    <center><img src="./assets/img/pathname-basename.png"></center>

    <p>
        Every file in the system has a pathname, which begins at root.
        This is also known as an <em>absolute filename</em>.
        Each pathname denotes a unique point in the directory tree.
        In Unix-like systems, a single file can have more than one pathname.
    </p>

    <p> The command <code>readlink</code> can report to us the pathname of an
        arbitrary file:

        <div class="code">
            $ cd /home/josh<br>
            $ readlink -f bin<br>
            /home/josh/documents
        </div>
    </p>

    <p>
        Every file in the system also has a basename.
        The command <code> basename</code> isolates this name for us:
        <div class="code">
            $ basename /home/josh/studies/merge.c<br>
            merge.c
        </div>
    </p>

    <p>
        Now, on to finding files!
    </p>
</div>

<div id="locate" class="content">
    <h2> Locate </h2>
    <p>
        Starting out, your best bet is the <code>locate</code> command.
        <code> locate</code> finds files by name.<sup><a href="http://www.man7.org/linux/man-pages/man1/locate.1.html">[1]</a></sup>
        By default, <code>locate</code> matches your pattern against the pathname of each file;
        it's rather inclusive in the sense that it matches-by-default.
        If it does match, then the file's pathname is printed on a new line.
        Now, this command references a database of information about the files
        on the system.
        As such, it is very fast. However, if you have done some operation on the filesystem and
        the files you are looking for are new, then you must update this
        database:
    </p>

    <div class="code">
        $ sudo updatedb
    </div>

    <p>
        By default, <code>locate</code> is fairly permissive, matching things that
        you wouldn't want matched.
        For instance,
    </p>

    <div class=aside-right>
        <h4>Aside</h4>
        It is often the case that commands written to the command-line are built up
        by trial and error, rather than written all at once.
        A nice pro-tip is to use the "echo" command to view exactly what a line will
        expand to, before executing it.
    </div>

    <div class="code">
        $ locate bin
    </div>

    <p>

        prints all files currently in the database whose pathname includes
        the string "bin".
        If we wanted to find all directories in the system named <code>bin</code>,
        then this is not what we want.
        On this system, we matched 56677 files.
        For instance,
    </p>

    <div class="code">
        /var/lib/dpkg/info/texlive-<strong>bin</strong>aries.postinst
    </div>

    <p>
        matches, as do
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/<strong>bin</strong>
    </div>

    <p>
        and
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/<strong>bin</strong>/rdoc
    </div>

    <p>
        The first thing we can do to narrow this list down is specify that
        <code>locate</code> match against the basename alone, rather than
        the full pathname.
        This is done with either <code> -b </code> or <code> --basename</code>:
    </p>

    <div class="code">
        $ locate --basename bin
    </div>

    <p>
        This reduces the number of matches by half, but still matches such things as
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/gems/sassc-2.3.0/ext/libsass/src/<strong>bin</strong>d.hpp
    </div>

    <p>
        Our final modification to this command will be to match with an expression
        that can specify the beginning of the line as well as the end of the line:
    </p>

    <div class="code">
        $ locate --basename --regex ^bin$
    </div>

    <p>
        This gives the desired result; an introduction to regex is given in a video below.
    </p>

    <p>
        The <code>locate</code> command is limited to searching the entire directory
        tree of the current system.  We could work around this, though, in two ways.
        Suppose we wish to find all files named <code>bin</code> in my home directory,
        <code>/home/josh/</code>.
    </p>

    <p>
        First, we could pipe each line through <code>grep</code>:
    </p>

    <div id="example" class="code">
        $ locate --basename --regex ^bin$ | grep '/home/josh/'
    </div>

    <p>
        Each file in the database that has basename of exactly <code>bin</code> is printed; each line
        is then sent through <code>grep</code>, which will print the line only if it matches
        <code>/home/josh/</code> as well.
    </p>

    <p>
        Second, we could specify a suitable regex expression against the entire pathname:
    </p>

    <div class="code">
        $ locate --regex ^/home/josh.*/bin$
    </div>

    <p>
        Where <code>.*</code> matches any-character (the period) zero-or-more-times (the asterisk).
    </p>

    <p>
        In addition, <code>locate</code> is restricted to querying the name of
        each file, so that if we wish to find all <em>executable</em> files,
        for instance, we must look elsewhere.
    </p>

</div>

<div id="find" class="content">

    <h2> Find </h2>
    <p>
        GNU's <code>find</code> utility is much more powerful.
        It searches the directory tree itself, and allows the user
        to query attributes of each file besides its name.
    </p>

    <p>
        The <code>find</code> utility works by beginning at the starting point(s)
        specified, and comparing each file it finds there against a sequence of tests,
        specified by you, the user.
        Then it descends, and repeats.
        If no starting point is specified, then <code>.</code> is implied.
    </p>

    <div class="code">
        find [starting-point...] [expression...]
    </div>

    <p>
        <code>[expression...]</code> may contain options, tests, or actions.
        Options affect global behavior, such as "descend n levels from starting point."
        Each file that <code>find</code> encounters is evaluated against the tests provided;
        if no tests are specified, then each file passes.
        If a file passes all tests given, then <code>find</code> will carry out the action(s) specified by the user;
        if no action is specified, then -print is implied.
    </p>

    <p>
        For instance, we can count all files on the system by,
    </p>

    <div class="code">
        $ sudo find / | wc -l
    </div>

    <p>
        We find 4.1 million files.
        We require superuser privileges to carry out the above task because
        some directories are not searchable by ordinary users (this is determined
        by the "search bit", which is the executable bit of a directory).
    </p>

    <p>
        <code>find</code> supports many tests. For instance, to find all
        files of size less-than 4 kilobytes, we could run,
    </p>

    <div class="code">
        $ sudo find / -size -4k | wc -l<br>
        2746999
    </div>

    <p>
        Each query is interpreted <em>as a sequence of logical tests</em>.
        Only when a file passes all of the tests is an action carried out.
        For instance, to count all executable files with size less than 4 kilobytes, we might,
    </p>

    <div class="code">
        $ sudo find / -size -4k -executable | wc -l
    </div>

    <p>
        Note that this includes searchable directories!
        To narrow our count down to programs, we must also specify that each file be of "regular" type:
    </p>

    <div class="code">
        $ sudo find / -size 4k -executable -type f | wc -l
    </div>

    <p>
        The default logical operator between tests is <code>-and</code>,
        but <code>-or</code> and <code>-not</code> are also supported, along
        with parenthesis to allow grouping.
        The most common among the tests is <code>-name</code>,
        which matches the given shell globbing pattern against each file's basename.
        In contrast to <code>locate</code>'s inclusive pattern-matching,
        <code>find</code>'s pattern matching is exclusive;
        <code>find</code> also supports <code>-regex</code>.
    </p>

    <p>
        To find all files on the system named "bin" on the system, we could execute,
    </p>

    <div class="code">
        $ sudo find / -name bin
    </div>

    <p>
        Note that this is equivalent to <code>--regex ^bin$</code>, as given above.
        To restrict the search to directories alone, we add an appropriate test:
    </p>

    <div class="code">
        $ sudo find / -name bin -type d
    </div>

    <p>
        To restrict the search to files in my home directory, we could carry out,
    </p>

    <div class="code">
        $ cd /home/josh<br>
        $ find -name bin -type d
    </div>

    <p>
        and rely on the defaults.
        Note that this does not require superuser privileges, because I own
        all the files in this directory.
        To learn yet more about <code>find</code>, I recommend
        <a href="https://www.gnu.org/software/findutils/manual/find.html"> GNU Findutils Official Documentation</a>.
    </p>
    </div>

    <div id="grep" class="content">
        <h2>Grep</h2>

        <p>
            I'm pretty sure that <code>find</code> will let you test against
            any possible system-level attribute that a file may have.
            To go any deeper, we must look inside each file, and that is what
            <code>grep</code> will allow us to do.
        </p>

        <p>
            By default, <code>grep</code> is simple enough:  It reads a file,
            and if a line in the file matches a given pattern, it prints the line.<sup><a href="http://www.man7.org/linux/man-pages/man1/grep.1.html">[2]</a></sup>
            If no files are given, then standard-in is assumed; we used this
            in <a href="#example">an example above</a>.
            Grep's synopsis is,
        </p>

        <div class="code">
            grep [OPTION...] PATTERNS [FILE...]
        </div>

        <p>
            Of note, each <code>PATTERN</code> is regex by default, and
            must either terminate with a newline, or else be explicitly specified by
            using the <code>-e</code> option, as in,
        </p>

        <div class="code">
            $ grep -e "hello" -e "world" file1.c file2.c
        </div>

        <p>
            Will print each line in files <code>file1.c</code> or <code>file2.c</code>
            which match either <em>hello</em> or <em>world</em> or both.
        </p>

        <p>
            Of <code>grep's</code> options, we are particularly interested in
            <code>-l</code> (list), <code>-C</code> (context), and <code>-r</code> (recurse).
            The <code>-r</code> option specifies that, if a file is a directory,
            recursively descend into it (and continue searching).
            So,
        </p>

        <div class="code">
            $ grep . -r -e "hello" -e "world"
        </div>

        <p>
            will print all lines matching either <em>hello</em> or <em>world</em>,
            starting at the current directory, and working downwards.
            But, rather than the line, we might be interested in the context within
            which that expression is found.  In that case,
        </p>

        <div class="code">
            $ grep . -r -C 5 -e "hello" -e "world"
        </div>

        <p>
            This will print five lines before, as well as five lines after, each match.
            Finally, to print out just the name of the file, we specify that
            <code>grep</code> list the match, with <code>-l</code>:
        </p>

        <div class="code">
            $ grep . -rl -e "hello" -e "world"
        </div>
    </div>

    <div id="engineer-man" class="content">
        <h2> Engineer Man </h2>

        <iframe class="video" src="https://www.youtube.com/embed/bgBWp9EIlMM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    </div>

    <div id="references" class="content">
        <h2> References </h2>
        <ol>
            <li><code><a href="http://www.man7.org/linux/man-pages/man1/locate.1.html"> man 1 locate</a></code></li>
            <li><code><a href="http://www.man7.org/linux/man-pages/man1/grep.1.html">man 1 grep</a></code></li>
            <li><a href="https://www.gnu.org/software/findutils/manual/find.html"> GNU Findutils Official Documentation</a></li>
            <li><code><a href="http://man7.org/linux/man-pages/man7/regex.7.html"> man 7 regex </a></code></li>
        </ol>

    </div>
