---
layout: default
title: Finding Files
last-updated: July, 2020
---

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#basename"> Pathnames and Basenames </a></li>
        <li><a href="#locate"> Locate </a></li>
        <li><a href="#find"> Find </a></li>
        <li><a href="#regex"> Regex </a></li>
        <li><a href="#grep"> Grep </a></li>
        <li><a href="#engineer-man"> Engineer Man</a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>Finding Files</h1>
    <div class="quote-text">
        "...though the advantages are obvious in hindsight, <br>
        heirarchical file systems were not widely available before Multics and then Unix."
    </div>

    <div class="quote-ref">
        &mdash;Brian Kernighan,<br>
        <u>UNIX: A History and a Memoir</u>
    </div>

    <p>
        Finding files is a very common operation in Linux, and the tools
        available are powerful, but not very new-user friendly.
        This paper will introduce the subject and some file-finding utilities.
    </p>
</div>

<div id="basename" class="content">
    <h2> Pathnames and Basenames</h2>
    <p>
        To start, we must make a clear distinction between a file's
        <em>pathname</em> and its <em>basename</em>, because
        our search tools will often make a distinction between these two.
    </p>

    <center>
        <img style="width: 70%;" src="./assets/img/pathname-basename.png">
    </center>

    <p>
        Every file in the system has a <em>basename,</em>
        which is, informally, just its name.
        The command <code>basename</code> isolates this name for us:
    </p>

    <div class="code">
        $ basename /home/josh/bin<br>
        bin
    </div>

    <p>
        A <em>pathname</em> prepends a file's basename with its
        parent directories, separating elements with forward slashes,
        <code>/</code>.
        Each of the following are pathnames of the above file:
    </p>

    <div class="code">
        /home/josh/bin <br>
        home/josh/bin <br>
        josh/bin
    </div>

    <p>
        Pathnames are usually used in a relative context.
        For example, if our current working directory is <code>/home</code>,
        then the relative pathname to the above file is,
    </p>

    <div class="code">
        josh/bin
    </div>

    <p>
        or equally,
    </p>

    <div class="code">
        ./josh/bin
    </div>

    <p>
        where the leading <code>./</code> explicitly specifies
        the current working directory.
    </p>

    <p>
        An <em>absolute pathname</em> is a pathname that begins with root,
        <code>/</code>.
        While each absolute pathname denotes a unique point in the directory tree,
        it is not the case that an absolute pathname of a file is unique, because
        the basename
        <a href="files-and-filesystems.html#directories">may be one of many names of the same file.</a>
        The command <code>readlink</code> can report to us the absolute
        pathname of an arbitrary basename:
    </p>

    <div class="code">
        $ cd /home/josh<br>
        $ readlink -f bin<br>
        /home/josh/bin
    </div>


    <p>
        Now, on to finding files!
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><code><a href="https://man7.org/linux/man-pages/man7/path_resolution.7.html">path_resolution(7)</a></code>&ndash; How the kernel resolves pathnames</li>
    </ul>
</div>

<div id="locate" class="content">
    <h2> Locate </h2>
    <p>
        Starting out, your best bet is the <code>locate</code> command:
	</p>

	<div class="code">
		$ locate <em>pattern</em>
	</div>

    <p>
        By default, <code>locate</code> matches <em>*pattern*</em> against the pathname of each file,
        using <a href="command-line-tutorial-introduction.html#globbing">shell globbing</a> to interpret the asterisks.
        In words,
    </p>

    <div class="code">
        $ locate <em>pattern</em>
    </div>

    <p>
        says, "Print out all absolute filenames containing the string <em>pattern</em>."
	</p>

    <p>
        For instance,
    </p>

    <div class="code">
        $ locate bin
    </div>

    <p>
        prints all files whose pathname includes
        the string "bin", so that
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/<mark>bin</mark>
    </div>

    <p>
        will be printed, as will
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/<mark>bin</mark>/rdoc
    </div>

    <p>
        in addition to,
    </p>

    <div class="code">
        /var/lib/dpkg/info/texlive-<mark>bin</mark>aries.postinst.
    </div>

    <p>
      Locate matches hidden files, and files in hidden directories, as well.
    </p>

	  <p>
  	  A minor detail:
  	  <em>locate</em> and its variants reference a database of information
      about files on the system, and not the directories themselves.
      The "database" is literally just a file containing filenames (see below).
      This makes it much faster for ordinary searches,
      but if you're looking for new files, then you must update this database with:
    </p>

    <div class="code">
        $ sudo updatedb
    </div>

    <p>
        Upon installation of the findutils package, the above command
        is executed for you daily.
    </p>

    <h3>See Also:</h3>
    <ul>
      <li><a href="https://jvns.ca/blog/2015/03/05/how-the-locate-command-works-and-lets-rewrite-it-in-one-minute/"> How the locate command works and let's write a faster version in one minute!</a> (Shoutout to <a href="https://wiki.archlinux.org/index.php/Mlocate">ArchWiki</a> for this link!)</li>
    </ul>

</div>

<div id="find" class="content">

    <h2> Find </h2>
    <p>
        The <code>locate</code> series of commands restricts itself to finding
        files based upon (absolute) pathname alone.
        To search with greater precision, we turn to programs which
        traverse the directory tree itself.
        These we will call <em>find</em> commands.
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>

        <p>
            <code>find</code> dates to the first edition of Unix.<sup><a href="http://man.cat-v.org/unix-1st/1/find">[000]</a></sup>
            The 1970's were <a href="http://man.cat-v.org/unix-1st/1/">simpler times</a>.
        </p>
    </div>

    <p>
        By recursively traversing the directory tree, these programs
        can query the system about each file on a case-by-case basis.
        Thus, they can ask about file size, file-type, etc..
        The most popular such utility is GNU's <code>find</code>, which is
        commonly included in Linux distributions.
    </p>

    <p>
        The essential format of a call to <code>find</code> is,
    </p>

    <div class="code">
        $ find [starting points...] [expression]
    </div>

    <p>
        If no starting points are given, then <code>.</code> is assumed.<sup><a href="https://www.man7.org/linux/man-pages/man1/find.1.html">[1]</a></sup>
        <em>Expression</em> is a sequence of tests to be performed on files
        and/or actions to be carried out.
        The default action is <em>print.</em>
        Every element in <em>expression</em> resolves to either true or false;
        <em>print</em> resolves to true.
        For each file, <em>expression</em> is evaluated left-to-right, with
        the default <em>print</em> occurring, conceptually, as the rightmost element.
        Finally, GNU <code>find</code> supports logical operators between subexpressions.
        If an operator is missing between two subexpressions, <code>-and</code>
        is substituted; note the single hyphen.
    </p>

    <p>
        Clearly, <code>find</code> is a powerful utility, but best reserved for scripts, I think.
        We'll take two examples, then introduce a more user-friendly variant.
    </p>

    <p>
        For example, to print the names of all executable files smaller than
        4k, we can use,
    </p>

    <div class="code">
        $ find / -size -4k -executable<br>
    </div>

    <p>
        Or, to print the names of all files in our home directory ending in <code>.py</code>,
    </p>

    <div class="code">
        $ cd <br>
        $ find -name '*.py'
    </div>

    <h3><b>fd</b></h3>

    <p>
        A more modern variant of <em>find</em> is <code><a href="https://github.com/sharkdp/fd">fd</a></code>.
        Compared to GNU's <code>find</code>, <code>fd</code>
        is intended to be faster and more user-friendly.
        For day-to-day use, I recommend it.
    </p>

    <div class="aside-right">
        <h4>Pro Tip:</h4>
        <p>
            For concise help, avoid the man pages.  Instead use,

            <br>
        <code>
            $ find --help
        </code>
        <br>
        &emsp;&emsp;--or--
        <br>
        <code>
            $ fd -h
        </code>
                </p>
    </div>

    <p>
        On Debian-based systems, we can install it with,
    </p>

    <div class="code">
        $ sudo apt install fd-find
    </div>

    <p>
        On Debian distributions, the executable is named <code>fdfind</code>.
        The essential format of a call to <code>fd</code> is
    </p>

    <div class="code">
        $ fd [FLAGS/OPTIONS] [&lt;pattern&gt;] [&lt;path&gt;...]
    </div>

    <p>
        For a concise tutorial introduction to <code>fd</code>,
        have a look at <a href="https://github.com/sharkdp/fd#tutorial">its creator's own documentation</a>.
    </p>

    <!--
    <p>
        Some examples:
        For instance, we can count all files on the system by,
    </p>

    <div class="code">
        $ sudo find / | wc -l
    </div>

    <p>
        We find 4.1 million files.
    </p>

    <p>
        <code>find</code> supports many tests.
		For instance, to find all
        files of size less-than 4 kilobytes, we could run,
    </p>

	<div class="aside-right">
		<h4>Aside</h4>
		<p>
	        We require superuser privileges to carry out this search because
	        some directories are not searchable by ordinary users.  This
			is determined by the "search bit", which is the "executable" bit of a directory).
		</p>
	</div>

    <div class="code">
        $ sudo find / -size -4k | wc -l<br>
        2746999
    </div>

    <p>
		where <code>-4k</code> means "less than 4 kilobytes."
        Further, to count all executable files with size less than 4 kilobytes, we might,
    </p>

    <div class="code">
        $ sudo find / -size -4k -executable | wc -l
    </div>

    <p>
        This reads as, "Beginning at the root directory, print the pathname of each
        file that is both less than four kilobytes in size and is executable; then, count the lines."
        Files that will "match" are those that are both less than 4 kilobytes in size, and
        whose executable bit is set.  Note that this  includes searchable directories!
        To narrow our count down to programs, we must also specify that each file be of "regular" type:
    </p>

    <div class="code">
        $ sudo find / -size 4k -executable -type f | wc -l
    </div>

    <p>
        It's very important to think of each query as a sequence of logical tests, because that is how
        <code>find</code> thinks of it:
        The default logical operator between tests is <code>-and</code>, and
		the tests are evaluated left-to-right.
		The operators <code>-or</code> and <code>-not</code> are also supported, along
        with parenthesis to allow grouping, but we won't touch on those.
    </p>

	<p>
		<code>find</code> is a very complicated and powerful program.  It has 17
		actions that it can perform on each file, and even offers
		debugging facilities! This discussion is restricted to printing each
		filename and reducing the number of files printed by repeatedly using
		the implied <code>-and</code> operator.
	</p>

        <p>
            To find all files on the system named "bin" on the system, we could execute,
        </p>

        <div class="code">
            $ sudo find / -name bin
        </div>

		<p>
            To restrict the search to directories alone, we add an appropriate test:
        </p>

        <div class="code">
            $ sudo find / -name bin -type d
        </div>

        <p>
            To restrict the search to files in my home directory, we could carry out,
        </p>

		<div class="code">
			$ find ~ -name bin -type d
		</div>

		<p>
			or
		</p>

        <div class="code">
            $ cd <br>
            $ find -name bin -type d
        </div>

        <p>
            and rely on the defaults.
            To learn yet more about finding files, see
			<a href="http://man7.org/linux/man-pages/man1/find.1.html"><code>man 1 find</code></a> or
            <a href="https://www.gnu.org/software/findutils/manual/find.html"> GNU Findutils Official Documentation</a>.
        </p>
    -->
    </div>

    <div id="regex" class="content">
      <h2> Regex </h2>

    </div>

    <div id="grep" class="content">
        <h2>Egrep</h2>

        <p>
            I'm pretty sure that <code>find</code> will let you test against
            any possible system-level attribute that a file may have.
            To go any deeper, we must look inside each file, and that is what
            <code>egrep</code> will allow us to do.
        </p>

        <div class="code">
            egrep [OPTION...] PATTERNS [FILE...]
        </div>

        <p>
            By default, <code>egrep</code> is simple enough:  It reads each <code>FILE</code>,
            and if a line matches one of <code>PATTERNS</code>, it prints the line.<sup><a href="http://www.man7.org/linux/man-pages/man1/grep.1.html">[3]</a></sup>
			If there's more than one <code>FILE</code>, <code>grep</code> will
			tell you that as well.
			If no <code>FILE</code> is given, then <code>grep</code> filters standard-in.
		</p>

        <p>
            Of note, each <code>PATTERN</code> is regex by default, and
            must either terminate with a newline, or else be explicitly specified by
            using the <code>-e</code> option, as in,
        </p>

        <div class="code">
            $ grep -e hello -e world file1.c file2.c
        </div>

        <p>
            This will print each line in files <code>file1.c</code> or <code>file2.c</code>
            which match either <em>hello</em> or <em>world</em> or both.
        </p>

        <p>
            Of <code>grep's</code> options, we are particularly interested in
            <code>-l</code> "list", <code>-C</code> "context", and <code>-r</code> "recurse".
            The <code>-r</code> option specifies that, if a file is a directory,
            recursively descend into it, and search all files in it.
            So,
        </p>

        <div class="code">
            $ grep . -r -e hello -e world
        </div>

        <p>
            will print all lines matching either <em>hello</em> or <em>world</em>
            found in any of the files of the current directory, downwards.
			This can be handy for, for instance, locating all C source files that
			make use of some macro:
		</p>

		<div class="code">
			$ grep . -r -e "MACRO"
		</div>

		<p>
			We can also print the context within which a matched line occurs:
        </p>

        <div class="code">
            $ grep . -r -C 3 -e "MACRO"
        </div>

        <p>
            This will print three lines before, as well as five lines after, each match.
            Finally, to print out just the name of the file, we specify that
            <code>grep</code> list the match, with <code>-l</code>.  This
			could be used to locate the file that defines the macro:
        </p>

        <div class="code">
            $ grep . -rl -e "#define +MACRO"
        </div>

	<h3>See Also:</h3>
		<ul>
			<li><a href="https://github.com/ziishaned/learn-regex">Learn Regex The Easy Way</a></li>
			<li><a href="https://www.youtube.com/watch?v=bgBWp9EIlMM&">Regular Expressions - Enough to be Dangerous</a> (Youtube Video by Engineer Man)</li>
		</ul>

	</div>

    <div id="engineer-man" class="content">
        <h2> Engineer Man </h2>

        <iframe class="video" src="https://www.youtube.com/embed/bgBWp9EIlMM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


    </div>

    <div id="references" class="content">
        <h2> References </h2>
        <ol>
            <li><code><a href="http://www.man7.org/linux/man-pages/man1/locate.1.html"> man 1 locate</a></code></li>
			      <li><code><a href="http://man7.org/linux/man-pages/man1/find.1.html">man 1 find</a></code></li>
            <li><code><a href="http://www.man7.org/linux/man-pages/man1/grep.1.html">man 1 grep</a></code></li>
            <li><a href="https://www.gnu.org/software/findutils/manual/find.html"> GNU Findutils Official Documentation</a></li>
            <li><code><a href="http://man7.org/linux/man-pages/man7/regex.7.html"> man 7 regex </a></code></li>
        </ol>

    </div>
