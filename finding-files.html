---
layout: default
title: Finding Files
---

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#basename"> Pathnames and Basenames </a></li>
        <li><a href="#locate"> Locate </a></li>
        <li><a href="#find"> Find </a></li>
        <li><a href="#grep"> Grep </a></li>
        <li><a href="#engineer-man"> Engineer Man </a></li>
        <li><a href="#references"> References </a></li>
        <li><a href="#credits">Credits and Licenses</a></li>
    </ul>
</div>

<div id="introduction" class="content">
    <h1>A Primer on Finding Files</h1>

    <p>
        Finding files is a very common operation in Linux, and the tools
        available are powerful, but not new-user friendly.
        We will cover GNU's <code>locate</code>, <code>find</code>, and <code>grep</code>
        utilities.
    </p>

</div>

<div id="basename" class="content">
    <h2> Pathnames and Basenames</h2>
    <p>
        To start, we must make a clear distinction between a file's
        <em>pathname</em> and a file's <em>basename</em>, because
        our search tools will often make a distinction between these two:
    </p>

    <center><img src="./assets/img/pathname-basename.png"></center>

    <p>
        Every file in the system has a pathname, which begins at root, <code>/</code>.
        This is also known as an <em>absolute filename</em>, and sometimes, a <em>wholename</em>.
        Each pathname denotes a unique point in the directory tree.
		</p>

		<div class=aside-left>
			<h4>Aside</h4>
	        In Linux, a single file can have more than one pathname.
			Each pathname is known as a <em>link</em>, and the kernel only deletes a file when it has no links.
			This is why the system call used to delete files is called <a href="http://man7.org/linux/man-pages/man2/unlink.2.html"><em>unlink</em></a>.
		</div>

    <p> The command <code>readlink</code> can report to us the pathname of an
        arbitrary file:

        <div class="code">
            $ cd /home/josh<br>
            $ readlink -f bin<br>
            /home/josh/documents
        </div>
    </p>

    <p>
        Every file in the system also has a basename.
        The command <code> basename</code> isolates this name for us:
        <div class="code">
            $ basename /home/josh/studies/merge.c<br>
            merge.c
        </div>
    </p>

    <p>
        Now, on to finding files!
    </p>
</div>

<div id="locate" class="content">
    <h2> Locate </h2>
    <p>
        Starting out, your best bet is the <code>locate</code> command:
	</p>

	<div class="code">
		locate <em>pattern</em>
	</div>

	<p>
        By default, <code>locate</code> matches <em>pattern</em> against the pathname of each file;
        if it does match, then the file's pathname is printed on a new line.
        Now, this command references a database of information about the files
        on the system.
        As such, it is very fast. However, if you have done some operation on the filesystem and
        the files you are looking for are new, then you must update this
        database:
    </p>

    <div class="code">
        $ sudo updatedb
    </div>

    <p>
		Moreover, <code>locate</code> is restricted to finding files by name.
        By default, <code>locate</code> is fairly permissive, matching things that
        you wouldn't want matched.
        For instance,
    </p>

    <div class="code">
        $ locate bin
    </div>

    <p>

        prints all files currently in the database whose pathname includes
        the string "bin".
        If we wanted to find all directories in the system named <code>bin</code>,
        then this is not what we want.
        On this system, we matched 56677 files.
        For instance,
    </p>

    <div class="code">
        /var/lib/dpkg/info/texlive-<strong>bin</strong>aries.postinst
    </div>

    <p>
        matches, as do
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/<strong>bin</strong>
    </div>

    <p>
        and
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/<strong>bin</strong>/rdoc
    </div>

    <p>
        The first thing we can do to narrow this list down is specify that
        <code>locate</code> match against the basename alone, rather than
        the full pathname.
        This is done with either <code> -b </code> or <code> --basename</code>:
    </p>

    <div class="code">
        $ locate --basename bin
    </div>

    <p>
        This reduces the number of matches by half, but still matches such things as
    </p>

    <div class="code">
        /var/lib/gems/2.5.0/gems/sassc-2.3.0/ext/libsass/src/<strong>bin</strong>d.hpp
    </div>

    <p>
        Our final modification to this command will be to match with an expression
        that can specify the beginning of the line as well as the end of the line:
    </p>

    <div class="code">
        $ locate --basename --regex ^bin$
    </div>

    <p>
        This gives the desired result. An introduction to regex is given in a video below.
    </p>

    <p>
        The <code>locate</code> command is limited to searching the entire directory
        tree of the current system.
		In addition, it is restricted to inspecting the name of each file.
		To get more in-depth, we must look elsewhere.
	</p>

</div>

<div id="find" class="content">

    <h2> Find </h2>
    <p>
        GNU's <code>find</code> utility is much more powerful.
        It searches the directory tree itself, and allows the user
        to query attributes of each file besides their names.
    </p>

    <p>
        The <code>find</code> utility works by beginning at the starting point(s)
        specified, inspecting each file it finds there, and comparing the attributes of each file against a sequence of tests,
        specified by you, the user.
        Then it descends, and repeats.
        If no starting point is specified, then <code>.</code> is implied.
    </p>

    <div class="code">
        find [starting-point...] [expression...]
    </div>

    <p>
        <code>[expression...]</code> may contain options, tests, or actions.
        Options affect global behavior, such as "descend n levels from starting point."
        Each file that <code>find</code> encounters is evaluated against the tests provided;
        if no tests are specified, then each file passes.
        If a file passes all tests given, then <code>find</code> will carry out the action(s) specified by the user;
        if no action is specified, then <code>-print</code> is implied.
    </p>

    <p>
        For instance, we can count all files on the system by,
    </p>

    <div class="code">
        $ sudo find / | wc -l
    </div>

    <p>
        We find 4.1 million files.
        We require superuser privileges to carry out the above task because
        some directories are not searchable by ordinary users (this is determined
        by the "search bit", which is the "executable" bit of a directory).
    </p>

    <p>
        <code>find</code> supports many tests. For instance, to find all
        files of size less-than 4 kilobytes, we could run,
    </p>

    <div class="code">
        $ sudo find / -size -4k | wc -l<br>
        2746999
    </div>

    <p>
        Each query is interpreted <em>as a sequence of logical tests</em>.
        Only when a file passes all of the tests is an action carried out.
        For instance, to count all executable files with size less than 4 kilobytes, we might,
    </p>

    <div class="code">
        $ sudo find / -size -4k -executable | wc -l
    </div>

    <p>
        This reads as, "Beginning at the root directory, print the pathname of each
        file that is both less than four kilobytes in size and is executable; then, count the lines."
        Files that will "match" are those that are both less than 4 kilobytes in size, and
        whose executable bit is set.  Note that this  includes searchable directories!
        To narrow our count down to programs, we must also specify that each file be of "regular" type:
    </p>

    <div class="code">
        $ sudo find / -size 4k -executable -type f | wc -l
    </div>

    <p>
        It's very important to think of each query as a sequence of logical tests, because that is how
        <code>find</code> thinks of it.
        The default logical operator between tests is <code>-and</code>.
		The operators <code>-or</code> and <code>-not</code> are also supported, along
        with parenthesis to allow grouping.
    </p>

	<h3>Some Common Tests</h3>
	<h4>Source: <a href="http://man7.org/linux/man-pages/man1/find.1.html"><code>man 1 find</code></a></h4>
	<br>
    <table>
        <tr><td> <code>-name <em> pattern</em></code></td> 	<td> True if basename of file matches shell pattern</td></tr>
        <tr><td> <code>-iname  <em>pattern</em></code></td>	<td>Same as -name, but ignores case</td></tr>
		<tr><td> <code>-regex <em>pattern</em></code></td>	  <td> True if regex expression matches pathname </td></tr>
		<tr><td> <code>-type f</code> </td>								<td>True if file is of type regular File </td></tr>
		<tr><td> <code>-type d</code> </td>								<td>True if file is of type Directory </td></tr>
    </table>

        <p>
            To find all directories on the system named "bin" on the system, we could execute,
        </p>

        <div class="code">
            $ sudo find / -name bin
        </div>

        <p>
	        This is equivalent to <code>locate --basename --regex ^bin$</code>, as given above,
			because <code>-name</code> uses a shell-style matching mechanism.
            To restrict the search to directories alone, we add an appropriate test:
        </p>

        <div class="code">
            $ sudo find / -name bin -type d
        </div>

        <p>
            To restrict the search to files in my home directory, we could carry out,
        </p>

        <div class="code">
            $ cd <br>
            $ find -name bin -type d
        </div>

        <p>
            and rely on the defaults.
            Note that this does not require superuser privileges, because I own
            all the files in this directory.
            To learn yet more about <code>find</code>, I recommend
            <a href="https://www.gnu.org/software/findutils/manual/find.html"> GNU Findutils Official Documentation</a>.
        </p>
    </div>

    <div id="grep" class="content">
        <h2>Grep</h2>

        <p>
            I'm pretty sure that <code>find</code> will let you test against
            any possible system-level attribute that a file may have.
            To go any deeper, we must look inside each file, and that is what
            <code>grep</code> will allow us to do.
        </p>

        <p>
            By default, <code>grep</code> is simple enough:  It reads a file,
            and if a line in the file matches a given pattern, it prints the line.<sup><a href="http://www.man7.org/linux/man-pages/man1/grep.1.html">[2]</a></sup>
            Grep's synopsis is,
        </p>

        <div class="code">
            grep [OPTION...] PATTERNS [FILE...]
        </div>

        <p>
            Of note, each <code>PATTERN</code> is regex by default, and
            must either terminate with a newline, or else be explicitly specified by
            using the <code>-e</code> option, as in,
        </p>

        <div class="code">
            $ grep -e "hello" -e "world" file1.c file2.c
        </div>

        <p>
            Will print each line in files <code>file1.c</code> or <code>file2.c</code>
            which match either <em>hello</em> or <em>world</em> or both.
        </p>

        <p>
            Of <code>grep's</code> options, we are particularly interested in
            <code>-l</code> (list), <code>-C</code> (context), and <code>-r</code> (recurse).
            The <code>-r</code> option specifies that, if a file is a directory,
            recursively descend into it (and continue searching).
            So,
        </p>

        <div class="code">
            $ grep . -r -e "hello" -e "world"
        </div>

        <p>
            will print all lines matching either <em>hello</em> or <em>world</em>,
            starting at the current directory, and working downwards.
            But, rather than the line, we might be interested in the context within
            which that expression is found.  In that case,
        </p>

        <div class="code">
            $ grep . -r -C 5 -e "hello" -e "world"
        </div>

        <p>
            This will print five lines before, as well as five lines after, each match.
            Finally, to print out just the name of the file, we specify that
            <code>grep</code> list the match, with <code>-l</code>:
        </p>

        <div class="code">
            $ grep . -rl -e "hello" -e "world"
        </div>

		<p>
            If no files are given, <code>grep</code> applies its craft to standard in.
			We can also specify standard in explicitly by including a <code>file</code> of <code>-</code> in the
			tool's positional parameters.
			In either case, this can be a useful mechanism.
		</p>

		<p>
			For instance, although <code>locate</code> is restricted to querying the entire filesystem, and matching only by name,
			it prints the entire pathname.
			We can, therefore, pass its output to <code>grep</code>, and reduce the number of "hits" dramatically.
		    Suppose we wish to find all files named <code>bin</code> in my home directory,
		    <code>/home/josh/</code>.
			Then,
		</p>

		<div id="example" class="code">
		    $ locate --basename --regex ^bin$ | grep '/home/josh/'
		</div>

		<p>
		    Here, each file in the database that has basename of exactly <code>bin</code> is printed; each line
		    is then sent through <code>grep</code>, which will print the line only if it matches
		    <code>/home/josh/</code> as well.
		</p>
		</div>

    <div id="engineer-man" class="content">
        <h2> Engineer Man </h2>

        <iframe class="video" src="https://www.youtube.com/embed/bgBWp9EIlMM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    </div>

    <div id="references" class="content">
        <h2> References </h2>
        <ol>
            <li><code><a href="http://www.man7.org/linux/man-pages/man1/locate.1.html"> man 1 locate</a></code></li>
            <li><code><a href="http://www.man7.org/linux/man-pages/man1/grep.1.html">man 1 grep</a></code></li>
            <li><a href="https://www.gnu.org/software/findutils/manual/find.html"> GNU Findutils Official Documentation</a></li>
            <li><code><a href="http://man7.org/linux/man-pages/man7/regex.7.html"> man 7 regex </a></code></li>
        </ol>

    </div>
