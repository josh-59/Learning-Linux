---
layout: default
title: How Open Source Works
last-updated: April 2021
---

<!--
    This paradigm is extensible, as well.
    Consider <em>makers</em>



    Quotes:
        "Don't be a dick."
            <a href="http://www.wheatonslaw.com/dontbeadick.html">Wheaton's Law</a>

        "Be considervative in what you do, be liberal in what you accept from others."
            <a href="https://en.wikipedia.org/wiki/Robustness_principle">Robustness Principle</a>

    Why You Should Choose Open Source:
        - User control
        - Free as in Cost, usually

    Why You Should Support Open Source:
        


    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            If the first statement of this section is taken literally, there are
            5<sup>1000</sup> possible GNU/Linux systems.
        </p>
    </div>



<div class="content" id="risc-v">
    <iframe class="video" src="https://www.youtube-nocookie.com/embed/Rsyn3_PjRXw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="content" id="brett-cannon">
    <h2> Brett Cannon </h2>
    <iframe class="video" src="https://www.youtube.com/embed/tzFWz5fiVKU?start=2935" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<li><a href="https://frame.work/">Framework | Introducing the Framework Laptop</a></li>
<li><a href="https://www.crowdsupply.com/">Crowd Supply</a> - For the Greater Goods</li>

<li><a href="#leadership">Leadership</a></li>
<li><a href="#closing-remarks">Closing Remarks</a></li>

-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#fork-merge">Fork/Merge</a></li>
        <li><a href="#time-based-releases">Time-Based Releases</a></li>
        <li><a href="#modularity">Modularity</a></li>
        <li><a href="#less"><code>less</code>: A Success Story</a</li>
        <li><a href="#build-what-you-want">Build What You Want</a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>


<div id="introduction" class="content">
    <h1>How Open Source Works</h1>

    <div class="quote-text">
        "Every good work of software <br>
        starts by scratching a developer's personal itch."
    </div>

    <div class="quote-ref">
        Eric S. Raymond<br>
        <em><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s02.html">The Cathedral and the Bazaar</a></em>
    </div>

    <p>
        So what makes it all tick?
        In this dramatic conclusion, we'll pick apart the
        common patterns of the open-source ecosystem,
        from the mechanics of contributing, to the
        resultingly modular structure.
        Hope you enjoyed!
    </p>
</div>

<div id="fork-merge" class="content">
    <h2>Fork/Merge</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Repositories exist in many contexts within open-source.
        </p>
    </div>

    <p>
        A <em>repository</em> is a tracked collection of files.
        The source code of an open-source project is available 
        in a public repository, and anyone
        may download or otherwise copy it.
        Such a copy is called a <em>fork.</em>
    </p>

    <p>
        Having created a fork, the software is now *yours*.
        You can inspect it, modify it, build it, install it, run it,
        discard it&mdash; Whatever you want.
        If you change some of its files, though, we say that your fork and 
        its source have <em>diverged.</em>
    </p>

    <p>
        Merging changes with the original repository is a process, and naturally
        involves the source's maintainer.
        The process begins with a <em>pull request,</em>
        which initiates a discussion about
        the proposed changes.<sup><a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">[a]</a></sup>
        If accepted, the changes are made to the original,
        and the two repositories are identical again.
    </p>

    <p>
        This pattern repeats at various scales.
        Today's revision control software allows an individual programmer
        to create distinct branches within a local repository,
        and to merge or abandon changes within it.
        At the macro scale, this pattern repeated with GNU's compiler
        collection, when a collection of forks became a concurrent project, 
        and was subsequently merged into GNU's main 
        trunk.<sup><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection#EGCS_fork">[b]</a></sup>
    </p>

    <p>
        For a few reasons, small merges are generally preferred over large 
        ones.
        First, the change is easier to review by others&mdash; especially,
        the project's maintainer.
        Second, bugs are less likely to be introduced.
        Third, small changes are less likely to break other peoples' work.
        This is especially important when the project implements
        some public API, and other projects depend upon it. 
        Finally, large changes simply don't bode well when 
        many people are working on the project.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://opensource.guide/">Open Source Guide</a></li>
        <li><a href="https://en.wikibooks.org/wiki/FOSS_A_General_Introduction/Introduction">FOSS: A General Introduction</a></li>
    </ul>
</div>

<div class="content" id="time-based-releases">
    <h2>Time-Based Releases</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            This section may be a little simplistic, but it seems worth
            developing precisely, if only once.
        </p>
    </div>

    <p>
        One of the fundamental challenges of open-source project 
        leadership is delivering, as Mozilla calls it,
        "stability without stagnation."<sup><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">[6]</a></sup>
        On one hand, we want to incorporate changes made by 
        many unknown people; but on the other,
        we also want to deliver a consistent product.
    </p>

    <p>
        One solution is to release a sequence of versions of the product:
        Even if each release is only
        marginally better than the previous, those improvements accrue,
        and the result is guaranteed to be great software.
    </p>

    <p>
        Large projects, such as the Linux kernel or Mozilla Firefox,
        for whom many people might want to see a particular change,
        often adopt a schedule for releases.
    </p>

    <p>
        For example, the last opportunity to merge feature
        changes in Firefox is before it enters <em>beta</em>.
        In beta, merges are restricted to bug fixes and 
        security updates. 
        Each release spends four weeks in <em>beta</em>
        before being released as the current official Firefox version.
    </p>

    <p>
        While it is released to the public, merges 
        are again restricted to bug fixes and
        security updates, and, again, each release
        is supported for four weeks:
    </p>

    <figure>
        <a href="https://wiki.mozilla.org/Release_Management/Calendar">
            <img src="assets/img/firefox-train-schedule.png" style="width: 90%; padding-bottom: 10pt;">
        </a>
        <figcaption><center><b><a href="https://wiki.mozilla.org/Release_Management/Calendar">Firefox Release Schedule</a></b></center></figcaption>
    </figure>

    <p>
        Witin Mozilla, this is known as a "train schedule,"
        and we see that <em>Firefox 80</em> will be released as 
        <em>Firefox 81</em>
        enters Beta and <em>Firefox 82</em> enters Nightly.
    </p>

    <p>
        Firefox is one of the largest and most agressive open-source
        projects outside of the Linux kernel.
        It even spawned the (awesome) programming language, Rust.
    </p>

    <!--
        There is some irony in trying to control improvement...

    -->

    <h3>Game Development</h3>

    <p>
        One area where "incremental improvement" does not apply 
        is game development, and the open-source community has always
        lagged behind their proprietary counterparts here.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Release_early,_release_often">Release Early, Release Often</a> - Wikipedia</li>
        <li><a href="https://blog.rust-lang.org/2014/10/30/Stability.html"> Stability as a Deliverable | Rust Blog</a></li>
        <li><a href="http://thinking-in-code.blogspot.com/2010/07/train-model-of-software-development.html"> Thinking in Code: Train Model of Software Development</a></li>
    </ul>
</div>

<div class="content" id="modularity">
    <h2 style='margin-bottom: 0px;'>Modularity</h2>
    <h4>and The Unix Philosophy</h4>

    <p>
        GNU/Linux can be likened to a 500-piece puzzle with 2500 available pieces:
        For any piece of the puzzle (shell, desktop environment,
        web browser, text editor&mdash; right down to
        C libraries<sup><a href="https://en.wikipedia.org/wiki/C_standard_library#Implementations">[h]</a></sup>
        and kernels<sup><a href="https://www.kernel.org/">[i]</a></sup>),
        there
        are around five competent options to choose from.
    </p>

    <p>
        This is an example of modular construction, and it is often left to
        the user to decide which software component
        instantiates each needed piece.
        Modular (as opposed to <em>monolithic</em>) construction lies at the
        heart of both open source and the UNIX philosophy:
    </p>

    <blockquote>
        "A serious attempt is made to apply the principle of modularity to everything on a Unix-like system, not only programs but also parts of programs, such as algorithms, and even the kernel. Thus, a Unix-like operating system generally (or at least ideally) consists of a small kernel together with a large number of small, specialized programs that can interact with each other through a variety of well-defined interfaces."<sup><a href="http://www.linfo.org/unix_philosophy.html">[g]</a></sup>
    </blockquote>
    <p>
        Modularity is realized in a variety of ways, and its implications
        are similarly numerous.
        First, a programmer working on any given piece must solve a
        greatly simplified problem.
        Consequently, many solutions may be tried, which then compete
        amongst themselves.
        Thus, the user is presented with an abundance of choice.
    </p>

    <h3>Linus' Rule</h3>

    <p>
    <em>If it's a bug that's being used, it's a feature, not a bug.</em>
    <p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.linfo.org/module.html">Module Definition</a> - LINFO</li>
    </ul>
</div>

<div class="content" id="less">
    <h2 style="margin-bottom: 0;"><code>less</code>:</h2>
    <h4>A Success Story</h4>

    <p>
        So, let's take a look at one piece of the puzzle.
        A <em>paging utility</em> is a program that displays a file on 
        the terminal one screenful at a time.
        The first widely used paging utility was <code>more</code>, written by
        Dan Halbert as a graduate student at UC Berkley in 1978.<sup><a href="https://danhalbert.org/more.html">[aa]</a></sup>
        <code>more</code> is a simple program, first filling up the screen,
        then waiting for user input to print the next line(s).
    </p>

    <p>
        In 1983, Mark Nudelman was a software developer working for a
        company called Integrated Office Systems. From the <a href="http://www.greenwoodsoftware.com/less/faq.html#history"><code>less</code> FAQ</a>:
    </p>

    <blockquote>
        Some of our software ran on a Unix system and produced enormous log files
        of its transactions. We wanted to be able to search these log files for
        error messages. But the version of "vi" we were using couldn't handle
        files larger than a certain size, and our log files often exceeded that
        size. So we were forced to use "more" to view the files. The problem was,
        once we found an error message, what we really wanted to see was the
        transactions leading up to the error; that is, the lines in the log file
        immediately before the error message. But more didn't allow backward
        movement in the file.
    </blockquote>

    <blockquote>
        We often complained about this problem. We said we needed a "backwards
        more"; someone (it wasn't me, but unfortunately I don't remember who
        it was) coined the name "less" as a joke on the concept of a "backwards
        more". It didn't seem to me that it would be too difficult to write a
        simple pager that would allow forward and backward movement.
        I wrote the first version in late 1983 and we began using it internally.
        I continued to enhance it and finally decided it was a useful enough
        tool that I should make it available to the world. I posted the first
        version to the newsgroup called (at that time) net.sources in May, 1985.
    </blockquote>

    <blockquote>
        Making the program publicly available allowed an enormous number of
        people to use it. Many people have made their own modifications and
        donated them to me for incorporation into the official version, and
        many more have reported bugs they've found or made suggestions about
        features they'd like to see added. This was my first experience with
        the concept of what is now called "open source" or "free software",
        and it has, I believe, produced a very high quality product. I'd like
        to thank all the users of less for their invaluable comments and
        suggestions over the years. Less wouldn't be what it is today without you.
    </blockquote>

    <p>
        Mark Nudelman continues to maintain the project today.  
        It is, at the time of this writing, in its 581<sup>st</sup> 
        version.<sup><a href="http://www.greenwoodsoftware.com/less/faq.html#version">[q]</a></sup><sup><a href="http://www.greenwoodsoftware.com/less/index.html">[r]</a></sup>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://fedoramagazine.org/5-cool-terminal-pagers-in-fedora/">5 cool terminal pagers in Fedora</a> - Fedora Magazine</li>
        <li><a href="https://zaiste.net/posts/shell-commands-rust/">Rewritten in Rust: Modern Alternatives of Command-Line Tools</a></li>
    </ul>
</div>


<div class="content" id="build-what-you-want">
    <h2>Build What You Want</h2>

    <p>
        To call open source a hobby isn't quite strong enough; 
        simultaneously, it isn't necessarily "work", either.  
        Open-Source and GNU/Linux is somewhere between the two,
        closer to sport.
        For me, the magic is that it's composed of
        things people created because they wanted to.
        As it turns out, they've built something stellar, and best
        of all, you can turn around and inspect it yourself.
    </p>

    <p>
        I do not believe that the ordinary user is 
        obligated to contribute to open source.  
        In particular, the "cathedral" model (like GNU) does not
        accept user modifications to their work:
        They built what they wanted to build, now it's freely available,
        and that's that&mdash; their hands are washed from it.
    </p>


    <blockquote>
        "Thompson wanted to create a comfortable computing environment 
        constructed according to his own design, using whatever means 
        were available. His plans, it is evident in retrospect, 
        incorporated many of the innovative aspects of Multics,
        including an explicit notion of a process as a locus of 
        control, a tree-structured file system, a command interpreter 
        as user-level program, simple representation of text files, 
        and generalized access to devices. They excluded others, such
        as unified access to memory and to
        files."<sup><a href="https://www.bell-labs.com/usr/dmr/www/chist.html">[o]</a></sup>
    </blockquote>

    <blockquote>
        This is a program for hackers by a hacker.  I've enjouyed doing
        it, and somebody might enjoy looking at it and even modifying it for
        their own needs.<sup><a href="https://josh-59.github.io/Learning-Linux/pre/free-minix-like-kernel-sources-for-386-at.html">[a]</a></sup>
    </blockquote>


    <h3>See Also:</h3>
    <ul>
        <li><a href="https://blog.linuxmint.com/?p=4054">Monthly News - April 2021 - The Linux Mint Block</a></li>
        <li><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/afterword/">Afterword: Beyond Software?</a></li>
    </ul>
</div>


<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from <a href="https://wiki.osdev.org/Required_Knowledge">https://wiki.osdev.org/Required_Knowledge</a></li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
        <li>Turon, A., &amp; Matsakis, N. (2014, October 30).  Stability as a Deliverable:  Rust Blog.  Retrieved August 18, 2020, from
            <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">https://blog.rust-lang.org/2014/10/30/Stability.html</a></li>
        <li> The Firefox release process. (n.d.). Retrieved August 18, 2020, from <a href="https://wiki.mozilla.org/Release_Management/Release_Process">https://wiki.mozilla.org/Release_Management/Release_Process</a></li>
    </ol>
</div>
