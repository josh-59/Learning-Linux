---
layout: default
title: How Open Source Works
last-updated: April 2021
---

<!--

Incremental Improvement
    Release early, release often
    https://en.wikipedia.org/wiki/Release_early,_release_often

    Kernel development team prefers incremental improvements
    https://lkml.org/lkml/2007/7/28/145


<div class="content" id="leadership">
    <h2>Leadership</h2>
    <p>
        Among successful open-source projects, one element remains constant,
        and that is <em>leadership.</em>
        Stated formally, For all successful open-source projects, there exists
        a leader.
        Stated another way, "Open source democracy doesn't work."&mdash; Brian Camprill
    </p>

    <p>
        For example, Linux kernel development is led by Linus Torvalds.
        The community <em>needed</em> someone to say,
        "No we're not doing that," on occaision, but firmly,
    </p>

    <p>
        As Greg Kroah-Hartman has said, "Half my job is to say 'no'."
    </p>

    <p>
        This works in open source because any user is always free to
        fork the source repository and take the project in a new direction.
        For example, <a href="https://www.devuan.org/">Devuan</a> is a fork of
        Debian without <code>systemd</code>
        (the introduction of <code>systemd</code> became cause for very bitter
        conflict within the Debian developer community).
    </p>

    BDFL:
        1) No-one is forcing anyone to work on their projects
        2) Open-source projects can always be forked into a sub-project

    <p>
        Linus' Law: Should be in reference to interfaces of a modular system:
        If it's a bug that people rely on, it's not a bug, it's a feature.
    </p>
</div>

<div class="content" id="building-what-they-want">
    <h2>Building What They Want</h2>

    <p>
        The Linux kernel began as a hobby; 
        Torvalds, "GNU emacs of terminal emulators", became a kernel during a
        marathon hacking session.
    </p>

    <blockquote>
    "Thompson wanted to create a comfortable computing environment constructed
    according to his own design, using whatever means were available. His plans, it
    is evident in retrospect, incorporated many of the innovative aspects of Multics,
    including an explicit notion of a process as a locus of control, a tree-structured
    file system, a command interpreter as user-level program, simple representation
    of text files, and generalized access to devices. They excluded others, such as
    unified access to memory and to
    files."<sup><a href="https://www.bell-labs.com/usr/dmr/www/chist.html">[o]</a></sup>
    </blockquote>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            It doesn't become "your thing" just because you had an idea.
        </p>
    </div>

   
    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/afterword/">Afterword: Beyond Software?</a></li>
    </ul>
</div>


<div class="content" id="closing-remarks">
    <h2 style="margin-bottom: 0;">Closing Remarks:</h2>
    <h4>Don't be a dick</h4>

    <p>
        As users of their creations, we are very much "after the fact."
        <em>detailed bug reports.</em>
    </p>

    <p>
        I do not believe that the ordinary user is obligated to contribute 
        to open source.  If they do, they should recognize that they are 
        <em>donating a modification</em>, not necessarily "making a contribution,"
        and that it is left to the repository mainatainer to do 
        something&mdash; if anything&mdash; with it.
        Finally, the most substantial contributions are made by doing 
        what you do best :).
    </p>
</div>

<div class="content" id="risc-v">
    <iframe class="video" src="https://www.youtube-nocookie.com/embed/Rsyn3_PjRXw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="content" id="brett-cannon">
    <h2> Brett Cannon </h2>
    <iframe class="video" src="https://www.youtube.com/embed/tzFWz5fiVKU?start=2935" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<li><a href="https://frame.work/">Framework | Introducing the Framework Laptop</a></li>
<li><a href="https://www.crowdsupply.com/">Crowd Supply</a> - For the Greater Goods</li>

<li><a href="#leadership">Leadership</a></li>
<li><a href="#closing-remarks">Closing Remarks</a></li>

-->


<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#fork-merge">Fork/Merge</a></li>
        <li><a href="#reiterative-improvement">Reiterative Improvement</a></li>
        <li><a href="#modularity">Modularity</a></li>
        <li><a href="#less"><code>less</code>: A Success Story</a</li>

        <li><a href="#references"> References </a></li>
    </ul>
</div>


<div id="introduction" class="content">
    <h1>How Open Source Works</h1>

    <div class="quote-text">
        "Given enough eyeballs, all bugs are shallow."
    </div>

    <div class="quote-ref">
        <a href="https://github.com/dwmkerr/hacker-laws#9091-principle-1-rule">Linus's Law</a>
    </div>

    <p>
        So what makes it all tick?
        In this dramatic conclusion, we'll pick apart the
        common patterns of the open-source ecosystem,
        from the mechanics of contributing, to their organizational structures.
        Hope you enjoyed!
    </p>
</div>

<div id="fork-merge" class="content">
    <h2>Fork/Merge</h2>

    <p>
        Recall that a repository is tracked collection of files,
        usually containing a package.
        Open-source repositories are made publicly available, and anyone
        may download or otherwise copy them.
        Such a copy is called a <em>fork.</em>
    </p>

    <p>
        Having created a fork, the software is now *yours*.
        You can inspect it, modify it, build it, install it, run it,
        discard it&mdash; whatever you want.
        If you change some of its files, though, we say that your fork and its source
        have <em>diverged.</em>
    </p>

    <p>
        Merging changes with the original is a process, and naturally
        involves the source repository's maintainer.
        The process begins with a <em>pull request,</em>
        which initiates a discussion about
        the proposed changes.<sup><a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">[a]</a></sup>
        If accepted, the changes are made to the original,
        and the two repositories are identical again.
    </p>

    <p>
        This pattern repeats at various scales.
        Today's revision control software allows an individual programmer
        to create distinct branches within a local repository,
        and to merge or abandon changes as they fit.
        At the macro scale, this pattern repeated with GNU's compiler
        collection, when a collection of forks became a concurrent project, and was subsequently merged
        into GNU's main trunk.<sup><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection#EGCS_fork">[b]</a></sup>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://opensource.guide/">Open Source Guide</a></li>
        <li><a href="https://en.wikibooks.org/wiki/FOSS_A_General_Introduction/Introduction">FOSS: A General Introduction</a></li>
    </ul>
</div>

<div class="content" id="reiterative-improvement">
    <h2 style='margin-bottom: 0px;'>  Reiterative Improvement</h2>
    <h4>and Train Schedules </h4>

    <p>
        Software development is fundamentally reiterative:
        You build something, publish it, improve it and release it again.
        Such reiterative improvement is realized in both open- and closed-source
        development models.
    </p>

    <p>
        The "train schedule" formalizes this by putting it on
        a timetable;
        it is often adopted by larger projects as a means
        of organizing many (individually minor) changes into a coherent whole.
    </p>

    <p>
        Mozilla
        "stability without stagnation."<sup><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">[6]</a></sup>
    </p>

    <p>
        A new Firefox version is scheduled for release every four weeks.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[7]</a></sup>
    </p>

    <figure>
        <img src="assets/img/train-schedules.png" style="width: 100%;">
    </figure>


        <div class="aside-right">
            <h4>Aside</h4>
            <p>
                Firefox is one of the largest and most agressive open-source
                projects outside of the Linux kernel.
                It even spawned the (awesome) programming language, Rust.
            </p>
        </div>


    <p>
        That is, each version spends four weeks in the <em>Mature</em> category,
        being the officially-supported, current version of Firefox.
        When here, no new features are implemented&mdash; rather, only
        security patches and bug-fixes are implemented and pushed to the user.
        After its four weeks in the spotlight, it is discarded,
        for the next version is ready.
    </p>

    <p>
        Before it becomes mature, each version of Firefox has been released as a <a href="https://www.mozilla.org/en-US/firefox/80.0beta/releasenotes/">beta</a>;
        this status corresponds to <em>Initial Release</em> above.
        When a release enters the <em>Beta</em> stage, only patches aimed at improving
        stability are accepted.<sup><a href="https://wiki.mozilla.org/Release_Management/Release_Process">[6]</a></sup>
        Each release spends four weeks there.
        Finally, there is the <a href="https://www.mozilla.org/en-US/firefox/80.0a1/releasenotes/">Nightly</a> build,
        which contains the latest (and most untested) features.
    </p>

    <p>
        Here we see that <em>Firefox 80</em> will be released as <em>Firefox 81</em>
        enters Beta and <em>Firefox 82</em> enters Nightly:
    </p>

    <!--
        There is some irony in trying to control improvement...
    -->

    <figure>
        <a href="https://wiki.mozilla.org/Release_Management/Calendar">
            <img src="assets/img/firefox-train-schedule.png" style="width: 90%; padding-bottom: 10pt;">
        </a>
        <figcaption><center><b><a href="https://wiki.mozilla.org/Release_Management/Calendar">Firefox Release Schedule</a></b></center></figcaption>
    </figure>

       <h3>See Also:</h3>
    <ul>
        <li><a href="https://blog.rust-lang.org/2014/10/30/Stability.html"> Stability as a Deliverable | Rust Blog</a></li>
        <li><a href="http://thinking-in-code.blogspot.com/2010/07/train-model-of-software-development.html"> Thinking in Code: Train Model of Software Development</a></li>
    </ul>
</div>

<div class="content" id="modularity">
    <h2 style='margin-bottom: 0px;'>Modularity</h2>
    <h4>and The Unix Philosophy</h4>

    <p>
        GNU/Linux can be likened to a 1000-piece puzzle with 5000 available pieces:
        For any piece of the puzzle (shell, desktop environment,
        web browser, text editor&mdash; right down to
        C libraries<sup><a href="https://en.wikipedia.org/wiki/C_standard_library#Implementations">[h]</a></sup>
        and kernels<sup><a href="https://www.kernel.org/">[i]</a></sup>),
        there
        are around five competent options to choose from.
    </p>

    <p>
        This is an example of modular construction, and it is often left to
        the user to decide which software component
        <a href="https://www.merriam-webster.com/dictionary/instantiate">instantiates</a>
        each needed piece.
        Modular (as opposed to <em>monolithic</em>) construction lies at the
        heart of both open source and the UNIX philosophy:
    </p>

    <blockquote>
        "A serious attempt is made to apply the principle of modularity to everything on a Unix-like system, not only programs but also parts of programs, such as algorithms, and even the kernel. Thus, a Unix-like operating system generally (or at least ideally) consists of a small kernel together with a large number of small, specialized programs that can interact with each other through a variety of well-defined interfaces."<sup><a href="http://www.linfo.org/unix_philosophy.html">[g]</a></sup>
    </blockquote>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            If the first statement of this section is taken literally, there are
            5<sup>1000</sup> possible GNU/Linux systems.
        </p>
    </div>

    <p>
        Modularity is realized in a variety of ways, and its implications
        are similarly numerous.
        Not only is the user presented with an abundance of choice,
        a programmer working on any given piece must solve a
        greatly simplified problem.
        Consequently, numerous solutions may be tried, which then compete
        amongst themselves.
        Most importantly, however, comprehension of a given piece is made possible,
        while comprehension of the whole is made unnecessary.
    </p>

    <p>
        Through modularity, a complex problem can, and has, been broken down
        and solved.
        The strategy has proved crucial not only to the development of computer
        software as well as
        <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">computer hardware</a>.
        Finally, the notion may be applied to responsibility:
        A <em>distribution</em> is a project that assembles components into
        a working operating system, and makes the result available to others.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="http://www.linfo.org/module.html">Module Definition</a> - LINFO</li>
    </ul>
</div>


<div class="content" id="less">
    <h2 style="margin-bottom: 0;"><code>less</code>:</h2>
    <h4>A Success Story</h4>

    <p>
        So, let's take a look at one piece of the puzzle.
        A <em>paging utility</em>
        is a program that displays a file on the terminal one screenful at a time.
        The first widely used paging utility was <code>more</code>, written by
        Dan Halbert as a graduate student at UC Berkley in 1978.<sup><a href="https://danhalbert.org/more.html">[aa]</a></sup>
        <code>more</code> is a simple program, first filling up the screen,
        then waiting for user input to print the next line(s).
    </p>

    <p>
        In 1983, Mark Nudelman was a software developer working for a
        company called Integrated Office Systems. From the <a href="http://www.greenwoodsoftware.com/less/faq.html#history"><code>less</code> FAQ</a>:
    </p>

    <blockquote>
        Some of our software ran on a Unix system and produced enormous log files
        of its transactions. We wanted to be able to search these log files for
        error messages. But the version of "vi" we were using couldn't handle
        files larger than a certain size, and our log files often exceeded that
        size. So we were forced to use "more" to view the files. The problem was,
        once we found an error message, what we really wanted to see was the
        transactions leading up to the error; that is, the lines in the log file
        immediately before the error message. But more didn't allow backward
        movement in the file.
    </blockquote>

    <blockquote>
        We often complained about this problem. We said we needed a "backwards
        more"; someone (it wasn't me, but unfortunately I don't remember who
        it was) coined the name "less" as a joke on the concept of a "backwards
        more". It didn't seem to me that it would be too difficult to write a
        simple pager that would allow forward and backward movement.
        I wrote the first version in late 1983 and we began using it internally.
        I continued to enhance it and finally decided it was a useful enough
        tool that I should make it available to the world. I posted the first
        version to the newsgroup called (at that time) net.sources in May, 1985.
    </blockquote>

    <blockquote>
        Making the program publicly available allowed an enormous number of
        people to use it. Many people have made their own modifications and
        donated them to me for incorporation into the official version, and
        many more have reported bugs they've found or made suggestions about
        features they'd like to see added. This was my first experience with
        the concept of what is now called "open source" or "free software",
        and it has, I believe, produced a very high quality product. I'd like
        to thank all the users of less for their invaluable comments and
        suggestions over the years. Less wouldn't be what it is today without you.
    </blockquote>

    <p>
        Mark Nudelman continues to maintain the project today.  It is, at
        the time of this writing, in its 581<sup>st</sup> version.<sup><a href="http://www.greenwoodsoftware.com/less/faq.html#version">[q]</a></sup><sup><a href="http://www.greenwoodsoftware.com/less/index.html">[r]</a></sup>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://fedoramagazine.org/5-cool-terminal-pagers-in-fedora/">5 cool terminal pagers in Fedora</a> - Fedora Magazine</li>
    </ul>
</div>


<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from <a href="https://wiki.osdev.org/Required_Knowledge">https://wiki.osdev.org/Required_Knowledge</a></li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
        <li>Turon, A., &amp; Matsakis, N. (2014, October 30).  Stability as a Deliverable:  Rust Blog.  Retrieved August 18, 2020, from
            <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">https://blog.rust-lang.org/2014/10/30/Stability.html</a></li>
        <li> The Firefox release process. (n.d.). Retrieved August 18, 2020, from <a href="https://wiki.mozilla.org/Release_Management/Release_Process">https://wiki.mozilla.org/Release_Management/Release_Process</a></li>
    </ol>
</div>
