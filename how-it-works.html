---
layout: default
title: How Open Source Works
last-updated: May 2021
---

<!--

        I do not believe that engineers would, left to their own devices,
        build a pickup-truck that destroys the planet.

Although I'd love to believe that open-source software
        is as casual as it's portrayed to be, it simply isn't.
        Good software is not easy to produce, and open-source is
        no different.
    </p>

    https://www.youtube.com/watch?v=XFrJcjCbCA8

    <p>
        Given intrinsic motivation, the open-source scene naturally
        decomposes into projects, with people working on what they want.
        This can give the appearance of self-satisfying development:
        For example, producing an operating system
        is outside the scope of the Linux kernel project.
        Their focus is on the kernel.
    </p>

    <p>
        Nonetheless, these projects have formed something substantial.
    </p>

    <p>
        For example, Facebook has put extensive effort into
        Linux's new <code>btrfs</code>, commonly described as 
        "a modern copy-on-write filesystem."
        The filesystem eases routine administrative tasks, especially in 
        enterprise-class settings.
        Facebook has contributed to the project for their own purposes;
        nonetheless, the resulting software is GNU GPL'd 
        (Version 2, to be specific), 
        and so from the user's standpoint, is as free (libre) as anything
        crafted by GNU's own hand.
    </p>

    <p>
        "No one "owns" the software in the traditional sense of 
        being able to command how it is used or developed,
        or to control its disposition."
            http://www.benkler.org/CoasesPenguin.PDF
        "[Common's] central characteristic is that groups of individuals
        successfully collaborate on large-scale projects following a
        diverse cluster of motivational drives and social signals,
        rath than either market prices or managerial commands."
    </p>

    "Write programs that do one thing and do it well.
    Write programs that work together."
    Douglas McIlroy 
    UNIX Time-Sharing System Foreword
    The Bell System Technical Journal 57, no. 6, 1978

    Working In Public
    by Nadia Eghbal
    Notes:
        The term <em>open source</em> describes the way that software
        is distributed and used, not to how it is produced.
            p 44


        Reasons to participate in the "Commons"
        - Intrinsic Motivation
            - i.e., it's neat
        - Modular and Granular Tasks
        - Low Coordination Costs
            Benkler, p74

    Quotes:
        "Be conservative in what you do, be liberal in what you accept from 
        others."
        <a href="https://en.wikipedia.org/wiki/Robustness_principle">Robustness 
        Principle</a>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            If the first statement of this section is taken literally, 
            there are
            5<sup>500</sup> possible GNU/Linux systems.
        </p>
    </div>

<div class="content" id="risc-v">
    <iframe class="video" src="https://www.youtube-nocookie.com/embed/Rsyn3_PjRXw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div class="content" id="brett-cannon">
    <h2> Brett Cannon </h2>
    <iframe class="video" src="https://www.youtube.com/embed/tzFWz5fiVKU?start=2935" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<li><a href="https://frame.work/">Framework | Introducing the Framework Laptop</a></li>
<li><a href="https://www.crowdsupply.com/">Crowd Supply</a> - For the Greater Goods</li>

<li><a href="#leadership">Leadership</a></li>
<li><a href="#closing-remarks">Closing Remarks</a></li>


        <li><a href="https://press.stripe.com/">Stripe Press</a> - Ideas for progress</a></li>


    Not easy
        |
        |
        |
        |
       \ /
Intrinsic Motivation
        |
        |   
        |   
        |
       \ /
Project Leadership
        |   Curating Modifications
        |
        |   Large projects:  Tree?
        |
       \ /
Incremental Improvement
        |   
        |
        |   Large projects: Time-based Releases
        |
       \ /
  Github is a Platform!
        |   
        |
        |   Large projects: Make their own platform
        |   Large Projects: Foundations
        |
       \ /
  What's it Like?
        |   
        |   Sport
        |  
        |
       \ /

-->

<div id="nav_bar_2" class="nav">
    <ul>
        <li><a href="#introduction"> Introduction </a></li>
        <li><a href="#from-the-top">From the Top</a></li>
        <li><a href="#project-leadership">Project Leadership</a></li>
        <li><a href="#less"><code>less</code>: A Success Story</a</li>
        <li><a href="#sports">Sports</a></li>
        <li><a href="#references"> References </a></li>
    </ul>
</div>


<div id="introduction" class="content">
    <h1>How Open Source Works</h1>

    <div class="quote-text">
        "That's how open source works: <br>Iterate, deploy, study, repeat."
    </div>

    <div class="quote-ref">
        <a href="https://doc.redox-os.org/ion-manual/html/">Ion Shell manual</a>
    </div>

    <p>
        So what makes it all tick?
        In this dramatic conclusion, we'll pick apart the
        key components of the open-source ecosystem,
        from the motivations of contributors to the leadership
        style necessarily implied by them.
    </p>

</div>

<div class="content" id="motivations">
    <h2>Motivations</h2>

    <p>
        As Eric S. Raymond noted, 
        Every good software project starts by a developer
        scratching a personal itch.
        Economists today call this <em>intrinsic</em> motivation,
        and it may be contrasted with the "extrinsic" motivation
        of money.
    </p>

    <p>
        The consequence of intrinsic motivation is that 
        the open-source scene naturally decomposes into projects, 
        with people working on what they want.
        That these projects have formed something truly substantial
        is outside the scope of any of them!
    </p>

    <p>
        For example, producing an operating system
        is outside the scope of the Linux kernel project:
        They do kernels for kernels' sake, and somebody interested
        in composing operating systems does that.
    </p>

    <div class="aside-right">
        <h4>Fun Fact:</h4>
        <p>
            Linus Torvalds once turned down a job offer from Steve Jobs
            because it wasn't interesting from a technical 
            standpoint.
        </p>
    </div>

    <p>
        Good works don't die, per se, and no matter the age,
        software in wide use is actively being developed.  
        For example, while Bash is 31 years old, and is 
        extremely stable, it's still under
        significant development: 
        In 
    </p>

    <p>
        World is not perfect, and many contributors have motivations
        other than the software itself.
        These individuals do not have the project's 
        raison diatre (?) at heart, and often leave.
    </p>

    <p>
        For Debian developer __________, Debian was a "make the world
        a better place" project.  
        But, <em>making the world a better place</em> was not 
        the project's stated intent; Ian Murdoch's intent was to 
        create a distribution that was supported by interested users,
        especially, one that could compete with commercial operating 
        systems!
    </p>
</div>

<div class="content" id="dividing">
    <h2>The Cathedral and the Bazaar</h2>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            The cathedral is characterized by a closed group of 
            developers publishing free software; it
            still has a place in modern open-source.
        </p>
    </div>


    <p>
        To call open-source a hobby isn't quite strong enough; 
        at the same time, it isn't <em>work</em> in the 
        traditional sense, either.  
        Open-Source and GNU/Linux lie somewhere between the two,
        closer to sport.
        For me, the magic is that it's composed of
        things people created because they wanted to.
    </p>

    <p>
        The most common open-source model today is what Eric S. 
        Raymond termed the <em>Bazaar:</em> The project's 
        maintainers make themselves publicly available, and
        contributions are welcome.
        This he juxtaposed with the then-traditional <em>Cathedral,</em>
        in which the maintainers of the project seal themselves
        from public suggestion.
    </p>

    <p>
        Since its introduction, the Bazaar model 
        has dominated open source.
        In my view, this is because it supports project growth much
        more responsively than the Cathedral: When projects are
        interesting (or of interest), people can more easily
        improve it, making it more successful.
        Besides: If everyone is invited, then you are too!
    </p>

    <p>
        Within a bazaar, there is usually structure, in the form of a
        "tree of trust" to handle code review and commit acceptance:
        Suggested edits are reviewed and filtered up on their way
        to being accepted.
    </p>

    <p>
        To support these communities and projects, you will
        often see Foundations&mdash; Linux Foundation, 
        Free Software Foundation, Mozilla Foundation, etc..
        These are 
    </p>

    <p>
        By contrast, <a href="">Github</a> is a propietary, 
        for-profit business that describes itself as a 
        "social coding platform." 
        It is characteristically two-dimensional, offering convenience
        at the expense of structure, and is not appropriate for
        large and popular projects. 
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.contributor-covenant.org/">Contributor Covenant[...] </a> by Coraline Ada Ehmke</li>
    </ul>
</div>

<div class="content" id="not-easy">
    <h2>Not Easy!</h2>

    <p>
        While I'd love to believe that open-source is as casual as
        Github portrays it to be, it's simply not:
        Good software is not easy to produce. 
        It's one thing to write a Python script for your own 
        purposes (or even a shell to demonstrate the idea); it's
        quite another to produce a product that's useable by 
        millions of people.
    </p>

    <p>
        In particular, there is a significant connection between 
        mathematical thinking and programming skill.
        For example, all of the operating systems researchers 
        of Bell Laboratories held
        Ph.D.'s in mathematics&mdash; and bear in mind that 
        UNIX was their <em>second</em> try!
    </p>

    <p>
        The role of project leader quickly skews from 
        <em>lead developer</em> to 
        <em>code reviewer and modification curator;</em>
        today, you will often see the term <em>maintainer</em>
        to describe the project's head honcho.
    </p>



    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Greg Kroah-Hartman once said, "Half my job is to say 'no'."
        </p>
    </div>



    <p>
        It isn't a coincidence that most of open-source's
        founders were college students.  


    <p>
        For the serious developer, mathematics is used literally in,
        especially, data structures.  
        Data structures, discrete mathematics, logic and 
        computer architecture form the core
        of undergraduate computer science today; nonetheless,
        skill is best accrued by reading and writing source.
    </p>

    <ul>
        <li><a href="https://www.hackerrank.com/">HackerRank</a></li>
        <li><a href="https://opendatastructures.org/">Open Data Structures</a> by Pat Morin</li>
        <li><a href="http://discrete.openmathbooks.org/dmoi3.html">Discrete Mathematics: An Open Introduction</a> by Oscar Levin</li>
        <li><a href="https://csapp.cs.cmu.edu/">Computer Systems: A Programmer's Perspective</a> by Randal E. Bryant and David R. O'Hallaron</li>
        <li><a href="https://man7.org/tlpi/index.html">The Linux Programming Interface</a> by Michael Kerrisk</li>
        <li><a href="https://store.doverpublications.com/0486406873.html">Introduction to Logic</a> by Patrick Suppes (Bonus!)</li>
    </ul>
</div>

<div class="content" id="incremental-improvement">
    <h2>Incremental Improvement</h2>

    <p>
        The general strategy employed is to build something,
        release it, review it, improve it, and then rebuild it.
    </p>

    <p>
        I like to think that, first, code left untouched does not degrade;
        that is, it persists.  
        ...Improvement is incidental to its being publicly exposed...
        Even if each release is only
        marginally better than the previous, those improvements accrue,
        and the result is guaranteed to be great software.
    </p>

    <p>
        Large projects, for whom many people might want to see a 
        particular change, often preemptively schedule releases.  
        The intent is to produce a reiterative cycle 
        that accomodate both feature introduction <em>and</em> 
        commit rejection&mdash; if your change doesn't make it into 
        the latest kernel release, for instance, you only have to 
        wait six weeks for the next one.
    </p>

    <p>
        One of the challenges of open-source project 
        leadership is delivering, as Mozilla calls it,
        "stability without stagnation."<sup><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">[6]</a></sup>
        On one hand, we want to incorporate changes made by 
        many unknown people; but on the other,
        we also want to deliver a consistent product.
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Outside of the Linux kernel, Firefox is one of the largest and
            most aggressive open-source projects is 
        </p>
    </div>

    <p>
        For example, the last opportunity to merge feature
        changes in Firefox is before it enters <em>beta</em>.
        In beta, merges are restricted to bug fixes and 
        security updates. 
        Each release spends four weeks in <em>beta</em>
        before being released as the current official Firefox version.
    </p>

    <p>
        While it is being used by the, merges 
        are again restricted to bug fixes and
        security updates, and, again, each release
        is supported for four weeks:
    </p>

    <figure>
        <a href="https://wiki.mozilla.org/Release_Management/Calendar">
            <img src="assets/img/firefox-train-schedule.png" style="width: 90%; padding-bottom: 10pt;">
        </a>
        <figcaption><center><b><a href="https://wiki.mozilla.org/Release_Management/Calendar">Firefox Release Schedule</a></b></center></figcaption>
    </figure>

    <p>
        Witin Mozilla, this is known as a "train schedule,"
        and we see that <em>Firefox 80</em> will be released as 
        <em>Firefox 81</em>
        enters Beta and <em>Firefox 82</em> enters Nightly.
    </p>

    <p>
        Firefox is one of the largest and most agressive open-source
        projects outside of the Linux kernel.
        It even spawned the (awesome) programming language, Rust.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Release_early,_release_often">Release Early, Release Often</a> - Wikipedia</li>
        <li><a href="https://blog.rust-lang.org/2014/10/30/Stability.html"> Stability as a Deliverable | Rust Blog</a></li>
        <li><a href="http://thinking-in-code.blogspot.com/2010/07/train-model-of-software-development.html"> Thinking in Code: Train Model of Software Development</a></li>
    </ul>
</div>

<div class="content" id="less">
    <h2 style="margin-bottom: 0;"><code>less</code>:</h2>
    <h4>A Success Story</h4>

    <p>
        A <em>paging utility</em> is a program that displays a file on 
        the terminal one screenful at a time.
        The first widely used paging utility was <code>more</code>, written by
        Dan Halbert as a graduate student at UC Berkley in 1978.<sup><a href="https://danhalbert.org/more.html">[aa]</a></sup>
        <code>more</code> is relatively simple: It first fills up the screen,
        then waits for user input to print the next line(s).
    </p>

    <p>
        In 1983, Mark Nudelman was a software developer working for a
        company called Integrated Office Systems. From the <a href="http://www.greenwoodsoftware.com/less/faq.html#history"><code>less</code> FAQ</a>:
    </p>

    <blockquote>
        Some of our software ran on a Unix system and produced enormous log files
        of its transactions. We wanted to be able to search these log files for
        error messages. But the version of "vi" we were using couldn't handle
        files larger than a certain size, and our log files often exceeded that
        size. So we were forced to use "more" to view the files. The problem was,
        once we found an error message, what we really wanted to see was the
        transactions leading up to the error; that is, the lines in the log file
        immediately before the error message. But more didn't allow backward
        movement in the file.
    </blockquote>

    <blockquote>
        We often complained about this problem. We said we needed a "backwards
        more"; someone (it wasn't me, but unfortunately I don't remember who
        it was) coined the name "less" as a joke on the concept of a "backwards
        more". It didn't seem to me that it would be too difficult to write a
        simple pager that would allow forward and backward movement.
        I wrote the first version in late 1983 and we began using it internally.
        I continued to enhance it and finally decided it was a useful enough
        tool that I should make it available to the world. I posted the first
        version to the newsgroup called (at that time) net.sources in May, 1985.
    </blockquote>

    <blockquote>
        Making the program publicly available allowed an enormous number of
        people to use it. Many people have made their own modifications and
        donated them to me for incorporation into the official version, and
        many more have reported bugs they've found or made suggestions about
        features they'd like to see added. This was my first experience with
        the concept of what is now called "open source" or "free software",
        and it has, I believe, produced a very high quality product. I'd like
        to thank all the users of less for their invaluable comments and
        suggestions over the years. 
        Less wouldn't be what it is today without you.
    </blockquote>

    <p>
        Mark Nudelman continues to maintain the project today.  
        It is, at the time of this writing, in its 581<sup>st</sup> 
        version.<sup><a href="http://www.greenwoodsoftware.com/less/faq.html#version">[q]</a></sup><sup><a href="http://www.greenwoodsoftware.com/less/index.html">[r]</a></sup>
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://fedoramagazine.org/5-cool-terminal-pagers-in-fedora/">5 cool terminal pagers in Fedora</a> - Fedora Magazine</li>
        <li><a href="https://zaiste.net/posts/shell-commands-rust/">Rewritten in Rust: Modern Alternatives of Command-Line Tools</a></li>
    </ul>
</div>

<div class="content" id="c">
    <h2>The C Programming Language</h2>

    <p>
        I know it looks like there's a bunch of programming languages
        out there, but there's really only one:
        The C programming language was invented by Dennis Ritchie and
        Ken Thompson.
        Then working on the PDP-11, they were the first working
        developers to create a language for their work.
    </p>

    <p>
        C has been called 'spartan', 'low-level', and
        'the lingua franca of computing':
        It presents the programmer with an unabated view
        of the process's environment.
        It is a high-level programming language that 
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Rust is pretty good, too.
        </p>
    </div>

    <p>
        No metadata is stored alongside this unit of memory, and, 
        each byte may be interpretted in a variety of ways. 
        Without getting into specifics, most interpretations reflect numbers;
        for the purposes of lightening your wallet, these interpretation, 
        and elementary operations on them, are supported by hardware natively.
    </p>
       
    <p>
        A <em>pointer</em> is a variable that holds an address.
        A pointer may point to any memory location in the program.
        In C, a pointer may point to an integer, a character, or any other
        <em>typed</em> memory location.
        Accessing that memory is called <em>dereferencing</em> the pointer;
        naturally, many pointers may refer to the same location in memory.
    </p>

    <p>
        
    </p>
</div>


<div id="references" class="content">
    <h2> References </h2>
    <ol>
        <li> Required Knowledge - OSDev Wiki. (2020, January 22). Retrieved July 29, 2020, from <a href="https://wiki.osdev.org/Required_Knowledge">https://wiki.osdev.org/Required_Knowledge</a></li>
        <li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
        <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
        <li> Blandy, J. (n.d.). Rust and Bitter C++ Developers with Jim Blandy [Interview by A. G. Bell]. Corecursive. Retrieved July 29, 2020, from https://corecursive.com/013-rust-and-bitter-c-developers-with-jim-blandy/.</li>
        <li> Cantrill, B. (2018). <i>Is It Time to Rewrite the Operating System in Rust?</i>. Lecture presented at QCon, San Francisco, 2018.</li>
        <li>Turon, A., &amp; Matsakis, N. (2014, October 30).  Stability as a Deliverable:  Rust Blog.  Retrieved August 18, 2020, from
            <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">https://blog.rust-lang.org/2014/10/30/Stability.html</a></li>
        <li> The Firefox release process. (n.d.). Retrieved August 18, 2020, from <a href="https://wiki.mozilla.org/Release_Management/Release_Process">https://wiki.mozilla.org/Release_Management/Release_Process</a></li>
    </ol>
</div>
