---
layout: default
title: Terminals and Shells
last-updated: November, 2020
---

<!--
To Do:
    Shells: 
        Builtin vs. program
    Standard File Descriptors:
        Include redirection
    Scripting
        Possibly:
            EOF and EOF character
-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
		<li><a href="#history"> History </a></li>
		<li><a href="#terminal-emulators"> Terminal Emulators </a></li>
		<li><a href="#shells"> Shells </a></li>
        <li><a href="#decomposing-lines">Decomposing Lines</a></li>
        <li><a href="#searching-for-commands">Searching for Commands</a></li>
		<li><a href="#standard-file-descriptors"> Standard File Descriptors </a></li>
		<li><a href="#shell-globbing"> Globbing </a></li>
		<li><a href="#shell-features"> Other Shell Features </a></li>
		<li><a href="#missing-semester"> Missing Semester </a></li>
		<li><a href="#references"> References </a></li>
	</ul>
</div>

<div id="introduction" class="content">
	<h1> Terminals and Shells</h1>
	<h4>Under Construction! </h4>
	<p>
		Unix was born in the years immediately following punch-card
		machines.
		At the time, the preferred interface for users was the <a href="./text-terminals.html">physical terminal</a>.
		Although physical terminals are antiquated, the idea persists in
		modern contexts because it is a very good low-level interface to the machine:
		It is often used by developers and system administrators to quickly get things done.
	</p>
</div>

<div id="history" class="content">
	<h2 style="margin-bottom: 2pt;">History:</h2>
	<h4>Physical Terminals</h4>

	<p>
		A <i>physical terminal</i> is a computer peripheral similar to a typewriter.
		The earliest examples printed output onto paper;
		this technology was carried over from the
		<a href="https://mysite.du.edu/~jcalvert/tel/teletype.htm"<i>teletypewriter</i></a>,
		a device for sending telegrams.
		Paper-based terminals persisted well into the 1970's, and later electronic typewriters
		<a href="https://www.youtube.com/watch?v=z-u4kUeIqDI">sometimes support terminal mode,</a>
		allowing them to interface with computers via serial cable.
	</p>

	<center>
		<a title="Peter Hamer, CC BY-SA 2.0 &lt;https://creativecommons.org/licenses/by-sa/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ken_Thompson_(sitting)_and_Dennis_Ritchie_at_PDP-11_(2876612463).jpg"><img width="1024" alt="Ken Thompson (sitting) and Dennis Ritchie at PDP-11 (2876612463)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg/1024px-Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg"></a>
		Ken Thompson (sitting) and Dennis Ritchie at PDP-11 in the "UNIX Room" of Bell Labs
	</center>

	<p>
		As technology developed and interactive computing became more popular,
		hard-copy terminals were phased out in favor of
		screen-based entities.
		The resulting devices consisted of a monitor and keyboard.
		The monitor was unlike a modern monitor in that it contained a buffer
		(on the order of a few kilobytes<sup><a href=#references>[3]</a></sup>)
		which maintained the text currently on screen.
		In addition, it contained a font table to be referenced
		when drawing each character&mdash; that is, it included its own font.
	</p>

	<p>
		Physical terminals <a href="https://www.vt100.net/dec/vt_history">were used for decades,</a>
		especially in situations demanding multiple access to large databases, such
		as airlines and libraries.
		In such a situation, the computational infrastructure forms a tree,
		with the system's administrators at the root, end-users at 
        the leaves.
	</p>

	<h3>See Also:</h3>
	<ul>
		<li><a href="https://youtu.be/RuZUPpmXfT0">DEC VT320: The Classic 1987 Library Computer Terminal</a> by LGR (Youtube Video)</li>
	</ul>

</div>

<div id="terminal-emulators" class="content">
	<h2> Terminal Emulators </h2>
	<p>
		Terminals persist on modern hardware in the form of <i>terminal emulators</i>.
		These are user-space processes that, well, emulate an old terminal!
		Specifically, it is a program that runs within the context of a desktop environment,
		and emulates the functionality of a physical terminal.
	</p>


	<figure>
		<img src="assets/img/gnome-terminal.png">
		<figcaption><center>GNOME Terminal Emulator</center></figcaption>
	</figure>

	<p>
		Some modern terminal emulators:
	</p>

	<p>
		<ul style="list-style: none;">
			<li> <a href="https://wiki.gnome.org/Apps/Terminal">GNOME Terminal</a>&mdash; A terminal emulator for GNOME. Common</li>
			<li> <a href="https://invisible-island.net/xterm/xterm.faq.html">xterm</a>&mdash; A terminal emulator for the X Window System.  Common, old, stable</li>
			<li> <a href="https://github.com/alacritty/alacritty "> alacritty</a>&mdash; A GPU-accelerated terminal emulator, written in Rust </li>
			<li> <a href="https://github.com/GitSquared/edex-ui#screenshots">edex-ui</a>&mdash; A terminal emulator designed to make you look <i>insanely badass</i> </li>
		</ul>
	</p>

	<div class="aside-right">
		<h4>Aside:</h4>
		<p>
			The files we are interested in are <code>/dev/pts/*</code>
		</p>
	</div>

	<p>
		These emulators are "dumb" in the sense that they do nothing except
		display text and return text.
		Per tradition, the Unix environment presents these connections as files.
		Since they are emulating a device, we can expect to find them in
		<code>/dev</code>.
	</p>

	<p>
		Terminal emulation can become quite involved;
		for this introduction, and for most purposes, it is sufficient to recognize that
		terminals and shells are distinct, cooperating processes.
	</p>

</div>

<div id="shells" class="content">
	<h2> Shells </h2>

    <div class="aside-right">
		<h4>Aside:</h4>
		<p>
		    Desktop environment serve a role analogous to shells.
		<p>
	</div>

	<p>
		A shell is a program which interprets and executes our (arbitrary) commands;
		it is a <em>shell</em> in the sense that it is the outermost layer of the
		operating system, and the one which the user has direct contact.
		Unix deviates from most operating systems designs by entertaining
		the shell as an ordinary user-space process:  From a software
		architecture standpoint, it is just another running program.
	</p>

	<p>
		Some modern shells:
	</p>

	<ul style="list-style: none;">
		<li><a href="https://www.gnu.org/software/bash/">bash</a>&mdash; A GNU Production; the standard shell</li>
		<li><a href="http://zsh.sourceforge.net/">zsh</a>&mdash; A shell designed for interactive use</li>
		<li><a href="https://fishshell.com/">fish</a>&mdash; The Friendly Interactive Shell</li>
	</ul>

    <p>
        Learning to use a shell amounts to learning how it handles
        each command given to it.  
        Here we'll study <code>bash</code>, but note that other shells
        in Linux operate similarly.
    </p>

    <h3>Commands and Builtin's</h3>

    <p>
        Most commands that users enter into <code>bash</code> are separate programs.
        For instance, when a user enters,
    </p>

    <div class="code">
        $ ls
    </div>

    <p>
        the shell finds the <code>ls(1)</code> executable, forks itself, and
        instructs the child process to execute that binary. 
        The <code>ls</code> program then reads its current directory's
        entries and prints them out.
        The shell 
        <a href="https://man7.org/linux/man-pages/man2/wait.2.html">waits</a>
        until <code>ls</code> terminates, then returns with a prompt.
        This happens very quickly.
    </p>

     <div class="aside-right">
        <h4>Alternative:</h4>
        <p>
            <code><a href="https://the.exa.website"</a>exa</a></code>
            is a modern replacement for <code>ls</code>.
        </p>
    </div>

    <p>
        While this strategy is certainly preferrable, there are times 
        where it will not work.
        For instance, changing the current directory must be carried out 
        by <code>bash</code> itself, since it is a per-process attribute.
        Therefore, <code>cd</code> is carried out by <code>bash</code>.
    </p>

    <p>
        Commands such as these are called <em>builtins</em>, and can be
        listed by,
    </p>

    <div class="code">
        $ help
    </div>

    <p>
        Where <code>help</code> is, itself, a builtin.
    </p>


</div>

<div class="content" id="decomposing-lines">
    <h2 style="margin-bottom: 0;">Decomposing Lines</h2>
    <h4>aka "Parsing"</h4>

</div>

<div class="content" id="searching-for-commands">
    <h2>Searching for Commands</h2>
</div>


<div id="standard-file-descriptors" class="content">
	<h2> The Standard File Descriptors </h2>
	<p>
        In interactive use, <code>bash</code> is connected to its terminal
        by open files.  
        The first file, represented within <code>bash</code> as 
        <a href="processes.html#file-descriptors">file descriptor <em>0</em></a>,
        is the keyboard:
        Writing to it is not permitted, and reading from it amounts to
        waiting for the next line of input.
        The second file, file descriptor <em>1</em>, is the terminal
        screen: Reading from it is not permitted, and anything written to it
        is printed on screen.
    </p>

    <p>
	    Recall that each process created by the <code>fork(2)</code> system
        call <a href="processes.html#process-creation">inherits</a> 
        its parent's attributes, and that these attributes
        include file descriptors.
        This implies that each fork of <code>bash</code> will have a 
        keyboard present at file descriptor zero, and a terminal screen
        at file descriptor one.
	</p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Can you do it?
            Yes you can!
        </p>
    </div>

    <p>
        This spawned the convention of <em>Standard file descriptors</em>:
        Descriptors 0, 1 and 2 are referred to as 
        <code>STDIN</code>,
        <code>STDOUT</code>,
        and <code>STDERR</code>, respectively.
        By this convention, writing an <code>ls</code> clone becomes simple:
        For each <a href="https://www.man7.org/linux/man-pages/man3/readdir.3.html">entry</a> in the current directory, <a href="https://man7.org/linux/man-pages/man3/printf.3.html">print</a> it out!
    </p>


    <p>
        Standard error (<code>STDERR</code>) is the same
        terminal screen as <code>STDOUT</code>, but is reserved for
        errors, logs and other red-letter messages.
        In a moment, we'll see why this is useful.
    </p>


    <h3> Redirection </h3>
</div>



	<div id="special-characters" class="content">
		<h2>Special Characters</h2>

		<p>
			Terminal special characters are like escape sequences, but in the other
			direction.  They are key-combinations typed at the keyboard
			which are interpreted by the terminal driver and mapped to special
			actions.
			There are sixteen commonly mapped terminal special characters;<sup><a href="#references">[15]</a></sup>
			most of them can be remapped by manipulating the <code>termios</code> struct.
			Here are a few:
		</p>

		<ul>
			<li>CTRL-C&mdash; Send the interrupt signal, <code>SIGINT</code>, to the foreground process. This is the principal
				means of terminating an unresponsive process.</li>
				<li>CTRL-D&mdash; Write the End-of-File character, <code>EOF</code>, to
					standard-in of the foreground process.  This will terminate a Bash session,
					for instance, or an interactive Python session.</li>
					<li>CTRL-S&mdash; "<code>STOP</code>" Upon receiving this character combination, the terminal
						driver stops, and attempts to store, all data to and from the terminal.
						This can make it appear as though the terminal has frozen.</li>
						<li>CTRL-Q&mdash; "<code>START</code>" Restart terminal input and output.
							If input or output is queued, the terminal driver will send it first, then resume normal operation.</li>
						</ul>

						<p>
							<em>Start</em> and <em>Stop</em> were more useful in times' past: The effect was to pause scrolling.
							In addition, the bell character was traditionally sounded when output was stopped and the terminal
							line discipline's buffer became full, thereby warning the user that data was being discarded.
							From the command prompt, we can list all bindings to special characters, in addition to other terminal attributes by,
						</p>

						<div class="code">
							$ stty -a
						</div>

						<p>
							Hope you enjoyed this&mdash; more to come!
						</p>
					</div>

					<div id="escape_sequences" class="content">
						<h2> Escape Sequences </h2>
						<p>
							It's worth repeating at this point that the terminal <i>proper</i> only sends a stream of bytes, and
							merely receives a stream of bytes.
							That is, the only method of sending data to a terminal monitor is by the same channel as
							printable characters.
							As a consequence, it is necessary to establish some common standard for communicating to the terminal
							non-printable, or <i>control</i>, characters, such as "newline."
							In the US, printable characters were traditionally mapped via ASCII (with the exception of <a href="https://en.wikipedia.org/wiki/EBCDIC"> some early IBM mainframes</a>).
							The first 32 ASCII characters (decimal 0 through 31) are control characters, rather than printable.
							They include the famous bell character, and both tab and newline (aka, "linefeed");
							in order to delete previously written text, one can print the backspace
							character, decimal 8 (see <a href="http://man7.org/linux/man-pages/man7/ascii.7.html"> man ascii </a> for more information).
						</p>

						<p>
							Most of these control characters quickly became antiquated, so that the majority are not widely used.
							For instance, ASCII alone does not provide provisions for moving the cursor or scrolling.
							As a consequence, the more extensible mechanism of <a href="https://en.wikipedia.org/wiki/Escape_sequence">escape sequences</a> was developed.
							The sequences in use were soon standardized by ANSI, and their support became ubiquitous.
							Each of these sequences begins with the ASCII "escape" control character (decimal 27)
							and the left-bracket "<code>[</code>" printable<sup><a href="#references">[13]</a></sup>.
							They are sequences of entirely ASCII characters.
							Technically, the're terminal-specific, but are still viable today
							because modern emulators typically
							<a href="https://unix.stackexchange.com/questions/43945/whats-the-difference-between-various-term-variables">implement a superset</a>
							of older terminals' escape sequences.
							Within C, to print <i>Hello World!</i> in reverse, we could do
						</p>

						<div class="code">
							#include &lt;stdio.h&gt;<br>
							<br>
							int main() {<br>
								&emsp;&emsp;&emsp;&emsp;printf("\033[7m Hello World! \033[m"); <br>
							}<br>
						</div>

						<p>
							So, by merely printing a special sequence through stdout to the terminal, we have
							modified the state of the recipient terminal.
							A few notes:
						</p>

						<ol>
							<li> <code>033</code> above is octal format, with decimal equivalent 27. </li>
							<li> This "setting" is persistent (try omitting the trailing <code>\033[m</code> ) </li>
							<li> To send an escape sequence from the keyboard, type CTRL+V, then ESC.  You should see <code>^[</code></li>
							<li> Why can't you just type <code>^[</code>?  <a href="http://unixwiz.net/techtips/termios-vmin-vtime.html"> Don't ask.</a> </li>
						</ol>


						<p>
							<a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php"> There are often dozens of such escaped sequences</a>,
							including such novelties as "set smooth scroll"; most real terminals can even change fonts.
							Some escape sequences may take parameters such as coordinates.
							In this case, the parameters
							<a href="http://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html#ss8.3">become part of</a> the escape sequence.
						</p>

					</div>

					<div class="content" id="missing-semester">
						<h2 style="margin-bottom: 2pt;">Missing Semester</h2>
						<h4 style="margin-bottom: 18pt;">Lecture 1: Course Overview + The Shell (2020)</h4>
						<iframe class="video" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
					</div>

					<div id="references" class="content">
						<h2> References </h2>
						<ol>
							<li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
							<li> Libes, Sol.  <i>Small Computer Systems Handbook</i>.  Published 1978, by Hayden Book Co. </li>
							<li> Lawyer, David S. <i>Text-Terminal-HOWTO</i> <a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO.html#toc1"> https://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html</a>.  The Linux Documentation Project.  Retrieved April 6, 2020. </li>
							<li> Shuford, Richard S. <a href="https://invisible-mirror.net/archives/shuford/terminal/first_principles.html"><i>First Thoughts about Terminal Emulation</i></a>. </li>
							<li> Ben-Halim, Zeyd M., Raymond, Eric S., Dickey, Thomas E. <a href="http://man7.org/linux/man-pages/man5/terminfo.5.html">man 5 terminfo</a>.  The Linux Man-Pages Project. Retrieved April 6, 2020.</li>
							<li> Dickey, Thomas E.  <a href="https://invisible-island.net/xterm/xterm.faq.html#what_is_vt220"><i>"What is a VT220?"</i></a>. Retrieved April 6, 2020.</li>
							<li> <a href="http://man7.org/linux/man-pages/man7/boot.7.html">man 7 boot</a>. The Linux Man-Pages Project. Written March 11, 2015.</li>
							<li> <a href="http://man7.org/linux/man-pages/man7/bootup.7.html">man 7 bootup</a>. The Linux Man-Pages Project.</li>
							<li> <a href="https://askubuntu.com/questions/27339/what-is-tty7-in-the-commandline">"What is tty7 in the command line?"</a>.  AskUbuntu question, posed by Fusky.</li>
							<li> <a href="http://man7.org/linux/man-pages/man4/tty.4.html">man 4 tty</a>. The Linux Man-Pages Project. Published March 6, 2019.</li>
							<li> <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/Kconfig?id=HEAD">Kernel Driver Source</a>.  Maintained by Linux Torvalds.</li>
							<li> <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html">The Kernel Administrators Guide; Linux Allocated Devices</a>. </li>
							<li> <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php">ANSI Escape Sequences</a>. ASCII-Table.com.  Retrieved April 6, 2020.</li>
							<li> <a href="https://linux.die.net/man/7/x"> man 7 x </a>.  Written by X.Org Foundation, LLC.  Hosted by die.net hosting.</li>
							<li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
						</ol>
					</div>
