---
layout: default
title: Terminals and Shells
last-updated: March, 2021
---

<!--
To Do:

    Shells:
    You can think of them as a view into the machine.

    <p>
        Learning to use a shell amounts to learning how it handles
        commands given to it, so buddy up to your favorite shell's
        reference manual!
    </p>

    Command Execution: (Need rather badly, before cwd)

    Bash Command Interpretation Cheat Sheet

    Simple Commands Definition:

    https://www.gnu.org/software/bash/manual/html_node/Simple-Commands.html#Simple-Commands

    Standard File Descriptors:
        Include redirection

        <div class="code">
        $ <i>command</i> [arg] ... [redirection] ...
    </div>

    <p>
        The above is the definition of a <em>simple command</em>
        in GNU <code>bash</code>.
        It effectively forms a unit in our command-line language.
    </p>

    Closing Remarks:
        Text Editors

<div class="content" id="closing-remarks">
    <h2>Closing Remarks</h2>

    <p>
        Different operating systems have their own idioms for the command line.
        Being a UNIX-like operating system, GNU/Linux has inheritted
        those of UNIX.
    </p>

    <p>
        A simple command has the form,
    </p>

    <div class="code">
        $ <i>command</i> [arg] ...
    </div>

    <p>
        I draw your attention to the <em>arguments</em> list:
        An argument may either be a sub-command, or an option.
        An option is prefixed with either <code>-</code> (short option)
        or <code>- -</code> (long option).
        A sub-command is not prefixed with either.
    </p>

    <p>
        For example,
    </p>

    <div class="code">
        $ git clone https://
    </div>

    <p>
        and
    </p>

    <div class="code">
        $ cargo build
    </div>

    <p>
        both contain subcommands, whereas
    </p>

    <div class="code">
        $ ls -F
    </div>

    <p>
        contains an option.
    </p>

    <p>
        This convention is not strictly adhered to, but is worthwhile.
        Formally:
    </p>

    <div class="code">
         $ <i>command</i> [subcommand] [[option] ... [file] ...] [redirection] ...
    </div>
</div>


<div class="content" id="setup-files">
    <h2>Bash Configuration Scripts</h2>

</div>

<p>
        IN THE BEGINNING, the shell operated in a simple loop involving an <em>exec</em>
        call to itself.<sup><a href="https://www.bell-labs.com/usr/dmr/www/hist.html">[1]</a></sup>
        SINCE THE BEGINNING, times have been good, and bearded UNIX hackers
        have been productive.
        In particular, per-user multiprocessing, and the <code>fork()</code> system call, have been introduced.
    </p>


-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
		<li><a href="#physical-terminals"> Physical Terminals </a></li>
		<li><a href="#terminal-emulators"> Terminal Emulators </a></li>
		<li><a href="#shells"> Shells </a></li>
        <li><a href="#simple-commands">Simple Commands</a></li>
        <li><a href="#pwd">Working Directory</a></li>
        <!--<li><a href="#path">PATH </a></li>-->
		<li><a href="#missing-semester"> Missing Semester </a></li>
		<li><a href="#references"> References </a></li>
	</ul>
</div>

<div id="introduction" class="content">
	<h1> Terminals and Shells</h1>

    <div class="quote-text">
        "In effect, tools are verbs in a language, <br>
		and files are the nouns that the verbs apply to."
    </div>

    <div class="quote-ref">
        Brian Kernighan<br>
        UNIX: A History and a Memoir
    </div>

    </div>

<div id="physical-terminals" class="content">
	<h2 style="margin-bottom: 2pt;">Physical Terminals</h2>
	<h4>A Brief History</h4>

	<p>
		A <i>physical terminal</i> was a computer peripheral similar to a typewriter.
		The earliest examples printed output onto paper;
		this technology was carried over from the
		<a href="https://mysite.du.edu/~jcalvert/tel/teletype.htm"<i>teletypewriter</i></a>,
		a device for sending telegrams.
		Paper-based terminals persisted well into the 1970's, and later
        electronic typewriters sometimes supported terminal mode,
		allowing them to interface with computers via serial cable.
	</p>

	<center>
		<a title="Peter Hamer, CC BY-SA 2.0 &lt;https://creativecommons.org/licenses/by-sa/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ken_Thompson_(sitting)_and_Dennis_Ritchie_at_PDP-11_(2876612463).jpg"><img width="1024" alt="Ken Thompson (sitting) and Dennis Ritchie at PDP-11 (2876612463)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg/1024px-Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg"></a>
		Ken Thompson (sitting) and Dennis Ritchie at PDP-11 in the "UNIX Room" of Bell Labs
	</center>

	<p>
		As technology developed and interactive computing became more popular,
		hard-copy terminals were phased out in favor of
		screen-based entities.
		The resulting devices consisted of a monitor and keyboard.
		The monitor was unlike a modern monitor in that it contained a buffer
        (on the order of a few kilobytes<sup><a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO-1.html#ss1.6">[2]</a></sup>)
		which maintained the text currently on screen.
		In addition, it contained a font table to be referenced
		when drawing each character&mdash; that is, it included its own font.
	</p>

	<p>
		Physical terminals <a href="https://www.vt100.net/dec/vt_history">were used for decades,</a>
		especially in situations demanding multiple access to large databases, such
		as airlines and libraries.
		In such situations, the computational infrastructure forms a tree,
		with the system's administrators at the root, and end-users at
        the leaves.
	</p>

	<h3>See Also:</h3>
	<ul>
		<li><a href="https://youtu.be/RuZUPpmXfT0">DEC VT320: The Classic 1987 Library Computer Terminal</a> by LGR (Youtube Video)</li>
	</ul>
</div>

<div id="terminal-emulators" class="content">
	<h2> Terminal Emulators </h2>
	<p>
		Terminals persist on modern hardware in the form of <i>terminal emulators</i>.
		These are user-space processes that, well, emulate an old terminal!
		Specifically, it is a program that runs within the context of a desktop environment,
		and emulates the functionality of a physical terminal.
	</p>

	<figure>
		<img src="assets/img/gnome-terminal.png">
		<figcaption><center>GNOME Terminal Emulator</center></figcaption>
	</figure>

	<p>
		Some modern terminal emulators:
	</p>

	<p>
		<ul style="list-style: none;">
			<li> <a href="https://wiki.gnome.org/Apps/Terminal">GNOME Terminal</a>&mdash; A terminal emulator for GNOME. Common</li>
			<li> <a href="https://invisible-island.net/xterm/xterm.faq.html">xterm</a>&mdash; A terminal emulator for the X Window System.  Common, old, stable</li>
			<li> <a href="https://github.com/alacritty/alacritty "> alacritty</a>&mdash; A GPU-accelerated terminal emulator, written in Rust </li>
			<li> <a href="https://github.com/GitSquared/edex-ui#screenshots">edex-ui</a>&mdash; A terminal emulator designed to make you look <i>insanely badass</i> </li>
            <li> <a href="https://hyper.is/">Hyper</a>&mdash; An <a href="https://www.electronjs.org/">Electron</a>-based terminal</li>
		</ul>
	</p>

	<div class="aside-right">
		<h4>Aside:</h4>
		<p>
			The files we are interested in are <code>/dev/pts/*</code>
		</p>
	</div>

	<p>
		These emulators are "dumb" in the sense that they do nothing except
		display text and return text.
		Per tradition, GNU/Linux presents terminal connections as files.
		Since they are emulating a device, we can expect to find them in
		<code>/dev</code>.
	</p>

	<p>
		Terminals can become quite involved; for this introduction, and for
        most purposes, it is sufficient to recognize that
		terminals and shells are distinct, cooperating processes.
	</p>
</div>

<div id="shells" class="content">
	<h2> Shells </h2>

    <div class="aside-right">
		<h4>Aside:</h4>
		<p>
		    <a href="https://itsfoss.com/what-is-desktop-environment/">
                Desktop environments</a>
            serve a role analogous to shells.
		<p>
	</div>

	<p>
		A shell is a program which interprets and executes our commands.
		It is a <em>shell</em> in the sense that it is the outermost layer of the
		operating system, and the one which the user has direct contact.
	</p>

    <p>
		The UNIX architecture entertains the shell as an ordinary user-space process:
        From its perspective, it is just another running program.
        This allows a single operating system to support many shells.
	</p>

	<p>
		Some modern shells:
	</p>

	<ul style="list-style: none;">
		<li><a href="https://www.gnu.org/software/bash/">Bash</a>&mdash; A GNU Production, pretty much the standard shell</li>
		<li><a href="http://zsh.sourceforge.net/">Zsh</a>&mdash; A shell "designed for interactive use; very similar to Bash.</li>
        <li><a href="https://www.nushell.sh/">Nushell</a>&mdash; An interactive shell, supporting piplines of structured data, in addition to simple text streams.</li>
        <li><a href="https://elv.sh/">Elvish</a>&mdash; an "expressive programming language and versatile interactive shell." Version 1.0 not yet released</a></li>
        <li><a href="https://xon.sh">Xonsh</a>&mdash; A Pythonic shell, written
            in Python.</li>
		<li><a href="https://fishshell.com/">fish</a>&mdash; The Friendly Interactive Shell</li>
	</ul>

    <p>
        A shell is launched for you when a terminal emulator window is opened:
    </p>

    <figure>
		<img src="assets/img/gnome-w-bash.png">
		<figcaption><center>GNOME Terminal Emulator running Bash</center></figcaption>
	</figure>

    <p>
        You can find out which shell is running
        by executing the <code>ps</code> command:
    </p>

    <figure>
		<img src="assets/img/gnome-w-bash-ps.png">
		<figcaption><center><code>ps</code> command, by default listing processes owned by this user, connected to this terminal </center></figcaption>
	</figure>

        <p>
        Finally, note that we will typically omit the picture of the terminal,
        so that the above command will be depicted:
    </p>

    <div class="code">
        $ ps <br>
        PID &ensp;TTY   &emsp;&emsp;&emsp;&emsp;&emsp;TIME CMD <br>
        3142 pts/1   00:00:00 bash <br>
        3148 pts/1   00:00:00 ps
    </div>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://ubuntu.com/tutorials/command-line-for-beginners#1-overview">The Linux Command Line for Beginners</a> - Ubuntu </li>
    </ul>
</div>

<div class="content" id="simple-commands">
    <h2>Simple Commands</h2>

    <p>
        A <em>simple command</em> is a command of the form:
    </p>

    <div class="code">
        $ <i>command</i> [arg ...]
    </div>

    <p>
        Where <code>command</code> is mandatory and arguments are optional.
    </p>

    <p>
        Commands given to shells are almost always separate programs;
        in fact, it is unusual for a command to be built in to the shell.
    </p>
</div>

<div class="content" id="execution">
	<h2>Command Execution</h2>

    <p>
        Most, but not all, commands given to the shell exist as separate
        programs.
    </p>
        
	<a href="assets/img/shell-model.pdf" title="Click for PDF">
		<img src="assets/img/shell-model-pic.png" style="height: 400pt;">
	</a>


    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Operation.html">Shell Operation (Bash Reference Manual)</a></li>
    </ul>
</div>

<div class="content" id="pwd">
    <h2>Working Directory</h2>



    <p>
        Recall that each process has a <a href="/processes.html#process-attributes">current working directory</a>.
        Since the shell is a process, naturally, it too has a current working directory.
        At the command line, this is of particular importance:
        It reflects <em>where you are</em> in the directory tree.
    </p>

    <p>
        The shell's current working directory may be printed with the 
        command <code>pwd</code>:
    </p>

    <div class="code">
        $ pwd<br>
        /home/josh
    </div>

    <p>
        Its value may be changed with <code>cd</code>:
    </p>

    <div class="code">
        $ cd Public<br>
        $ pwd<br>
        /home/josh/Public
    </div>

    <p>
        In Ancient UNIX, <em>change directories</em> was implemented
        as a separate command.
        When invoked, it inherited the shell's current working directory,
        changed it, and then the shell would inherit <em>that</em> working directory.
        With the inclusion of the <em>fork()</em> system call, though, 
        the <code>chdir</code> command broke:
    </p>

    <!--
        Justification: https://qmacro.org/2020/11/08/the-meaning-of-pwd-in-unix-systems/
    -->

    <p>

    <blockquote>
        "There was much reading of code and anxious introspection about how 
        the addition of fork could have broken the chdir call. Finally the 
        truth dawned: in the old system chdir was an ordinary command; it 
        adjusted the current directory of the (unique) process attached to
        the terminal. Under the new system, the chdir command correctly 
        changed the current directory of the process created to execute it, 
        but this process promptly terminated and had no effect whatsoever on 
        its parent shell! It was necessary to make chdir a special command,
        executed internally within the shell. It turns out that several 
        command-like functions have the same property, for example login."
    </blockquote>

    <div class="quote-ref">
        &mdash;Dennis M. Ritchie<br>
        <a href="https://www.bell-labs.com/usr/dmr/www/hist.html">The Evolution of the Unix Timesharing System</a><br>
    </div>

    <p>
        The <code>cd</code> command is also, necessarily, built in to the shell.
        Commands such as these are today called <em>builtins</em>, and can be investigated by:
    </p>

    <div class="code">
        $ help
    </div>

</div>

<div class="content" id="path">
    <h2><code>PATH</code> Environment Variable</h2>

    <!--
        Kernighan page 132:
            Invented by John Mashey and introduced in the 6th edition shell,
            it was a workaround so that non-expert users could
            share their own sets of commands by lab, department and group.
    -->

    <p>
        Bash, being a process, has environment variables.  
        Of these variables, <code>PATH</code> is the most important:
        It contains a list of directories to be searched when looking for
        a command.
        This list is colon (<code>:</code>) -separated, and may look like,
    </p>

    <div class="code">
        $ echo $PATH<br>
        /usr/bin:/bin:/home/josh/.local/bin
    </div>

    <p>
        Bash searches each directory in this list from left to right, 
        for a file whose name matches the command given. 
        It executes the first found, and then abandons its search.
    </p>

    <p>
        Some caveats apply:
        If the command is a builtin, Bash will execute the builtin, and ignore
        <code>PATH</code>.
        More, Bash does <em>not</em> search the current working directory for a command.
    </p>

    <p>
        We can overrule both of these behaviors by including a 
        forward-slash <code>/</code> in our command, typically:
    </p>

    <div class="code">
        $ ./<i>command</i>
    </div>

    <p>
        Appending locations to <code>PATH</code> is an important step of 
        setting up a development environment.
        This is typically done in <code>~/.bashrc</code>.
        The correct construct appends the directory
        only if it is not already present:
    </p>

    <div class="code">
        if [[ ! $PATH =~ $HOME/.local/bin ]]; then<br>
        &emsp;&emsp;&emsp;&emsp;PATH=$PATH:$HOME/.local/bin<br>
        fi
    </div>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Environment_variable#True_environment_variables"> Environment Variables </a> - Wikipedia</li>
    </ul>

</div>

<div class="content" id="missing-semester">
	<h2 style="margin-bottom: 2pt;">Missing Semester</h2>
	<h4 style="margin-bottom: 18pt;">Lecture 1: Course Overview + The Shell (2020)</h4>
	<iframe class="video" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<!--
<div class="content" id="exercises">
    <h2>Exercises:</h2>

    <ol style="margin-left: 0;">
        <li>
            <p>
                Terminal emulators are also processes.  From the command line, find
                your emulator's working directory.
            </p>
        </li>
        <li>
            <p>
                What is the difference between <code>type</code> and <code>which</code>?
            </p>
        </li>
        <li>
            <p>
                Why <em>shouldn't</em> you append <code>.</code> to PATH?
            </p>
        </li>
        <li>
            <p>
                Scripting exercise:
                Use constructs other than <code>if</code> to append a location
                to path.
            </p>
        </li>
    </ol>
</div>
-->

<div id="references" class="content">
	<h2> References </h2>
	<ol>
        <li>Ritchie, D. M. (1984). The Evolution of the Unix Time-sharing System. <em>AT&amp;T Bell Laboratories Technical Journal,</em> 63(6), 2nd ser., 1577-1593.</li>
		<li> Lawyer, David S. <i>Text-Terminal-HOWTO</i> <a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO-1.html#ss1.6"> https://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html</a>.  The Linux Documentation Project.  Retrieved April 6, 2020. </li>

	</ol>
</div>


<!--
		<li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
		<li> Libes, Sol.  <i>Small Computer Systems Handbook</i>.  Published 1978, by Hayden Book Co. </li>
		<li> Shuford, Richard S. <a href="https://invisible-mirror.net/archives/shuford/terminal/first_principles.html"><i>First Thoughts about Terminal Emulation</i></a>. </li>
		<li> Ben-Halim, Zeyd M., Raymond, Eric S., Dickey, Thomas E. <a href="http://man7.org/linux/man-pages/man5/terminfo.5.html">man 5 terminfo</a>.  The Linux Man-Pages Project. Retrieved April 6, 2020.</li>
		<li> Dickey, Thomas E.  <a href="https://invisible-island.net/xterm/xterm.faq.html#what_is_vt220"><i>"What is a VT220?"</i></a>. Retrieved April 6, 2020.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/boot.7.html">man 7 boot</a>. The Linux Man-Pages Project. Written March 11, 2015.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/bootup.7.html">man 7 bootup</a>. The Linux Man-Pages Project.</li>
		<li> <a href="https://askubuntu.com/questions/27339/what-is-tty7-in-the-commandline">"What is tty7 in the command line?"</a>.  AskUbuntu question, posed by Fusky.</li>
		<li> <a href="http://man7.org/linux/man-pages/man4/tty.4.html">man 4 tty</a>. The Linux Man-Pages Project. Published March 6, 2019.</li>
		<li> <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/Kconfig?id=HEAD">Kernel Driver Source</a>.  Maintained by Linux Torvalds.</li>
		<li> <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html">The Kernel Administrators Guide; Linux Allocated Devices</a>. </li>
		<li> <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php">ANSI Escape Sequences</a>. ASCII-Table.com.  Retrieved April 6, 2020.</li>
		<li> <a href="https://linux.die.net/man/7/x"> man 7 x </a>.  Written by X.Org Foundation, LLC.  Hosted by die.net hosting.</li>
		<li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
-->
