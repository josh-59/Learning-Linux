---
layout: default
title: Terminals and Shells
last-updated: November, 2020
---

<!--
To Do:
        IN THE BEGINNING, the shell operated in a simple loop involving an <em>exec</em>
        call to itself.<sup><a href="https://www.bell-labs.com/usr/dmr/www/hist.html">[1]</a></sup>
        This is explained by a lack of multiprogramming support and goto statements.
        SINCE THE BEGINNING, times have been good, and bearded UNIX hackers 
        have been productive,
    </p>

    <p>
        This article introduces the command line, and is intended to serve as
        down-the-road documentation.
        It explains shell behavior chronologically with respect to command execution,
        but can be read piecewise.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://ubuntu.com/tutorials/command-line-for-beginners#1-overview">The Linux Command Line for Beginners</a> (Ubuntu Official Tutorial)</li>
    </ul>

    Terminal Pro:
        fork'ed == subshell environment
        $ type bash
        $ which bash
        $ file $(which bash)

    Shells:
    http://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf
 Today, the way in which commands are executed by the shell can be summarized as follows: 1) The shell reads a command line from the terminal. 2) It creates a child process by fork.3) The child process uses exec to call in the command from a file. 4) Meanwhile, the parent shell uses wait to wait for the child (command) process to terminate bycalling exit.5) The parent shell goes back to step 1)

    Bash Command Interpretation Cheat Sheet

    Standard File Descriptors:
        Include redirection
  <p>
        By this convention, writing an <code>ls</code> clone becomes simple:
        For each <a href="https://www.man7.org/linux/man-pages/man3/readdir.3.html">entry</a> in the current directory, <a href="https://man7.org/linux/man-pages/man3/printf.3.html">print</a> it out!
    </p>


    Single quotes: Allow newlines to be passed

    Basic Bash Grammar:
        Pipeline and Lists

    Shell scripting:
        https://medium.com/better-programming/the-ultimate-programmers-guide-to-bash-scripting-2d11d4e6e978       
        help for
        help if
        help [[

        https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html#index-parameters
        variable=[value]
            [value] undergoes tilde expansion, parameter and variable expansion, 
            command substitution, arithmetic expansion, and quote removal; 
            does not undergo filename expansion


    Closing Remarks:
    Text Editor: vim

    These controls have made their way into many other programs: man, git, less.
    In fact, even Firefox lets you 'Quick Search' a web page with <code>/</code>.
    Once you are (well) familiar with them, you can set Bash to vi-mode with
    <code>set -o vi</code>.

    Explanation of sudo:
    https://www.linuxjournal.com/sites/default/files/2018-11/GeekGuide-BeyondTrust-BeyondSudo.pdf


     Other Nice Features:
        Filename completion via tab 
            - Filename list via tab
        Command completion via tab
            - Command list via tab

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>

            Most shells support <em>tab completion:</em>
            If you've typed enough of a command-name or filename to
            uniquely identify it, you can press "tab," and it will complete it for you.
        </p>
    </div>

    Terminal screensavers
    https://gitlab.com/jallbrit/cbonsai/-/tree/master

-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
		<li><a href="#physical-terminals"> Physical Terminals </a></li>
		<li><a href="#terminal-emulators"> Terminal Emulators </a></li>
		<li><a href="#shells"> Shells </a></li>
        <li><a href="#simple-commands">Simple Commands</a></li>
        <li><a href="#shell-expansion">Shell Expansion</a></li>
		<li><a href="#redirection">I/O Redirection</a></li>
        <li><a href="#searching-for-commands">Searching for Commands</a></li>
		
		<!--
		<li><a href="#shell-features"> Other Shell Features </a></li>
        <li><a href="#special-characters">Terminal Special Characters</a></li>
        -->
		<li><a href="#missing-semester"> Missing Semester </a></li>
		<li><a href="#references"> References </a></li>
	</ul>
</div>

<div id="introduction" class="content">
	<h1> Terminals and Shells</h1>
	<h4>Under Construction! </h4>
	<p>
	</p>
</div>

<div id="physical-terminals" class="content">
	<h2 style="margin-bottom: 2pt;">Physical Terminals</h2>
	<h4>A Brief History</h4>

	<p>
		A <i>physical terminal</i> was a computer peripheral similar to a typewriter.
		The earliest examples printed output onto paper;
		this technology was carried over from the
		<a href="https://mysite.du.edu/~jcalvert/tel/teletype.htm"<i>teletypewriter</i></a>,
		a device for sending telegrams.
		Paper-based terminals persisted well into the 1970's, and later 
        electronic typewriters sometimes supported terminal mode,
		allowing them to interface with computers via serial cable.
	</p>

	<center>
		<a title="Peter Hamer, CC BY-SA 2.0 &lt;https://creativecommons.org/licenses/by-sa/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ken_Thompson_(sitting)_and_Dennis_Ritchie_at_PDP-11_(2876612463).jpg"><img width="1024" alt="Ken Thompson (sitting) and Dennis Ritchie at PDP-11 (2876612463)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg/1024px-Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg"></a>
		Ken Thompson (sitting) and Dennis Ritchie at PDP-11 in the "UNIX Room" of Bell Labs
	</center>

	<p>
		As technology developed and interactive computing became more popular,
		hard-copy terminals were phased out in favor of
		screen-based entities.
		The resulting devices consisted of a monitor and keyboard.
		The monitor was unlike a modern monitor in that it contained a buffer
		(on the order of a few kilobytes<sup><a href=#references>[3]</a></sup>)
		which maintained the text currently on screen.
		In addition, it contained a font table to be referenced
		when drawing each character&mdash; that is, it included its own font.
	</p>

	<p>
		Physical terminals <a href="https://www.vt100.net/dec/vt_history">were used for decades,</a>
		especially in situations demanding multiple access to large databases, such
		as airlines and libraries.
		In such situations, the computational infrastructure forms a tree,
		with the system's administrators at the root, and end-users at 
        the leaves.
	</p>

	<h3>See Also:</h3>
	<ul>
		<li><a href="https://youtu.be/RuZUPpmXfT0">DEC VT320: The Classic 1987 Library Computer Terminal</a> by LGR (Youtube Video)</li>
	</ul>

</div>

<div id="terminal-emulators" class="content">
	<h2> Terminal Emulators </h2>
	<p>
		Terminals persist on modern hardware in the form of <i>terminal emulators</i>.
		These are user-space processes that, well, emulate an old terminal!
		Specifically, it is a program that runs within the context of a desktop environment,
		and emulates the functionality of a physical terminal.
	</p>


	<figure>
		<img src="assets/img/gnome-terminal.png">
		<figcaption><center>GNOME Terminal Emulator</center></figcaption>
	</figure>

	<p>
		Some modern terminal emulators:
	</p>

	<p>
		<ul style="list-style: none;">
			<li> <a href="https://wiki.gnome.org/Apps/Terminal">GNOME Terminal</a>&mdash; A terminal emulator for GNOME. Common</li>
			<li> <a href="https://invisible-island.net/xterm/xterm.faq.html">xterm</a>&mdash; A terminal emulator for the X Window System.  Common, old, stable</li>
			<li> <a href="https://github.com/alacritty/alacritty "> alacritty</a>&mdash; A GPU-accelerated terminal emulator, written in Rust </li>
			<li> <a href="https://github.com/GitSquared/edex-ui#screenshots">edex-ui</a>&mdash; A terminal emulator designed to make you look <i>insanely badass</i> </li>
            <li> <a href="https://hyper.is/">Hyper</a>&mdash; An <a href="https://www.electronjs.org/">Electron</a>-based terminal</li>
		</ul>
	</p>

	<div class="aside-right">
		<h4>Aside:</h4>
		<p>
			The files we are interested in are <code>/dev/pts/*</code>
		</p>
	</div>

	<p>
		These emulators are "dumb" in the sense that they do nothing except
		display text and return text.
		Per tradition, GNU/Linux presents terminal connections as files.
		Since they are emulating a device, we can expect to find them in
		<code>/dev</code>.
	</p>

	<p>
		Terminals can become quite involved; for this introduction, and for 
        most purposes, it is sufficient to recognize that
		terminals and shells are distinct, cooperating processes.
	</p>
</div>

<div id="shells" class="content">
	<h2> Shells </h2>

    <div class="aside-right">
		<h4>Aside:</h4>
		<p>
		    <a href="https://itsfoss.com/what-is-desktop-environment/">
                Desktop environments</a>
            serve a role analogous to shells.
		<p>
	</div>

	<p>
		A shell is a program which interprets and executes our (arbitrary) commands.
		It is a <em>shell</em> in the sense that it is the outermost layer of the
		operating system, and the one which the user has direct contact.
	</p>

    <p>
		The UNIX architecture entertains the shell as an ordinary user-space process:  
        From the operating system's perspective, it is just another running program.
        This allows a single operating system to support many shells.
	</p>

	<p>
		Some modern shells:
	</p>

	<ul style="list-style: none;">
		<li><a href="https://www.gnu.org/software/bash/">Bash</a>&mdash; A GNU Production, pretty much the standard shell</li>
		<li><a href="http://zsh.sourceforge.net/">Zsh</a>&mdash; A shell designed for interactive use; very similar to Bash.</li>
        <li><a href="https://www.nushell.sh/">Nushell</a>&mdash; An interactive shell, supporting piplines of structured data, in addition to simple text streams.</li>
        <li><a href="https://elv.sh/">Elvish</a>&mdash; an "expressive programming language and versatile interactive shell." Version 1.0 not yet released</a></li>
        <li><a href="https://gitlab.redox-os.org/redox-os/ion">ion</a>&mdash; The default shell of <a href="https://www.redox-os.org/">RedoxOS</a>, works on Linux as well</li>
		<li><a href="https://fishshell.com/">fish</a>&mdash; The Friendly Interactive Shell</li>
	</ul>

    <p>
        A shell is launched for you when a terminal emulator window is opened:
    </p>

    <figure>
		<img src="assets/img/gnome-w-bash.png">
		<figcaption><center>GNOME Terminal Emulator running Bash</center></figcaption>
	</figure>

    <p>
        You can find out which shell is running 
        from within terminal with the <code>ps</code> command:
    </p>

    <figure>
		<img src="assets/img/gnome-w-bash-ps.png">
		<figcaption><center><code>ps</code> command, by default listing processes owned by this user, connected to this terminal </center></figcaption>
	</figure>

    <p>
        Learning to use a shell amounts to learning how it handles
        commands given to it.  
        Here we'll study <code>bash</code>, but other shells
        in Linux operate similarly.
    </p>

    <p>
        Finally, we will typically omit the picture of the terminal,
        so that the above command will normally be depicted:
    </p>

    <div class="code">
        $ ps <br>
        PID &ensp;TTY   &emsp;&emsp;&emsp;&emsp;&emsp;TIME CMD <br>
        3142 pts/1   00:00:00 bash <br>
        3148 pts/1   00:00:00 ps
    </div>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Operation.html">Shell Operation (Bash Reference Manual)</a></li>
    </ul>
   </div>

<div class="content" id="simple-commands">
    <h2 style="margin-bottom: 0;">Simple Commands</h2>
    <h4>and Word Splitting</h4>

    <p>
        A typical line of input given to the shell is as follows:
    </p>

    <div class="code">
        command [arg1 arg2 ...] 
    </div>

    <p>
        Where <em>command</em> is mandatory, and arguments are
        optional.
        In the following example, the <code>ls</code> command is given
        with the single argument <code>-l</code>:
    </p>

    <div class="code">
        $ ls -l
    </div>

    <p>
        Elements (referred to as "words") are separated by <a href="https://en.wikipedia.org/wiki/Whitespace_character">whitespace</a>.
        If, for some reason, we need to include whitespace in
        an argument, we can wrap said argument in single-quotes.
        There are a few ways to go about this, but 
        single quotes are most-used: 
        They tell Bash to preserve the text exactly as-is.
    </p>

    <p>
        For example, in the following command, 
        the <code>cd</code> command recieves a single argument,
        <code>Random Acccess Memories</code>: 
    </p>

    <div class="code">
        $ cd 'Random Access Memories'
    </div>

    <p>
        In Bash, breaking a line of input into its elements is 
        known as <em>word splitting</em>, 
        and is the first step of command interpretation.
    </p>

</div>

<div class="content" id="shell-expansion">
    <h2 style="margin-bottom: 0;">Shell Expansion</h2>
    <h4>and Quote Removal</h4>

    <p>
        The next step on the journey of command execution is <em>shell
        expansion.</em> 
        Bash searches each word, from left to right, in two consequetive passes.
        If a word is single-quoted, then it is exempt from expansion.
    </p>

    <p>
        The first pass searches for:
    </p>

    <ol>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html">Braces</a>&emsp; <code>{}</code>
            <br>
            <code>a{1,2,3}b</code> becomes <code>a1b a2b a3b</code>
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html">Tilde</a>&emsp;  <code>~</code>
            <br>
            Expands to the absolute pathname of your home directory, or 
            <code>HOME</code> parameter, if it is set.
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">Parameter</a> &emsp;  <code>$</code>
            <br>
            <code>$NAME</code> is replaced by the value of <code>NAME</code> 
            parameter, if it exists, and null string otherwise. 
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html">Command</a> &emsp;  <code>$( </code><em>command</em><code> )</code>
            <br>
            Executes <em>command</em> in a subshell environment, captures output
            and replaces <br> <code>$(</code><em>command</em><code>)</code>
            with said output
        </li>
        <li>
            <a href="https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html">Arithmetic</a>&emsp;  <code>$(( </code><em>expression</em><code>  ))</code>
            <br>
            Evaluates <em>expression</em> and replaces <code>$((</code><em>expression</em><code>))</code> with result

        </li>
    </ol>

    <p>
        Expansions can be understood through prodigious use of the
        <code>echo</code> command, which simply prints out whatever arguments
        it recieves.
        For instance, in the following example, the <code>echo</code> command
        recieves exactly two arguments, <code>12</code> and <code>13</code>,
        and it is the shell that has done the work:
    </p>

    <div class="code">
        $ echo 1{2,3}<br>
        12 13
    </div>

    <h3 id="globbing"> Filename Expansion </h3>

    <p>
        The second expansion pass is <em>filename expansion,</em> sometimes 
        referred to as <em>globbing.</em>
        These expansions let you manipulate multiple files quickly.
        If any word contains an asterisk <code>*</code>, question mark 
        <code>?</code>, or brackets <code>[]</code>, then it is regarded as a 
        <em>pattern,</em> and is replaced by an alphabetical list of all
        filenames in the current directory matching that pattern.
    </p>

    <p>
        The meanings of these metacharacters are as follows:
    </p>

    <ul style="list-style-type: none;">
        <li>
            <code>*</code>&emsp; Asterisk.  Matches zero-or-more of any character.
        </li>

        <li>
            <code>?</code>&emsp; Question Mark.  Matches zero-or-one of any character.
        </li>

        <li>
            <code>[ ]</code>&emsp; Brackets.  Matches exactly one of any of the characters contained.
        </li>
    </ul>

    <p>
        In patterns, all other characters are treated literally.
        For example,
    </p>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            By default, hidden files must be matched explicitly. 
        </p>
    </div>
  
    <div class="code">
        *
    </div>

    <p>
        expands to all files in the current directory.
    </p>

    <div class="code">
        *.pdf
    </div>

    <p>
        expands to all files ending in <code>.pdf</code>; and,
    </p>

    <div class="code">
        *.[gx]z
    </div>

    <p>
        expands to all files ending in either <code>.xz</code> or <code>.gz</code>.
    </p>

    <p>
        After these steps have been completed, Bash removes unquoted
        quotes, and prepares to execute the command.
    </p>
   
  <h3> See Also: </h3>
  <ul>
    <li><a href="http://mywiki.wooledge.org/glob"> glob - Greg's Wiki </a></li>
  </ul>
</div>

<div id="redirection" class="content">
	<h2 style="margin-bottom: 0;">I/O Redirection</h2>
    <h4> and Standard File Descriptors</h4>

    
	<p>
        In interactive use, the shell is connected to its terminal
        by 
        <a href="./processes.html#standard-file-descriptors">three open files</a>.  
        The first file, <code>STDIN</code>, is the keyboard. 
        When <code>bash</code> is waiting for you to enter a new command, 
        it's actually asked the kernel to 
        read a line from this file, and the kernel has 
        paused execution of <code>bash</code> until a line is 
        available (a line is available once you hit enter).
        The second and third open files, 
        <code>STDOUT</code> and <code>STDERR</code>, are the terminal
        screen: Whenever <code>bash</code> wants to print something out, 
        it writes characters to one of these files. 
    </p>

    <p>
	    Recall that each process created by the <code>fork</code> system
        call <a href="processes.html#process-creation">inherits</a> 
        its parent's attributes, and that these attributes
        include file descriptors (open files).
        This means that we, the users, can reasonably expect each
        child of <code>bash</code> to have our keyboard present at 
        <code>STDIN</code> and our terminal screen at both 
        <code>STDOUT</code> and <code>STDERR</code>.
    </p>

    <p>
        In interactive use, this is typically what we want, and
        means that our command,
    </p>

    <div class="code">
        $ ls
    </div>

    <p>
        will inherit the terminal as primary I/O, and thereby 
        print to the terminal screen.
    </p>
   
    <h3> Redirection </h3>

    <p>
        Redirection is the act of assigning a different file to the standard
        file descriptors before executing a command.
        Let's start with input.
    </p>

    <ul style="list-style-type: none;">
        <li> <code> command &lt; file </code> &emsp; Open <code>file</code>
            for reading,
            assign to <code>STDIN</code>, then execute <code>command</code></li>
    </ul>

    <p>
        This removes the keyboard from <code>STDIN</code> and replaces it with
        <code>file</code>; the command is no longer interactive, but will
        still print output to the terminal.
        This can be useful for scripting: Rather than
        repeatedly entering the same sequence of input multiple times,
        just save said input to a file and redirect.
    </p>

    <p>
        Here, as in all redirections, <code>command</code> is oblivious.
        Redirection is shell functionality, and <code>bash</code>
        remaps the appropriate open files before execution takes place.
        More, <code>command</code> does not recieve <code>&lt; file</code>
        as arguments; <code>bash</code> removes them after 
        the changes have been made.  
    </p>

    <p>
        To redirect output:
    </p>
        
    <ul style="list-style-type: none;">
        <li> <code> command &gt; file </code> &emsp; Open <code>file</code> 
            for writing; set length to zero; assign to <code>STDOUT</code>. 
            Then search for command.</li>
        <li> <code> command &gt;&gt; file </code> &emsp; Open <code>file</code> 
            for writing; seek to end; assign to <code>STDOUT</code>. 
            Then search for command.</li>
    </ul>

    <p>
        Since <code>STDERR</code> has been left unchanged, errors will
        still be printed to our terminal screen.
    </p>

    <p>
        Redirection can become quite involved. 
        It is possible to redirect <code>STDERR</code>, 
        to open a file and assign it an arbitrary file descriptor, 
        to copy the assignment of a file descriptor, 
        and to close an arbitrary file descriptor.
        All of this occurs within <code>bash</code>, after shell expansion
        and forking, and before it begins searching for the command.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://wiki.bash-hackers.org/syntax/redirection">Redirection - Bash Hackers Wiki</a></li>
        <li><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html"> Redirections - Bash Reference Manual</a></li>
    </ul>

</div>



<div class="content" id="searching-for-commands">
    <h2>Searching for Commands</h2>

    <h3>Commands and Builtin's</h3>

    <p>
        Most commands that users enter into <code>bash</code> are separate programs.
        For instance, <code>ls</code> is a separate program. When a user enters,
    </p>

    <div class="code">
        $ ls
    </div>

    <p>
        the shell finds the <code>ls</code> executable, 
        <a href="processes.html#process-creation">forks</a> itself, and
        instructs the child process to execute the appropriate program. 
        That child program gets its working 
        directory's entries from the kernel and prints them out.
        The shell, meanwhile, 
        <a href="https://man7.org/linux/man-pages/man2/wait.2.html">waits</a>
        in the background for the child process to terminate, then returns with a prompt.
    </p>

    <p>
        For a few reasons, this strategy is preferrable. 
        However, there are times where it will not work.
        For example, changing the current directory must be carried out 
        by <code>bash</code> directly; 
        as such, <code>cd</code> is built in to the shell itself.
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            The <code>type</code> command can be used to check if a command
            is a builtin.
        </p>
    </div>

    <p>
        Commands such as these are called <em>builtins</em>, and can be
        listed by,
    </p>

    <div class="code">
        $ help
    </div>

    <p>
        Within Bash, builtins <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Search-and-Execution.html#Command-Search-and-Execution">take precedence</a> over external commands.
    </p>
</div>


<!--

<div id="special-characters" class="content">
	<h2>Terminal Special Characters</h2>

	<p>
		Terminal special characters are key combinations 
        which are interpreted <em>by the terminal driver</em> 
        and mapped to special actions.
		There are sixteen commonly mapped terminal special characters,<sup><a href="#references">[15]</a></sup>
		but only a few are used daily:
	</p>

	<ul>
        <li>CTRL-C&mdash; Send <code><a href="https://en.wikipedia.org/wiki/Signal_(IPC)">SIGINT</a></code>, the interrupt signal, 
            to the foreground process. This is one means 
			of terminating a process.
        </li>
		<li>CTRL-D&mdash; Write <code>EOF</code>, the End-of-File character. 
            This indicates the end of input, and 
            will terminate a Bash session, or an interactive Python session.
        </li>
    </ul>
</div>

-->

<div class="content" id="missing-semester">
	<h2 style="margin-bottom: 2pt;">Missing Semester</h2>
	<h4 style="margin-bottom: 18pt;">Lecture 1: Course Overview + The Shell (2020)</h4>
	<iframe class="video" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div id="references" class="content">
	<h2> References </h2>
	<ol>
		<li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
		<li> Libes, Sol.  <i>Small Computer Systems Handbook</i>.  Published 1978, by Hayden Book Co. </li>
		<li> Lawyer, David S. <i>Text-Terminal-HOWTO</i> <a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO.html#toc1"> https://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html</a>.  The Linux Documentation Project.  Retrieved April 6, 2020. </li>
		<li> Shuford, Richard S. <a href="https://invisible-mirror.net/archives/shuford/terminal/first_principles.html"><i>First Thoughts about Terminal Emulation</i></a>. </li>
		<li> Ben-Halim, Zeyd M., Raymond, Eric S., Dickey, Thomas E. <a href="http://man7.org/linux/man-pages/man5/terminfo.5.html">man 5 terminfo</a>.  The Linux Man-Pages Project. Retrieved April 6, 2020.</li>
		<li> Dickey, Thomas E.  <a href="https://invisible-island.net/xterm/xterm.faq.html#what_is_vt220"><i>"What is a VT220?"</i></a>. Retrieved April 6, 2020.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/boot.7.html">man 7 boot</a>. The Linux Man-Pages Project. Written March 11, 2015.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/bootup.7.html">man 7 bootup</a>. The Linux Man-Pages Project.</li>
		<li> <a href="https://askubuntu.com/questions/27339/what-is-tty7-in-the-commandline">"What is tty7 in the command line?"</a>.  AskUbuntu question, posed by Fusky.</li>
		<li> <a href="http://man7.org/linux/man-pages/man4/tty.4.html">man 4 tty</a>. The Linux Man-Pages Project. Published March 6, 2019.</li>
		<li> <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/Kconfig?id=HEAD">Kernel Driver Source</a>.  Maintained by Linux Torvalds.</li>
		<li> <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html">The Kernel Administrators Guide; Linux Allocated Devices</a>. </li>
		<li> <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php">ANSI Escape Sequences</a>. ASCII-Table.com.  Retrieved April 6, 2020.</li>
		<li> <a href="https://linux.die.net/man/7/x"> man 7 x </a>.  Written by X.Org Foundation, LLC.  Hosted by die.net hosting.</li>
		<li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
	</ol>
</div>

