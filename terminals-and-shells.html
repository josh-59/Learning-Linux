---
layout: default
title: Terminals and Shells
last-updated: November, 2020
---

<!--
To Do:
    Standard File Descriptors:
        Include redirection
    Scripting
        Possibly:
            EOF and EOF character
    Bash Command Interpretation Cheat Sheet

    Other Nice Features:
        Filename completion via tab 
            - Filename list via tab
        Command completion via tab
            - Command list via tab

-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
		<li><a href="#history"> History </a></li>
		<li><a href="#terminal-emulators"> Terminal Emulators </a></li>
		<li><a href="#shells"> Shells </a></li>
        <li><a href="#word-splitting">Word Splitting</a></li>
        <li><a href="#searching-for-commands">Searching for Commands</a></li>
		<li><a href="#standard-file-descriptors"> Standard File Descriptors </a></li>
		
		<!--
        <li><a href="#shell-globbing"> Globbing </a></li>
		<li><a href="#shell-features"> Other Shell Features </a></li>
        <li><a href="#special-characters">Terminal Special Characters</a></li>
        -->
		<li><a href="#missing-semester"> Missing Semester </a></li>
		<li><a href="#references"> References </a></li>
	</ul>
</div>

<div id="introduction" class="content">
	<h1> Terminals and Shells</h1>
	<h4>Under Construction! </h4>
	<p>
		Unix was born in the years immediately following punch-card
		machines.
		At the time, the preferred interface for users was the <a href="./text-terminals.html">physical terminal</a>.
		Although physical terminals are antiquated, the idea persists in
		modern contexts because it is a very good low-level interface to the machine:
		It is often used by developers and system administrators to quickly get things done.
	</p>
</div>

<div id="history" class="content">
	<h2 style="margin-bottom: 2pt;">History:</h2>
	<h4>Physical Terminals</h4>

	<p>
		A <i>physical terminal</i> is a computer peripheral similar to a typewriter.
		The earliest examples printed output onto paper;
		this technology was carried over from the
		<a href="https://mysite.du.edu/~jcalvert/tel/teletype.htm"<i>teletypewriter</i></a>,
		a device for sending telegrams.
		Paper-based terminals persisted well into the 1970's, and later electronic typewriters
		<a href="https://www.youtube.com/watch?v=z-u4kUeIqDI">sometimes support terminal mode,</a>
		allowing them to interface with computers via serial cable.
	</p>

	<center>
		<a title="Peter Hamer, CC BY-SA 2.0 &lt;https://creativecommons.org/licenses/by-sa/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ken_Thompson_(sitting)_and_Dennis_Ritchie_at_PDP-11_(2876612463).jpg"><img width="1024" alt="Ken Thompson (sitting) and Dennis Ritchie at PDP-11 (2876612463)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg/1024px-Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg"></a>
		Ken Thompson (sitting) and Dennis Ritchie at PDP-11 in the "UNIX Room" of Bell Labs
	</center>

	<p>
		As technology developed and interactive computing became more popular,
		hard-copy terminals were phased out in favor of
		screen-based entities.
		The resulting devices consisted of a monitor and keyboard.
		The monitor was unlike a modern monitor in that it contained a buffer
		(on the order of a few kilobytes<sup><a href=#references>[3]</a></sup>)
		which maintained the text currently on screen.
		In addition, it contained a font table to be referenced
		when drawing each character&mdash; that is, it included its own font.
	</p>

	<p>
		Physical terminals <a href="https://www.vt100.net/dec/vt_history">were used for decades,</a>
		especially in situations demanding multiple access to large databases, such
		as airlines and libraries.
		In such a situation, the computational infrastructure forms a tree,
		with the system's administrators at the root, end-users at 
        the leaves.
	</p>

	<h3>See Also:</h3>
	<ul>
		<li><a href="https://youtu.be/RuZUPpmXfT0">DEC VT320: The Classic 1987 Library Computer Terminal</a> by LGR (Youtube Video)</li>
	</ul>

</div>

<div id="terminal-emulators" class="content">
	<h2> Terminal Emulators </h2>
	<p>
		Terminals persist on modern hardware in the form of <i>terminal emulators</i>.
		These are user-space processes that, well, emulate an old terminal!
		Specifically, it is a program that runs within the context of a desktop environment,
		and emulates the functionality of a physical terminal.
	</p>


	<figure>
		<img src="assets/img/gnome-terminal.png">
		<figcaption><center>GNOME Terminal Emulator</center></figcaption>
	</figure>

	<p>
		Some modern terminal emulators:
	</p>

	<p>
		<ul style="list-style: none;">
			<li> <a href="https://wiki.gnome.org/Apps/Terminal">GNOME Terminal</a>&mdash; A terminal emulator for GNOME. Common</li>
			<li> <a href="https://invisible-island.net/xterm/xterm.faq.html">xterm</a>&mdash; A terminal emulator for the X Window System.  Common, old, stable</li>
			<li> <a href="https://github.com/alacritty/alacritty "> alacritty</a>&mdash; A GPU-accelerated terminal emulator, written in Rust </li>
			<li> <a href="https://github.com/GitSquared/edex-ui#screenshots">edex-ui</a>&mdash; A terminal emulator designed to make you look <i>insanely badass</i> </li>
		</ul>
	</p>

	<div class="aside-right">
		<h4>Aside:</h4>
		<p>
			The files we are interested in are <code>/dev/pts/*</code>
		</p>
	</div>

	<p>
		These emulators are "dumb" in the sense that they do nothing except
		display text and return text.
		Per tradition, the Unix environment presents these connections as files.
		Since they are emulating a device, we can expect to find them in
		<code>/dev</code>.
	</p>

	<p>
		Terminal emulation can become quite involved;
		for this introduction, and for most purposes, it is sufficient to recognize that
		terminals and shells are distinct, cooperating processes.
	</p>

</div>

<div id="shells" class="content">
	<h2> Shells </h2>

    <div class="aside-right">
		<h4>Aside:</h4>
		<p>
		    <a href="https://itsfoss.com/what-is-desktop-environment/">
                Desktop environments</a>
            serve a role analogous to shells.
		<p>
	</div>

	<p>
		A shell is a program which interprets and executes our (arbitrary) commands.
		It is a <em>shell</em> in the sense that it is the outermost layer of the
		operating system, and the one which the user has direct contact.
	</p>

    <p>
		Unix deviates from most operating systems designs by entertaining
		the shell as an ordinary user-space process:  From
        the operating system's perspective, it is just another running program.
	</p>

	<p>
		Some modern shells:
	</p>

	<ul style="list-style: none;">
		<li><a href="https://www.gnu.org/software/bash/">bash</a>&mdash; A GNU Production; the standard shell</li>
		<li><a href="http://zsh.sourceforge.net/">zsh</a>&mdash; A shell designed for interactive use</li>
		<li><a href="https://fishshell.com/">fish</a>&mdash; The Friendly Interactive Shell</li>
	</ul>

    <p>
        A shell is launched for you when a terminal emulator window is opened.
    </p>

    <p>
        You can find out which shell is running by purusing the settings of 
        your terminal, or from within a terminal with the <code>ps</code> command:
    </p>

    <div class="code">
        $ ps <br>
        PID &emsp;&ensp;TTY  &emsp;    TIME &emsp;&ensp;   CMD <br>
        39410 pts/5    00:00:00 bash <br>
        39851 pts/5    00:00:00 ps
    </div>

    <p>
        Learning to use a shell amounts to learning how it handles
        each command given to it.  
        Here we'll study <code>bash</code>, but note that other shells
        in Linux operate similarly.
    </p>

   </div>

<div class="content" id="word-splitting">
    <h2 style="margin-bottom: 0;">Word Splitting</h2>
    <h4>and Simple Commands</h4>

    <div class="aside-right">
        <p>
            In Bash, this is referred to as a <em>simple command.</em>
            Here it will be referred to by <code style="font-size: inherit;">[command]</code>.
        </p>
    </div>

    <p>
        A typical line of input given to a shell is as follows:
    </p>

    <div class="code">
        command [arg1] [arg2] [arg3] ...
    </div>

    <p>
        Where <em>command</em> is mandatory, each argument is optional,
        and each element ("word") is separated by whitespace.
        In the following example, the <code>shutdown</code> command is given
        with the single argument <code>now</code>:
    </p>

    <div class="code">
        $ shutdown now
    </div>

    <p>
        If, for some reason, we need to include whitespace in
        an argument, we can wrap said argument in single-quotes.
        These tell Bash to preserve the text exactly as-is; Bash
        discards quoting characters.
    </p>

    <p>
        For example, in the following command, 
    </p>

    <div class="code">
        $ cd 'Random Access Memories'
    </div>

    <p>
        the <code>cd</code> command recieves a single argument,
        <code>Random Acccess Memories</code>.
    </p>

    <p>
        In Bash, this procedure is known as <em>word splitting</em>, 
        and is the conceptual center of command interpretation.
    </p>
        
</div>

<div class="content" id="searching-for-commands">
    <h2>Searching for Commands</h2>
   
     <h3>Commands and Builtin's</h3>

    <p>
        Most commands that users enter into <code>bash</code> are separate programs.
        For instance, <code>ls</code> is a separate program. When a user enters,
    </p>

    <div class="code">
        $ ls
    </div>

    <p>
        the shell finds the <code>ls(1)</code> executable, 
        <a href="processes.html#process-creation">forks</a> itself, and
        instructs the child process to execute that binary. 
        The <code>ls</code> program then reads its current directory's
        entries and prints them out.
        The shell 
        <a href="https://man7.org/linux/man-pages/man2/wait.2.html">waits</a>
        for <code>ls</code> to terminate, then returns with a prompt.
        This happens very quickly.
    </p>

     <div class="aside-right">
        <h4>Alternative:</h4>
        <p>
            <code><a href="https://the.exa.website"</a>exa</a></code>
            is a modern replacement for <code>ls</code>.
        </p>
    </div>

    <p>
        For a few reasons, this strategy is preferrable; however, 
        there are times where it will not work.
        For instance, changing the current directory must be carried out 
        by <code>bash</code> itself, since it is a per-process attribute.
        Therefore, <code>cd</code> is carried out by <code>bash</code>.
    </p>

    <p>
        Commands such as these are called <em>builtins</em>, and can be
        listed by,
    </p>

    <div class="code">
        $ help
    </div>

    <p>
        Where <code>help</code> is, itself, a builtin.
    </p>

    <p>
        Within Bash, builtins <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Search-and-Execution.html#Command-Search-and-Execution">take precedence</a> over external commands.
    </p>


</div>


<div id="standard-file-descriptors" class="content">
	<h2 style="margin-bottom: 0;"> The Standard File Descriptors </h2>
    <h4> and Redirection</h4>
	<p>
        In interactive use, <code>bash</code> is connected to its terminal
        by open files.  
        The first file, represented within <code>bash</code> as 
        <a href="processes.html#file-descriptors">file descriptor <em>0</em></a>,
        is the keyboard:
        Writing to it is not permitted, and reading from it amounts to
        waiting for the next line of input.
        The second file, file descriptor <em>1</em>, is the terminal
        screen: Reading from it is not permitted, and anything written to it
        is printed on screen.
    </p>

    <p>
	    Recall that each process created by the <code>fork(2)</code> system
        call <a href="processes.html#process-creation">inherits</a> 
        its parent's attributes, and that these attributes
        include file descriptors.
        This implies that each fork of <code>bash</code> will have a 
        keyboard present at file descriptor zero, and a terminal screen
        at file descriptor one.
	</p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Can you do it?
            Yes you can!
        </p>
    </div>

    <p>
        This spawned the convention of <em>Standard file descriptors</em>:
        Descriptors 0, 1 and 2 are referred to as 
        <code>STDIN</code>,
        <code>STDOUT</code>,
        and <code>STDERR</code>, respectively.
        By this convention, writing an <code>ls</code> clone becomes simple:
        For each <a href="https://www.man7.org/linux/man-pages/man3/readdir.3.html">entry</a> in the current directory, <a href="https://man7.org/linux/man-pages/man3/printf.3.html">print</a> it out!
    </p>

    <p>
        Standard error (<code>STDERR</code>) is the same
        terminal screen as <code>STDOUT</code>, but is reserved for
        errors, logs and other red-letter messages.
        In a moment, we'll see why this is useful.
    </p>

    <h3> Redirection </h3>

    <p>
        Redirection is the act of assigning a different file to the standard
        file descriptors before executing a command.
    </p>

    <ul style="list-style-type: none;">
        <li> <code> [command] &gt; file </code> &emsp; Redirect <code>STDOUT</code> to file, then execute command. Creates or overwrites file. </li>
        <li> <code> [command] &lt; file </code> &emsp; Redirect <code>STDIN</code>
            to file, then execute command </li>
    </ul>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            "O, that infected moisture of his eye..."
        </p>
    </div>

    <p>
        There's actually not much to these, so we'll just jump into using them.
        Suppose we had <a href="https://ocw.mit.edu/ans7870/6/6.006/s08/lecturenotes/files/t8.shakespeare.txt">the complete works of Shakespeare in a single file</a> (5.3MB), and we wanted to copy them.
        We could use <code>cp</code>, but for poetic reasons, we want the computer
        <em>to read</em> them, and therefore, we must use <code>cat</code> instead.
    </p>

    <div class="code">
        $ cat t8.shakespeare.txt <br>
        This is the 100th Etext file presented by Project Gutenberg, and <br>
        is presented in cooperation with World Library, Inc., from their <br>
        Library of the Future and Shakespeare CDROMS.  Project Gutenberg <br>
        often releases Etexts that are NOT placed int he Public Domain!! <br>
        <br>
        Shakespeare <br>
        <br>
        *This Etext has certain copyright implications you should read!* <br>
        <br>
        &lt;&lt;THIS ELECTRONIC VERSION OF THE COMPLETE WORKS OF WILLIAM <br>
        ...  
    </div>

    <p>
        Whoops!  That printed to the terminal screen (1.662 seconds)!
        What we wanted to do was <em>redirect</em> that output to a different file:
    </p>

    <div class="code">
        $ cat t8.shakespeare.txt &gt; shakespeare_backup
    </div>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            Since <code>STDERR</code> was not redirected, any errors would 
            have been printed to our terminal screen.
        </p>
    </div>



    <p>
        Much better.  After word splitting, <code>Bash</code> inspects
        each word; here, it found the redirection operator <code>&gt;</code>.
        It took the next word, <code>shakespeare_backup</code>, to be
        a filename. Since that file did not exist, it created it
        (if it had existed, <code>bash</code> would have truncated its length
        to zero, effectively erasing the file).
        Then it assigned the file to <code>STDOUT</code> and
        executed <code>cat</code> with a single argument, <code>t8.shakespeare.txt</code>.
        Finally, <code>cat</code> naively printed to <code>STDOUT</code>, and 
        thereby copied the contents of the file.
    </p>

    
    <ul style="list-style-type: none;">
        <li> <code> [command] &gt;&gt; file </code> &ensp; Redirect <code>STDOUT</code>
            to file, then execute command. Concatenate.</li>

    </ol>



</div>

<!--

<div id="special-characters" class="content">
	<h2>Terminal Special Characters</h2>

	<p>
		Terminal special characters are key combinations 
        which are interpreted <em>by the terminal driver</em> 
        and mapped to special actions.
		There are sixteen commonly mapped terminal special characters,<sup><a href="#references">[15]</a></sup>
		but only a few are used daily:
	</p>

	<ul>
        <li>CTRL-C&mdash; Send <code><a href="https://en.wikipedia.org/wiki/Signal_(IPC)">SIGINT</a></code>, the interrupt signal, 
            to the foreground process. This is one means 
			of terminating a process.
        </li>
		<li>CTRL-D&mdash; Write <code>EOF</code>, the End-of-File character. 
            This indicates the end of input, and 
            will terminate a Bash session, or an interactive Python session.
        </li>
    </ul>
</div>

-->

<div class="content" id="missing-semester">
	<h2 style="margin-bottom: 2pt;">Missing Semester</h2>
	<h4 style="margin-bottom: 18pt;">Lecture 1: Course Overview + The Shell (2020)</h4>
	<iframe class="video" src="https://www.youtube.com/embed/Z56Jmr9Z34Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<div id="references" class="content">
	<h2> References </h2>
	<ol>
		<li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
		<li> Libes, Sol.  <i>Small Computer Systems Handbook</i>.  Published 1978, by Hayden Book Co. </li>
		<li> Lawyer, David S. <i>Text-Terminal-HOWTO</i> <a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO.html#toc1"> https://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html</a>.  The Linux Documentation Project.  Retrieved April 6, 2020. </li>
		<li> Shuford, Richard S. <a href="https://invisible-mirror.net/archives/shuford/terminal/first_principles.html"><i>First Thoughts about Terminal Emulation</i></a>. </li>
		<li> Ben-Halim, Zeyd M., Raymond, Eric S., Dickey, Thomas E. <a href="http://man7.org/linux/man-pages/man5/terminfo.5.html">man 5 terminfo</a>.  The Linux Man-Pages Project. Retrieved April 6, 2020.</li>
		<li> Dickey, Thomas E.  <a href="https://invisible-island.net/xterm/xterm.faq.html#what_is_vt220"><i>"What is a VT220?"</i></a>. Retrieved April 6, 2020.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/boot.7.html">man 7 boot</a>. The Linux Man-Pages Project. Written March 11, 2015.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/bootup.7.html">man 7 bootup</a>. The Linux Man-Pages Project.</li>
		<li> <a href="https://askubuntu.com/questions/27339/what-is-tty7-in-the-commandline">"What is tty7 in the command line?"</a>.  AskUbuntu question, posed by Fusky.</li>
		<li> <a href="http://man7.org/linux/man-pages/man4/tty.4.html">man 4 tty</a>. The Linux Man-Pages Project. Published March 6, 2019.</li>
		<li> <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/Kconfig?id=HEAD">Kernel Driver Source</a>.  Maintained by Linux Torvalds.</li>
		<li> <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html">The Kernel Administrators Guide; Linux Allocated Devices</a>. </li>
		<li> <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php">ANSI Escape Sequences</a>. ASCII-Table.com.  Retrieved April 6, 2020.</li>
		<li> <a href="https://linux.die.net/man/7/x"> man 7 x </a>.  Written by X.Org Foundation, LLC.  Hosted by die.net hosting.</li>
		<li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
	</ol>
</div>

