---
layout: default
title: Terminals and Shells
last-updated: March, 2021
---

<!--
To Do:

    Simple Commands:
        Recall that
        Each command therefore inherits the shell's attributes, including
        - Place in the filesystem
        - Open files
            - Terminal

    <p>
        A parent can pass information to its child in other ways,
        such as environment variables, but
        ...and tend to remain constant over a session.
    </p>

    ================>Closing Remarks<=================

    <p>
        The shell does little else.
        It may provide some means to store variables, and offer to expand them,
        but by and large, shells are as "dumb" as terminals, and, this is intentional.
    </p>

<div class="content" id="shell-features">
    <h2>Shell Features</h2>

    <p>
        Kernighan page 132:
        Invented by John Mashey and introduced in the 6th edition shell,
        it was a workaround so that non-expert users could
        share their own sets of commands by lab, department and group.
    </p>

-->

<div id="nav_bar_2" class="nav">
	<ul>
		<li><a href="#introduction"> Introduction </a></li>
		<li><a href="#physical-terminals"> Physical Terminals </a></li>
		<li><a href="#terminal-emulators"> Terminal Emulators </a></li>
		<li><a href="#shells"> Shells </a></li>
        <li><a href="#commands">Commands</a></li>
        <li><a href="#pwd">Working Directory</a></li>
        <li><a href="#path">PATH </a></li>
        <li><a href="#closing-remarks">Closing Remarks: Arguments</a></li>
        <li><a href="#ryan-tomayko">Ryan Tomayko</a></li>
		<li><a href="#references"> References </a></li>
	</ul>
</div>

<div id="introduction" class="content">
	<h1> Terminals and Shells</h1>

    <div class="quote-text">
        "Nontechnical questions sometimes don't have an answer at all."
    </div>
    <div class="quote-ref">
        Linus Torvalds
    </div>

    <p>
        Though foreign to most users, the text-terminal is the original
        interface for "interactive computing."
        This article will examine the fascinating history and theory of
        this interface in GNU/Linux.
        For a tutorial introduction, see 
        <a href="https://effective-shell.com/">Effective Shell</a> by Dave Kerr, 
        or the Ubuntu <a href="https://ubuntu.com/tutorials/command-line-for-beginners#1-overview">Linux Command Line for Beginners</a>.
    </p>
</div>

<div id="physical-terminals" class="content">
	<h2 style="margin-bottom: 2pt;">Physical Terminals</h2>
	<h4>A Brief History</h4>

	<p>
		A <i>physical terminal</i> was a computer peripheral similar to a typewriter.
		The earliest examples printed output onto paper;
		the technology was carried over from the
		<a href="https://mysite.du.edu/~jcalvert/tel/teletype.htm"<i>teletypewriter</i></a>,
		a device for sending telegrams.
		Paper-based terminals persisted well into the 1970's, and later
        electronic typewriters often supported terminal mode,
		allowing them to interface with computers via serial cable.
	</p>

	<center>
		<a title="Peter Hamer, CC BY-SA 2.0 &lt;https://creativecommons.org/licenses/by-sa/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ken_Thompson_(sitting)_and_Dennis_Ritchie_at_PDP-11_(2876612463).jpg"><img width="1024" alt="Ken Thompson (sitting) and Dennis Ritchie at PDP-11 (2876612463)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg/1024px-Ken_Thompson_%28sitting%29_and_Dennis_Ritchie_at_PDP-11_%282876612463%29.jpg"></a>
        Ken Thompson (sitting) and Dennis Ritchie at PDP-11, in Bell Labs' <em>UNIX Room</em><sup><a href="#references" title="Kernighan, p. 45">[1]</a></sup>
	</center>

    <p>
		As technology developed and interactive computing became more popular,
		hard-copy terminals were phased out in favor of
		screen-based entities.
		The resulting devices consisted of a monitor and keyboard.
	</p>

    <div class="aside-right">
        <h4>Aside</h4>
        <p>
            Terminals are represented by <code>tty</code>
            device files.  
        </p>
    </div>

	<p>
		The monitor contained a buffer
        (on the order of a few kilobytes)
		which maintained the text currently on-screen.<sup><a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO-1.html#ss1.6">[2]</a></sup>
		Using an onboard font table, it would redraw the text given to it without
		further instruction by the computer; thus, the computer's only duties were to feed
		the terminal characters and to draw characters from it.
    </p>

	<h3>See Also</h3>
	<ul>
        <li><a href="https://www.man7.org/linux/man-pages/man1/tty.1.html"><code>tty(1)</code></a></li>
		<li><a href="https://www.vt100.net/dec/vt_history">Meet the Family: Digital's Video Terminals</a></li>
        <li><a href="https://www.youtube.com/watch?v=RuZUPpmXfT0&t=4s">DEC VT320: The Classic 1987 Library Computer Terminal</a> (Youtube Video)</li>
    </ul>
</div>

<div id="terminal-emulators" class="content">
	<h2> Terminal Emulators </h2>
	<p>
		Terminals persist today primarily the form of
        <i>terminal emulators</i>.
        A terminal emulator is a program that runs within the context of a desktop
        environment and provides the functionality of a physical terminal:
	</p>

	<figure>
		<img src="assets/img/gnome-terminal.png">
		<figcaption><center>GNOME Terminal Emulator</center></figcaption>
	</figure>

	<p>
		Some modern terminal emulators:
	</p>

	<p>
		<ul style="list-style: none;">
			<li> <a href="https://wiki.gnome.org/Apps/Terminal">GNOME Terminal</a>&mdash; A terminal emulator for GNOME. Common</li>
			<li> <a href="https://github.com/alacritty/alacritty "> alacritty</a>&mdash; A GPU-accelerated terminal emulator</li>
			<li> <a href="https://github.com/GitSquared/edex-ui">edex-ui</a>&mdash; A terminal emulator designed to make you look <i>insanely badass</i> </li>
            <li> <a href="https://hyper.is/">Hyper</a>&mdash; An <a href="https://www.electronjs.org/">Electron</a>-based terminal</li>
            <li> <a href="https://github.com/Swordfish90/cool-retro-term">Cool Retro Term</a>&mdash; 'nuff said</li>
		</ul>
	</p>

	<p>
		These emulators are "dumb" in the sense that they do nothing except
		display text and return text.
		Per tradition, their input and output is handled through device files 
        (see <code>tty(1)</code> below).
	</p>

	<p>
		Terminals can become quite involved; for this introduction, and for
        most purposes, it is sufficient to recognize that
		terminals and shells are distinct, cooperating processes.
	</p>
</div>

<div id="shells" class="content">
	<h2> Shells </h2>

    <div class="aside-right">
		<h4>Aside:</h4>
		<p>
		    <a href="https://itsfoss.com/what-is-desktop-environment/">
                Desktop environments
            </a>
            serve a role analogous to shells.
		<p>
	</div>

	<p>
		A shell is a program which interprets and executes commands.
		It is a <em>shell</em> in the sense that it is the outermost layer of the
		operating system, and the one which the user has direct
        contact with.<sup><a href="http://www.linfo.org/kernel.html">[a]</a></sup>
		The UNIX architecture entertains the shell as an ordinary user-space process.
	</p>

	<p>
		Some modern shells:
	</p>

	<ul style="list-style: none;">
        <li><a href="https://www.gnu.org/software/bash/">Bash</a>&mdash; GNU's <em>Bourne Again Shell</em> was among the first programs to run on the Linux kernel, and has been more or less standard since.</li>
        <li><a href="http://zsh.sourceforge.net/">Zsh</a>&mdash; An extension to <em>Bash</em> focusing on interative features. Default on Mac's</li>h  
        <li><a href="https://xon.sh">Xonsh</a>&mdash; A Pythonic shell, written in Python!</li>
		<li><a href="https://fishshell.com/">Fish</a>&mdash; The Friendly Interactive Shell</li>
        <li><a href="https://www.nushell.sh/">Nushell</a>&mdash; An interactive shell, supporting piplines of structured data, in addition to simple text streams.</li>
        <li><a href="https://elv.sh/">Elvish</a>&mdash; an "expressive programming language and versatile interactive shell." Version 1.0 not yet released</a></li>
	</ul>

    <p>
        A shell is launched for you when a terminal emulator window is opened.
        You can find out which shell is running
        by executing the <code>ps</code> command:
    </p>

    <figure>
		<img src="assets/img/gnome-w-bash-ps.png">
        <figcaption><center><code>ps</code> command, by default listing processes owned by the current user,<br> and connected to the current terminal </center></figcaption>
	</figure>

    <p>
    </p>
</div>

<div class="content" id="commands">
    <h2>Commands</h2>

    <p>
        A typical line of input to the shell has the following form:
    </p>

    <div class="code">
        $ <i>command</i> [arg ...]
    </div>

    <p>
        This corresponds directly to, <em>Find and execute <code>command</code>, 
        and pass it <code>[arg ...]</code>.</em>
        There are a few places the shell can look.
        In order: 
    </p>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            Two tools to identify commands are
            <code>type</code> and <code>which</code>.
        </p>
    </div>

    <ol>
        <li>User-defined Function</li>
        <li>Shell Builtin Command</li>
        <li>External Command</li>
    </ol>

    <p>
        Most commands are external to the shell.
        For example, 
    </p>

    <div class="code">
        $ ls 
    </div>

    <p>
        The <code>ls</code> command is not found as a user-defined function,
        nor as a builtin.  
        It is found in <code>/bin</code>.
    </p>

    <h3>Arguments</h3>

    <p>
        Commands are the first part of a "typical line of input" given to the
        shell; the other part is arguments.
        Like commands, arguments are supplied by the user. 
        They are passed to each function, builtin, or program as it begins 
        execution, and it is up to that command to interpret them.
    </p>

    <p>
        For example, <code>echo</code> responds to arguments 
        very simply&mdash; It prints them back out:
    </p>

    <div class="code">
        $ echo one two three four<br>
        one two three four<br>
    </div>

    <p>
        See a command's manual page (or other documentation) for details.
    </p>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://linuxhandbook.com/linux-commands/">Basic Linux Commands Everyone Should Know</a></li>
    </ul>
</div>

<div class="content" id="pwd">
    <h2>Working Directory</h2>

    <p>
        Recall that each process has a
        <a href="/processes.html#process-attributes">current working directory</a>.
        Since the shell is a process, it too has a current working directory.
        At the command line, this is of particular importance:
        It reflects <em>where you are</em> in the directory tree.
    </p>

    <div class="aside-right">
        <h4>Aside</h4>
        <p>
            In particular, relative file names are resolved with respect to this 
            location.
        </p>
    </div>

    <p>
        The shell's current working directory may be printed with 
        <code>pwd</code>:
    </p>

    <div class="code">
        $ pwd<br>
        /home/josh
    </div>

    <p>
        Its value may be changed with <code>cd</code>:
    </p>

    <div class="code">
        $ cd Public<br>
        $ pwd<br>
        /home/josh/Public
    </div>

    <p>
        Since each directory refers to its parent directory as <code>..</code>,
        we can always move <em>up</em> the tree with,
    </p>

    <div class="code">
        $ cd .. <br>
        $ pwd<br>
        /home/josh
    </div>

</div>

<div class="content" id="path">
    <h2><code>PATH</code> Environment Variable</h2>

    <div class="aside-right">
        <h4>Note:</h4>
        <p>
            The shell searches the directories in <em>PATH</em> only after
            looking for a user-defined function and a builtin by the
            same name.
        </p>
    </div>

    <p>
        So where does the shell look for external commands?
        The <em>PATH</em> environment variable
        contains a colon (<code>:</code>)-separated list of directories to be searched
        when looking for a program.
        It may look like this:
    </p>

    <div class="code">
        $ echo $PATH<br>
        /usr/bin:/bin:/home/josh/.local/bin
    </div>

    <p>
        The shell searches each directory in this list from left to right
        for a file whose name matches the command given.
        It executes the first found, then abandons its search.
        The shell does not search the current working directory
        for a command.
    </p>
    
    <p>
        If a command includes a forward-slash <code>/</code>, 
        then it is interpretted as a program name.
        For instance, we can execute precisely <code>/usr/bin/echo</code>
        by issuing,
    </p>

    <div class="code">
        $ /usr/bin/echo one two three four <br>
        one two three four
    </div>

    <p>
        This is typically done to execute a program in the current working
        directory:
    </p>

    <div class="code">
        $ ./<i>program</i> 
    </div>

    <p>
        Finally, appending locations to <code>PATH</code> is an important step of
        setting up a development environment.
        This is typically done in <code>~/.bashrc</code>
        (but UNIX purists beg to differ).
        The correct construct appends the directory
        only if it is not already present:
    </p>

    <div class="code">
        if [[ ! $PATH =~ $HOME/.local/bin ]]; then<br>
        &emsp;&emsp;&emsp;&emsp;PATH=$PATH:$HOME/.local/bin<br>
        fi
    </div>

    <h3>See Also:</h3>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Environment_variable#True_environment_variables"> Environment Variables </a> - Wikipedia</li>
    </ul>
</div>

<div class="content" id="closing-remarks">
    <h2 style="margin-bottom: 5px;">Closing Remarks:</h2>

    <p>
        At this point, we have covered the most essential elements of the 
        shell.
        It is <a href="assets/simple-shell.c">not a difficult construct</a>,
        and consists of a main loop which:
    </p>

    <ol>
        <li>Prints prompt</li>
        <li>Gets input</li>
        <li>Executes command</li>
    </ol>

    <p>
        The variety of shells offered above reflects a variety of interpretations of,
        and expansions on, this same thing.
        For instance, the Pythonic shell <code>xonsh</code> exposes
        a full, general-purpose programming language to the user.
        The most common shells of our time are <code>bash</code> and <code>zsh</code>.
    </p>

    <p>
        Many details and constructs have not been introduced, but these
        are mostly implementation-specific, and generally aren't required for
        day-to-day use.
        Some of the most important are:
    </p>

    <ul>
        <li>I/O and Redirection</li>
        <li>Variables</li>
        <li><a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-script.php">Scripting</a></li>
    </ul>

    <h4 style="width: 30%; margin: auto;">In the Beginning</h4>

    <p>
        The first versions on UNIX entertained exactly two processes:
        One for each of two terminals connected to the machine.<sup><a href="https://www.bell-labs.com/usr/dmr/www/hist.html">[3]</a></sup>
        The shell,
        <a href="https://en.wikipedia.org/wiki/Thompson_shell"><code>sh</code></a>,
        existed as a user-space process, but <em>fork()</em> had not been introduced.
        To execute a command, the shell simply replaced itself with
        the requested program;
        the program, on calling <em>exit</em>, replaced itself with the
        shell once again.<sup><a href="https://www.bell-labs.com/usr/dmr/www/hist.html">[3]</a></sup>
    </p>

    <p>
        In particular, <em>change directories</em> was implemented
        as a separate command.
        When invoked, it inherited the shell's current working directory,
        changed it, and then the shell would inherit the resulting working directory.
        With the inclusion of the <em>fork()</em> system call, though,
        the <code>chdir</code> command broke:
    </p>

    <div class="aside-right">
        <h4>Aside:</h4>
        <p>
            The <code>exit</code> command is also, necessarily, built in to the shell.
        </p>
    </div>


    <blockquote>
        "There was much reading of code and anxious introspection about how
        the addition of fork could have broken the chdir call. Finally the
        truth dawned: in the old system chdir was an ordinary command; it
        adjusted the current directory of the (unique) process attached to
        the terminal. Under the new system, the chdir command correctly
        changed the current directory of the process created to execute it,
        but this process promptly terminated and had no effect whatsoever on
        its parent shell! It was necessary to make chdir a special command,
        executed internally within the shell. It turns out that several
        command-like functions have the same property, for example login."
    </blockquote>

    <p>
        And so <em>builtins</em> began.
        In Bash, builtins can be investigated by:
    </p>

    <div class="code">
        $ help
    </div>

    <p>
        And in Zsh, by:
    </p>

    <div class="code">
        $ man zshbuiltins
    </div>

    <h3>Startup Files</h3>
    <p>
        

    </p>
    
    <h3>See Also:</h3>
    <ul>
        <li><a href="https://www.bell-labs.com/usr/dmr/www/hist.html">The Evolution of the Unix Timesharing System</a></li>
        <li><a href="http://shellhaters.org/">Shell Hater's Handbook</a></li>
        <li><a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">Read-eval-print loop</a> - Wikipedia</li>
    </ul>
</div>

<div class="content" id="ryan-tomayko">
    <h2>Ryan Tomayko:</h2>
    <h4>Shell Hater's Handbook</h4>

<iframe class="video" src="https://www.youtube.com/embed/olH-9b3VJfs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<!--
<div class="content" id="exercises">
    <h2>Exercises:</h2>

    <ol style="margin-left: 0;">
        <li>
            <p>
                Terminal emulators are also processes.  From the command line, find
                your emulator's working directory.
            </p>
        </li>
        <li>
            <p>
                What is the difference between <code>type</code> and <code>which</code>?
            </p>
        </li>
        <li>
            <p>
                Why <em>shouldn't</em> you append <code>.</code> to PATH?
            </p>
        </li>
        <li>
            <p>
                Scripting exercise:
                Use constructs other than <code>if</code> to append a location
                to path.
            </p>
        </li>
        <li>
            <p>
                The command,
            </p>
            <div class="code">
                $ $(echo cd $PWD)
            </div>
            <p>
                is equivalent to which of the following:
            </p>
            <ol>
                <li>$ cd </li>
                <li>$ cd $HOME</li>
                <li>$ cd .</li>
                <li>$ cd ..</li>
            </ol>
        </li>
        <li>
            Each section of the manual page has an introduction, <code>intro</code>,
            but no index.  Why not?  Create an index of Section 7 for yourself.
        </li>
        <li>
            Implement 'exit' builtin in simple-shell.c
        </li>
    </ol>
</div>
-->

<div id="references" class="content">
	<h2> References </h2>
	<ol>
		<li> Kernighan, Brian. <i>Unix: A History and a Memoir.</i>  Published 2020, by Brian W. Kernighan via Kindle Direct Publishing. </li>
		<li> Lawyer, David S. <i>Text-Terminal-HOWTO</i> <a href="https://tldp.org/HOWTO/Text-Terminal-HOWTO-1.html#ss1.6"> https://tldp.org/HOWTO/Text-Terminal-HOWTO-8.html</a>.  The Linux Documentation Project.  Retrieved April 6, 2020. </li>
        <li>Ritchie, D. M. (1984). The Evolution of the Unix Time-sharing System. <em>AT&amp;T Bell Laboratories Technical Journal,</em> 63(6), 2nd ser., 1577-1593.</li>

	</ol>
</div>


<!--
		<li> Libes, Sol.  <i>Small Computer Systems Handbook</i>.  Published 1978, by Hayden Book Co. </li>
		<li> Shuford, Richard S. <a href="https://invisible-mirror.net/archives/shuford/terminal/first_principles.html"><i>First Thoughts about Terminal Emulation</i></a>. </li>
		<li> Ben-Halim, Zeyd M., Raymond, Eric S., Dickey, Thomas E. <a href="http://man7.org/linux/man-pages/man5/terminfo.5.html">man 5 terminfo</a>.  The Linux Man-Pages Project. Retrieved April 6, 2020.</li>
		<li> Dickey, Thomas E.  <a href="https://invisible-island.net/xterm/xterm.faq.html#what_is_vt220"><i>"What is a VT220?"</i></a>. Retrieved April 6, 2020.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/boot.7.html">man 7 boot</a>. The Linux Man-Pages Project. Written March 11, 2015.</li>
		<li> <a href="http://man7.org/linux/man-pages/man7/bootup.7.html">man 7 bootup</a>. The Linux Man-Pages Project.</li>
		<li> <a href="https://askubuntu.com/questions/27339/what-is-tty7-in-the-commandline">"What is tty7 in the command line?"</a>.  AskUbuntu question, posed by Fusky.</li>
		<li> <a href="http://man7.org/linux/man-pages/man4/tty.4.html">man 4 tty</a>. The Linux Man-Pages Project. Published March 6, 2019.</li>
		<li> <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/Kconfig?id=HEAD">Kernel Driver Source</a>.  Maintained by Linux Torvalds.</li>
		<li> <a href="https://www.kernel.org/doc/html/v5.4/admin-guide/devices.html">The Kernel Administrators Guide; Linux Allocated Devices</a>. </li>
		<li> <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php">ANSI Escape Sequences</a>. ASCII-Table.com.  Retrieved April 6, 2020.</li>
		<li> <a href="https://linux.die.net/man/7/x"> man 7 x </a>.  Written by X.Org Foundation, LLC.  Hosted by die.net hosting.</li>
		<li> Kerrisk, Michael.  <em>The Linux Programming Interface</em>. San Francisco, CA, No Starch Press, 2010.</li>
-->
