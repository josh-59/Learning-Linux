---
layout: default
title: Command Line
last-updated: July, 2020
---
<!--
  TODO
  Builtins

  readlink (command-line utility)

  A tutorial introduction

  Example of good scripting:
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | cat -
-->


<div id="nav_bar_2" class="nav">
  <ul>
    <li><a href="#introduction"> Introduction </a></li>
    <li><a href="#commands"> Commands </a></li>

    <li><a href="#path-environment-variable"> The Path Environment Variable </a></li>
    <li><a href="#introduction-to-make"> Introduction to Make </a></li>
    <li><a href="#closing-remarks"> Closing Remarks </a></li>
    <li><a href="#references"> References </a></li>
  </ul>
</div>

<div id="introduction" class="content">
  <h1>The Command Line 2:</h1>
  <h4>More Detail</h4>
  <h4>Under Construction!</h4>

  <p>

  </p>
</div>

<div class="content" id="commands">
    <h2>Commands</h2>
    <p>
        The command-line interface, sometimes abbreviated CLI, is based around the
        <em>command.</em>
        A command is just a program; nothing more, and nothing less.

    </p>
</div>

<div class="content" id="path-environment-variable">
  <h2> The Path Environment Variable </h2>
  <p>
      The <em>PATH</em> environment variable declares the directories the shell
      will search when locating an executable file each time a command is entered.
      We can have a look at its value with,
  <p>

  <div class="code">
      echo $PATH
  </div>

  <p>
      The result is a list of directories;
      the shell searches these directories (from left to right), and executes
      the first executable with the same name as the command given.
      The <code>PATH</code> variable was invented by John Mashey
      and introduced as a workaround so that non-expert users could
      share their own sets of command by lab, department or
      group.<sup><a href="#references">Kernighan page 132 (check not plaigarizing)</a></sup>
  </p>

  <div class="aside-right">
    <h4>Aside:</h4>
    <p>
      We can always override this search by specifying the executable's
      location, either absolutely (e.g., <code>/bin/echo</code>), or relatively (e.g., <code>./cat</code>).
    </p>
  </div>

  <p>
    It's fairly common to modify the value of this variable, so we'll go over
    how to do it properly.
  </p>
</div>

<div class="content" id="introduction-to-make">
  <h2> Introduction to Make </h2>
  <p>

  </p>
</div>

<div class="content" id="closing-remarks">
  <h2> Closing Remarks </h2>
  <p>
      A shell is not, fundamentally, a complicated program.
      Its job is to query the user for their next command,
      then execute that command.
      An outline of the central loop is as follows:
  </p>

  <div class="code">
    while(true) {<br>
      &emsp;print_prompt();<br>
      &emsp;get_line();<br>
      &emsp;parse_line();<br>
      &emsp;execute(line);<br>
    }
  </div>

  <h3> The Builtin Confusion </h3>
  <p>
    Shells contain many functions of their own.
    These commands are called <em>builtins,</em> and implement functionality
    too closely tied with the shell to be separate.
    For instance, the <em>cd</em> command must be implemented as a
    builtin (because the system call to change a process's working directory,
    <a href="https://man7.org/linux/man-pages/man2/chdir.2.html">chdir(2)</a>,
    acts on the calling process alone, and therefore cannot be executed within
    a fork of the process.
  </p>

  <p>
    The confusion arises when the shell implements a command like <em>echo</em>
    as a builtin.
    In this situation, echo exists as a program on PATH, so that "which echo"
    prints a path, but that program is not called when echo is called.
    Modern shells (e.g., <em><a href="https://www.nushell.sh/">nushell</a></em>) will warn you of this when you
    call <em>which</em>, but older shells like bash do not.
    In Bash, if you suspect that a command like <em>echo</em> is builtin, you can check with,
  </p>

  <div class="code">
    $ help echo
  </div>

  <p>
    If a shell help page exists, then it is a builtin.
    In practice, this "builtin" detail is rarely an issue, but it occasionally is, and it
    is confusing.
    You can "force" the external program with an absolute pathname,
    e.g.,
  </p>

  <div class="code">
    $ /bin/echo hello world
  </div>

  or

  <div class="code">
    $ $(which echo) hello world.
  </div>

  <h3> Convention: $ and # </h3>
  <p>
    By convention, the dollar-sign symbol <em>$</em> denotes
    the command-line prompt with ordinary user permissions.
    The hash symbol <em>#</em> denotes the command-line prompt with root permissions:
  </p>

  <div class="code">
    $ cat archlinux-2020.07.02-pbp.img > /dev/sdb <br>
    bash: /dev/sdb: Permission denied <br>
    $ sudo -i <br>
    [sudo] password for josh: <br>
    # cat archlinux-2020.07.02-pbp.img > /dev/sdb <br>
  </div>

  <h3> See Also: </h3>
  <ul>
    <li> <a href="https://github.com/alebcay/awesome-shell">Awesome Shell</a> </li>
  </ul>
</div>

<div id="references" class="content">
  <h2> References </h2>
  <ol>
    <li> Kernighan, B. W., &amp; Ritchie, D. M. (1988). <i>The C Programming Language</i> (2nd ed.). Englewood Cliffs,, NJ: Prentice Hall.</li>
  </ol>

</div>
